<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!--
MIT License

Copyright (c) 2020 Viresh Ratnakar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

The latest code and documentation for Exet can be found at:
https://github.com/viresh-ratnakar/exet

Current version: v0.33 March 13 2021
-->

<link rel="stylesheet" type="text/css" href="exolve-m.css?v1.00"/>
<script src="exolve-m.js?v1.00"></script>
<script src="lufz-en-lexicon.js"></script>

<style>
[contenteditable="true"]:active,
[contenteditable="true"]:focus{
  border:none;
  outline:none;
}
.xet-frame {
  width: 940px;
  margin: 0 8px;
  box-sizing: border-box;
  font-family: monospace;
  font-size: 14px;
}
.xet-controls-col {
  padding: 4px;
}
.xet-frame hr {
  margin-left: 0;
  margin-right: 0;
}
.xet-tab {
  height: 50px;
  border: 4px solid #ddd;
  border-bottom: 0;
  background-color: #ddd;
  border-radius: 10px 10px 0 0;
  overflow: auto;
}
.xet-tab button {
  font-size: 14px;
  width: 105px;
  height: 100%;
  background-color: inherit;
  float: left;
  outline: none;
  cursor: pointer;
  padding: 2px 4px;
  transition: 0.3s;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  border: 1px solid silver;
}
.xet-tab button:hover {
  background-color: #f0f0f0;
  border-bottom: 0;
  cursor: pointer;
}
.xet-tab button.active {
  background-color: white;
  border-bottom: 0;
}
.xet-tabcontent {
  display: none;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
}
.xet-td {
  vertical-align: top;
}
.xet-iframe {
  width: 910px;
  border: 0;
  overflow: auto;
}
.xet-panel {
  width: 910px;
  border: 0;
  overflow: auto;
}
.xet-section {
  border: 0;
}
.xet-high-tall-box {
  height: 450px;
}
.xet-mid-tall-box {
  height: 325px;
}
.xet-draft > td:first-child {
  color: gray;
}
.xet-draft-marker,
.xet-done-marker {
  font-size: 12px;
  font-family: monospace;
  color: gray;
}
.xet-done-marker {
  text-decoration: line-through;
  text-decoration-color: dodgerblue;
}
.xet-clue-stat {
  cursor: pointer;
  padding: 2px;
  border: 1px solid white;
}
.xet-clue-stat:hover {
  border: 1px solid dodgerblue;
  background: mistyrose;
}
.xet-anno {
  font-family: monospace;
  font-size: 14px;
  color: darkgreen;
}
.xlv-curr-clue-label {
  cursor: pointer;
}
.xlv-curr-clue {
  font-family: monospace;
  font-weight: normal;
  font-size: 14px;
  padding: 2px 2px 4px 2px;
}
.xet-linking {
  position: absolute;
  top: -50px;
  z-index: 1;
  background-color: white;
  border: 1px solid dodgerblue;
  padding: 8px;
  color: darkgreen;
}
#xet-unlink {
  padding: 4px;
}
.xet-red {
  color: red;
}
.xet-blue {
  color: blue;
  text-decoration: none;
}
.xet-small {
  font-family: monospace;
  font-size: 10px;
}
.xet-bold {
  font-weight: bold;
}
.xet-controls-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: left;
}
.xet-scratch-pad,
.xet-controls-col {
  display: flex;
  flex-flow: column wrap;
  align-items: flex-start;
}
.xet-scratch-pad {
  padding: 0 0 6px;
}
.xet-choices-box {  
  overflow-y: auto;
  overflow-x: hidden;
  margin: 4px 0;
  border: 1px solid gray;
  border-collapse: collapse;
  box-sizing: border-box;
}
#xet-light-choices-box {  
  width: 30ch;
  height: 340px;
}
#xet-light-choices {  
  font-size: 16px;
}
.xet-choices {  
  table-layout: auto;
  margin: 0;
  padding: 0;
  width: 100%;
  color: #333;
  border: 1px solid gray;
  border-collapse: collapse;
  border-spacing: 0; 
  font-family: monospace;
  font-size: 12px;
}
.xet-choices td, .xet-choices th {
  border: 0;
  border-right: 1px solid gray;
  border-left: 1px solid gray;
  padding: 8px;
}
.xet-choices th {  
  background: #DFDFDF;
  font-weight: bold;
}
.xet-choices td {  
  background: #FAFAFA;
  text-align: left;
  cursor: pointer;
}
.xet-choices tr:nth-child(even) td { background: #F1F1F1; }   
.xet-choices tr:nth-child(odd) td { background: #FEFEFE; }  
.xet-choices:not(.xet-picked) tr:hover td {
  background: lightgreen;
}  
.xet-fill-settings {
  width: 300px;
  padding: 8px;
  margin: 0 8px 6px 0;
  border: 1px solid gray;
  font-family: monospace;
  font-size: 12px;
  box-sizing: border-box;
}
.xet-menu {
  position: relative;
  width:100%;
}
.xet-menu > ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
.xet-menu > ul > li {
  float: left;
}
.xet-metadata {
  text-align: center;
  padding: 8px 12px;
  width: 500px;
}
.xet-edit {
  color: darkgreen;
  cursor: auto;
}
.xet-dropbtn {
  display: inline-block;
  text-align: center;
  padding: 8px 12px;
  margin: 0;
  font-size: 14px;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  border: 1px solid transparent;
}
.xet-dropdown:hover .xet-dropbtn {
  background-color: #ddd;
  cursor: pointer;
  border: 1px solid gray;
}
.xet-menu li.xet-dropdown {
  display: inline-block;
}
.xet-dropdown-content,
.xet-dropdown-submenu {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 275px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
  margin: 0;
  border: 1px solid gray;
}
.xet-dropdown-submenu {
  bottom: 0;
  left: 100%;
}
.xet-autofill-panel {
  top: 0;
  bottom: auto;
}
.xet-dropdown-submenu textarea {
  background-color: #e9e9e9;
}
.xet-dropdown-div {
  line-height: 1.5;
}
.xet-dropdown-item,
.xet-dropdown-div,
.xet-dropdown-subitem {
  margin: 0;
  padding: 15px;
  display: block;
  text-align: left;
  position: relative;
}
.xet-dropdown-content .xet-dropdown-item:nth-child(odd) {
  background: #F1F1F1;
}   
.xet-dropdown-content .xet-dropdown-item:nth-child(even) {
  background: #FEFEFE;
}  
.xet-dropdown-content .xet-dropdown-item:hover {
  background-color: lightgreen;
  cursor: pointer;
}
.xet-dropdown-submenu .xet-dropdown-subitem:nth-child(odd) {
  background: #F1F1F1; }   
.xet-dropdown-submenu .xet-dropdown-subitem:nth-child(even) {
  background: #FEFEFE;
}  
.xet-dropdown-submenu .xet-dropdown-subitem:hover {
  background-color: #a1ffa1;
  cursor: pointer;
}
.xet-dropdown-item:hover .xet-dropdown-submenu {
  display: block;
}
.xet-analysis {
  width: 640px;
  height: 440px;
  overflow: auto;
  padding: 6px 6px 6px 16px;
  background-size: 20px 20px;
  background-image:
    linear-gradient(to right, gainsboro 1px, transparent 1px),
    linear-gradient(to bottom, gainsboro 1px, transparent 1px);
}
.xet-analysis li {
  margin-top: 14px;
}
.xet-plotbar {
  background: dodgerblue;
  height: 16px;
  margin: 2px;
}
.xet-frame .xlv-clues {
  font-size: 16px;
  font-family: serif;
  font-weight: 400;
  line-height: normal;
  box-sizing: border-box;
}
.xlv-frame .xlv-clues td:not(:first-child) {
  padding: 4px 0 0 0;
}
.xet-frame .xlv-clues {
  width: 610px;
}
.xet-clues-box {
  width: 625px;
}
.xet-rev-chooser {
  position: absolute;
  z-index: 1;
  background-color: white;
  border: 1px solid gray;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  font-size: 12px;
}
.xet-chosen {
  font-weight: bold;
  color: darkgreen;
}
.xet-editable {
  outline: 1px solid lightgreen;
  padding: 4px;
  line-height: 1.8;
}
.xet-editable[contenteditable] {
  outline: 1px solid lightgreen;
}
.xet-action {
  color: dodgerblue;
  font-weight: normal;
  font-family: serif;
  font-size: 14px;
  font-style: italic;
  margin: 4px 0;
}
#xet-scratch-pad {
  margin: 0 6px 0 0;
}
.xet-icon {
  padding: 0;
  height: 25px;
  width: 25px;
}
.xet-companag {
  padding: 0 0 8px 0;
  overflow: auto;
}
.xet-companag-text {
  color: blue;
  font-family: monospace;
  font-size: 14px;
}
.xet-table-midline td:nth-child(2) {
  border-left: 1px solid gray;
  padding-left: 4px;
}
.xet-table-midline td {
  padding-top: 4px;
}
.xet-table-midline {
  margin-top: 10px;
}
.xet-preview {
  height: 300px;
  width:800px;
  overflow:auto;
}
.xet-full-width {
  width: 100%;
}
#xet-charade-choices td {
  padding: 3px 0;
}
.xet-sweeping-box {
  display: inline-block;
  position: absolute;
  height: 31px;
  width: 31px;
  right: 0;
  bottom: -22px;
}
@keyframes xet-sweeping {
  from {
    width: 0; height: 0; border-radius: 0;
    left: 15.5px; top: 15.5px; background: red;
  }
  to {
    width: 10px; height: 10px; border-radius: 5px;
    left: 10.5px; top: 10.5px; background: red;
  }
}
.xet-sweeping,
.xet-sweeping-animated {
  position: absolute;
}
.xet-sweeping {
  left: 15.5px;
  top: 15.5px;
  width: 0;
  height: 0;
  border-radius: 0;
}
.xet-sweeping-animated {
  animation-name: xet-sweeping;
  animation-duration: 2s;
  animation-direction: alternate;
  animation-iteration-count: infinite;
}
.xet-preflex-editor {
  position: absolute;
  left: 0;
  top: 0;
  padding: 8px;
  z-index: 1;
  background-color: white;
  border: 1px solid gray;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  font-size: 12px;
}
.xet-autofill-panel {
  padding: 4px;
  min-width: 400px;
}
.xet-autofill-panel .xlv-button {
  margin: 2px 6px 4px;
}
#xet-outdated-message,
#xet-outdated {
  color: red;
  font-weight: bold;
}
#xet-minpop {
  text-align: right;
}
#xet-save-warnings {
  padding: 2px 15px;
}
.xet-pink-button {
  background-color: salmon !important;
}
.xet-pink-button:hover {
  background-color: red !important;
}
</style>

<title>Exet: Create a crossword</title>

</head>
<body>

<div id="xet-xlv-frame">
</div>

<script>

function ExetModals() {
  this.modal = null;
  document.addEventListener('click', this.handleClick.bind(this));
};

ExetModals.prototype.handleClick = function(e) {
  if (!this.modal) {
    return
  }
  if (!this.modal.contains(e.target)) {
    this.hide()
  }
}

// If caller calls this in response to a click event e, then caller should also
// call e.stopPropagation().
ExetModals.prototype.showModal = function(elt) {
  this.hide()
  if (!elt) {
    return
  }
  this.modal = elt;
  this.modal.style.display = 'block'
}

ExetModals.prototype.hide = function() {
  if (!this.modal) {
    return
  }
  this.modal.style.display = 'none'
  this.modal = null;
}

function ExetRevManager() {
  this.REV_LOADED_FROM_FILE = 1
  this.REV_CREATED_BLANK = 2
  this.REV_CREATED_AUTOBLOCK = 3
  this.REV_JUMPED_TO_REV = 10
  this.REV_GRID_CHANGE = 20
  this.REV_AUTOFILL_GRIDFILL_CHANGE = 28
  this.REV_GRIDFILL_CHANGE = 30
  this.REV_ENUM_CHANGE = 40
  this.REV_CLUE_CHANGE = 50
  this.REV_METADATA_CHANGE = 60
  this.REV_PREFLEX_CHANGE = 70

  this.revMsgs = {}
  this.revMsgs[this.REV_LOADED_FROM_FILE] = "Loaded from a file"
  this.revMsgs[this.REV_CREATED_BLANK] = "Created a blank grid"
  this.revMsgs[this.REV_CREATED_AUTOBLOCK] = "Created a blank grid " +
      "with automagic blocks"
  this.revMsgs[this.REV_JUMPED_TO_REV] = "Jumped to a previous revision"
  this.revMsgs[this.REV_GRID_CHANGE] = "Grid change"
  this.revMsgs[this.REV_AUTOFILL_GRIDFILL_CHANGE] = "Autofilled grid-fill " +
      "change"
  this.revMsgs[this.REV_GRIDFILL_CHANGE] = "Grid-fill change"
  this.revMsgs[this.REV_ENUM_CHANGE] = "Enum change"
  this.revMsgs[this.REV_CLUE_CHANGE] = "Clue or anno change"
  this.revMsgs[this.REV_METADATA_CHANGE] = "Metadata change"
  this.revMsgs[this.REV_PREFLEX_CHANGE] = "Change in the list of preferred " +
      "words"

  // State for throttled revision-saving
  this.throttleRevTimer = null;
  this.saveLagMS = 5000
  this.throttlingLastRev = 0;

  // Special localStorage key for storing preferences and state
  this.SPECIAL_KEY = '42-exet-42'
  this.spaceUsedAtStart = 0
  for (let idx = 0; idx < window.localStorage.length; idx++) {
    let id = window.localStorage.key(idx)
    this.spaceUsedAtStart += window.localStorage.getItem(id).length
  }
  this.spaceUsed = this.spaceUsedAtStart

  let k500 = '1234567812345678'
  while (k500.length < 500000) {
    k500 = k500 + k500
  }
  let tempKey = '42-exet-cap-42-'
  this.spaceLeftAtStart = 0
  for (let i = 0; i < 20; i++) {
    // Only count up to 10 MB
    try {
      window.localStorage.setItem(tempKey + i, k500)
      this.spaceLeftAtStart += k500.length
    } catch (err) {
      break
    }
  }
  for (let i = 0; i < 20; i++) {
    window.localStorage.removeItem(tempKey + i)
  }

  // Id for previews
  this.previewId = `exet-preview-${Math.random().toString(36).substring(2, 8)}`
};

ExetRevManager.prototype.inMB = function(num) {
  return (num / 1000000).toFixed(2)
}

ExetRevManager.prototype.choosePuzRev = function(manageStorage,
                                                 puz, elt, callback) {
  let choices = []
  if (puz) {
    let stored = window.localStorage.getItem(puz.id)
    let spaceUsed = stored.length
    choices = [{id: puz.id, title: puz.title, space: spaceUsed}]
  } else {
    this.spaceUsed = 0
    for (let idx = 0; idx < window.localStorage.length; idx++) {
      let id = window.localStorage.key(idx)
      let stored = window.localStorage.getItem(id)
      let spaceUsed = stored.length
      this.spaceUsed += spaceUsed
      if (id == this.SPECIAL_KEY) {
        continue
      }
      try {
        stored = JSON.parse(stored)
      } catch (err) {
        continue
      }
      if (!stored || !stored["id"] || !stored["revs"] || !stored["maxRevNum"]) {
        continue
      }
      let title = ''
      if (stored.revs.length > 0) {
        title = stored.revs[stored.revs.length - 1].title
      }
      choices.push({id: stored.id, title: title, space: spaceUsed})
    }
  }
  let html = `
  <table>
    <tr>
      <td><i>Select puzzle ID/Title</i></td>
      <td>
        <i>Select revision</i>
      </td>
    </tr>
    <tr>
      <td>
        <div class="xet-choices-box" id="xet-choose-id">
          <table class="xet-choices" id="xet-id-choices">`
  for (let i = 0; i < choices.length; i++) {
    html = html + `
      <tr id="xet-id-choice-${i}">
        <td>${choices[i].id}</td>
        <td>${choices[i].title}</td>
        <td>${this.inMB(choices[i].space)} MB</td></tr>`
  }
  html = html + `
          </table>
        </div>
      </td>
      <td>
        <div class="xet-choices-box" id="xet-choose-rev">
          <table class="xet-choices" id="xet-rev-choices">
          </table>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div>
          <span>Space used: ${this.inMB(this.spaceUsed)} MB</span>
          <span>Space available: <span
            class="xet-red">${this.inMB(this.spaceUsedAtStart +
              this.spaceLeftAtStart - this.spaceUsed)}</span> MB</span>
          <button id="xset-puz-rev-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete rev</button>
          <button id="xset-puz-prior-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete older revs!</button>
          <button id="xset-puz-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete!</button>
          <button id="xset-puz-rev-selector"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Open</button>
        </div>
        <div id="xet-preview" class="xet-preview">
        </div>
      </td>
    </tr>
  </table>
  `
  elt.innerHTML = html
  this.idChoicesBox = document.getElementById('xet-choose-id')
  this.idChoicesBox.style.width = '270px'
  this.idChoicesBox.style.height = '200px'
  this.idChoices = document.getElementById('xet-id-choices')
  this.revChoicesBox = document.getElementById('xet-choose-rev')
  this.revChoicesBox.style.width = '500px'
  this.revChoicesBox.style.height = '200px'
  this.revChoices = document.getElementById('xet-rev-choices')
  this.preview = document.getElementById('xet-preview')
  this.idChoice = ''
  this.revChoice = -1
  this.puzDeleter = document.getElementById('xset-puz-deleter')
  this.puzPriorDeleter = document.getElementById('xset-puz-prior-deleter')
  this.puzRevDeleter = document.getElementById('xset-puz-rev-deleter')
  this.puzRevSelector = document.getElementById('xset-puz-rev-selector')
  this.manageStorage = manageStorage
  if (manageStorage) {
    this.puzDeleter.style.display = ''
    this.puzPriorDeleter.style.display = ''
    this.puzRevDeleter.style.display = ''
    this.puzDeleter.disabled = true
    this.puzPriorDeleter.disabled = true
    this.puzRevDeleter.disabled = true
    let deleter = (types, e) => {
      if (!confirm('Are you sure you want to delete ' + types +
                   ' revision(s)?')) {
        return
      }
      this.idChoices.className = 'xet-choices'
      this.revChoices.className = 'xet-choices'
      if (types == 'all') {
        window.localStorage.removeItem(this.idChoice)
      } else {
        if (this.revChoice < 0 || !this.storedRevs ||
            this.storedRevs.revs.length == 0 ||
            this.revChoice >= this.storedRevs.revs.length) {
          console.log('Weird, did not find revChoice/storedRevs to delete from')
          return
        }
        let lastToDelete = this.revChoice
        if (types == 'prior') lastToDelete--
        let numToDelete = (types == 'prior' ? lastToDelete + 1 : 1)
        let newRevs = []
        if (lastToDelete - numToDelete >= 0) {
          newRevs = this.storedRevs.revs.slice(
              0, lastToDelete - numToDelete + 1)
        }
        this.storedRevs.revs = newRevs.concat(
            this.storedRevs.revs.slice(lastToDelete + 1))
        this.saveLocal(this.idChoice, JSON.stringify(this.storedRevs))
      }
      this.choosePuzRev(true, null, exet.revChooser, null)
      e.stopPropagation()
    }
    this.puzDeleter.addEventListener('click', deleter.bind(this, 'all'))
    this.puzPriorDeleter.addEventListener('click', deleter.bind(this, 'prior'))
    this.puzRevDeleter.addEventListener('click', deleter.bind(this, 'this'))
  } else {
    this.puzRevSelector.style.display = ''
    this.puzRevSelector.disabled = true
    this.puzRevSelector.addEventListener('click', e => {
      if (this.revChoice < 0 || !this.storedRevs ||
          this.storedRevs.revs.length == 0 ||
          this.revChoice >= this.storedRevs.revs.length) {
        console.log('Hmm: bad selection! Check ExetRevManager:')
        console.log(this)
        return
      }
      exetModals.hide()
      this.idSelectors = []
      this.revSelectors = []
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      callback(this.storedRevs.revs[this.revChoice])
    })
  }

  this.idSelectors = []
  this.revSelectors = []
  this.storedRevs = null
  if (puz) {
    this.idChoice = puz.id
    document.getElementById("xet-id-choice-0").className = 'xet-chosen'
    this.chooseRev()
    return
  }
  for (let i = 0; i < choices.length; i++) {
    let selector = document.getElementById(`xet-id-choice-${i}`)
    this.idSelectors.push(selector)
    let id = choices[i].id
    selector.addEventListener('click', e => {
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      this.puzDeleter.disabled = true
      this.puzPriorDeleter.disabled = true
      this.puzRevDeleter.disabled = true
      this.revChoices.innerHTML = ''
      this.revChoices.className = 'xet-choices'
      this.revChoice = -1
      this.revSelectors = []
      this.storedRevs = null
      this.puzRevSelector.disabled = true
      if (id == this.idChoice) {
        this.idChoice = null
        selector.className = ''
        this.idChoices.className = 'xet-choices'
      } else {
        for (let j = 0; j < choices.length; j++) {
          if (j != i) {
            this.idSelectors[j].className = ''
          }
        }
        this.idChoice = id
        this.puzDeleter.disabled = false
        selector.className = 'xet-chosen'
        this.idChoices.className = 'xet-choices xet-picked'
        this.chooseRev()
      }
    })
  }
};

Exet.prototype.renderPreview = function(spec, eltId) {
  let newPuz = new Exolve(spec, eltId, null, false, 0, 400, false)
  document.getElementById(
      `${newPuz.prefix}-controls-etc`).style.display = 'none';
  document.getElementById(
      `${newPuz.prefix}-curr-clue-parent`).style.display = 'none'
  newPuz.revealAll(false)
}

ExetRevManager.prototype.chooseRev = function() {
  let stored = window.localStorage.getItem(this.idChoice)
  if (!stored) {
    return
  }
  this.storedRevs = JSON.parse(stored)
  let html = ''
  for (let idx = this.storedRevs.revs.length - 1; idx >= 0; idx--) {
    let rev = this.storedRevs.revs[idx]
    let revTime = new Date(rev.timestamp)
    html = html + `
      <tr id="xet-rev-choice-${idx}">
        <td>${rev.title}</td>
        <td>#${rev.revNum}</td>
        <td>${revTime.toLocaleString()}</td>
        <td>${exetRevManager.revMsgs[rev.revType]}</td>
        <td>${rev.details}</td>
      </tr>`
  }
  this.revChoices.innerHTML = html
  this.revSelectors = []
  this.revChoice = -1
  for (let i = 0; i < this.storedRevs.revs.length; i++) {
    let selector = document.getElementById(`xet-rev-choice-${i}`)
    this.revSelectors.push(selector)
    selector.addEventListener('click', e => {
      if (!this.storedRevs) {
        return
      }
      this.puzPriorDeleter.disabled = true
      this.puzRevDeleter.disabled = true
      this.puzRevSelector.disabled = true
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      if (i == this.revChoice) {
        this.revChoice = -1
        selector.className = ''
        this.revChoices.className = 'xet-choices'
      } else {
        for (let j = 0; j < this.revSelectors.length; j++) {
          if (j != i) {
            this.revSelectors[j].className = ''
          }
        }
        this.revChoice = i
        selector.className = 'xet-chosen'
        this.revChoices.className = 'xet-choices xet-picked'
        let exolve = this.storedRevs.revs[i].exolve.replace(
            /exolve-id:[ ]*[a-zA-Z0-9-]*/, `exolve-id: ${this.previewId}`)
        exet.renderPreview(exolve, "xet-preview")
        this.puzPriorDeleter.disabled = (i <= 0)
        this.puzRevDeleter.disabled = false
        this.puzRevSelector.disabled = false
      }
    })
  }
};

ExetRevManager.prototype.saveLocal = function(k, v) {
  try {
    window.localStorage.setItem(k, v)
  } catch (err) {
    alert('No available local storage left. Please use the "Manage storage" ' +
          'menu option to free up some space.')
    console.log('Could not save value of length ' + v.length + ' for key: ' + k)
  }
}

ExetRevManager.prototype.saveRev = function(revType, details="") {
  if (!exet || !exet.puz || !exet.puz.id) {
    console.log('Cannot save revision when there is no puzzle!')
    return
  }
  let stored = window.localStorage.getItem(exet.puz.id)
  if (!stored) {
    stored = {
      id: exet.puz.id,
      maxRevNum: 0,
      revs: []
    }
  } else {
    stored = JSON.parse(stored)
  }
  let exolve = exet.getExolve()
  if (stored.revs.length > 0) {
    let lastRev = stored.revs[stored.revs.length - 1]
    if (lastRev.exolve == exolve &&
        lastRev.prefix == exet.prefix && lastRev.suffix == exet.suffix &&
        lastRev.scratchPad == exet.puz.scratchPad.value &&
        lastRev.preflex &&
        JSON.stringify(lastRev.preflex) == JSON.stringify(exet.preflex) &&
        lastRev.unpreflex &&
        JSON.stringify(lastRev.unpreflex) == JSON.stringify(exet.unpreflex) &&
        lastRev.noProperNouns == exet.noProperNouns &&
        lastRev.minpop == exet.minpop) {
      return
    }
  }
  stored.maxRevNum++;
  let exetRev = new ExetRev(exet.puz.id, (exet.puz.title ? exet.puz.title : ''),
                            stored.maxRevNum, revType, Date.now(), details)
  exetRev.maxRevNum = stored.maxRevNum
  exetRev.prefix = exet.prefix
  exetRev.suffix = exet.suffix
  exetRev.exolve = exolve
  exetRev.scratchPad = exet.puz.scratchPad.value
  exetRev.navState = [exet.puz.currDir, exet.puz.currRow, exet.puz.currCol]
  exetRev.preflex = exet.preflex
  exetRev.unpreflex = exet.unpreflex
  exetRev.noProperNouns = exet.noProperNouns
  exetRev.minpop = exet.minpop
  stored.revs.push(exetRev)
  this.saveLocal(exet.puz.id, JSON.stringify(stored))
};

ExetRevManager.prototype.throttledSaveRev = function(revType, details="") {
  let urgent = revType <= 10;
  if (this.throttleRevTimer) {
    clearTimeout(this.throttleRevTimer);
    if (this.throttlingRevType > 0 && revType < this.throttlingRevType) {
      urgent = true
    }
  }
  this.throttleRevTimer = null;
  this.throttlingRevType = 0;
  if (urgent) {
    this.saveRev(revType, details)
    return
  }
  this.throttlingRevType = revType;
  this.throttleRevTimer = setTimeout(() => {
    this.saveRev(revType, details)
    this.throttleRevTimer = null;
    this.throttlingRevType = 0;
  }, this.saveLagMS);
}

ExetRevManager.prototype.saveAllRevisions = function() {
  const storage = {}
  for (let idx = 0; idx < window.localStorage.length; idx++) {
    let id = window.localStorage.key(idx)
    if (id == this.SPECIAL_KEY) {
      continue
    }
    let storedRevsBlob = window.localStorage.getItem(id)
    let storedRevs = null
    try {
      storedRevs = JSON.parse(storedRevsBlob)
    } catch (err) {
      continue
    }
    if (!storedRevs || !storedRevs['revs']) {
      continue
    }
    storage[id] = storedRevs
  }
  const json = JSON.stringify(storage, null, 2)
  const a = document.createElement('a');
  a.style.display = 'none';
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([json], {type: 'text/json'})
  );
  let filename = `exet-revisions-${(new Date()).toISOString()}.json`
  a.setAttribute('download', filename)
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

ExetRevManager.prototype.mergeRevisionsFile = function() {
  exetModals.hide()
  let fr = new FileReader(); 
  fr.onload = function(){ 
    let allSavedRevs = {}
    try {
      allSavedRevs = JSON.parse(fr.result)
    } catch (err) {
      alert('Could not parse the saved revisions file')
      return
    }
    existingRevs = {}
    for (let idx = 0; idx < window.localStorage.length; idx++) {
      let id = window.localStorage.key(idx)
      if (id == this.SPECIAL_KEY) {
        continue
      }
      let storedRevsBlob = window.localStorage.getItem(id)
      let storedRevs = null
      try {
        storedRevs = JSON.parse(storedRevsBlob)
      } catch (err) {
        continue
      }
      if (!storedRevs || !storedRevs['revs']) {
        continue
      }
      for (rev of storedRevs['revs']) {
        const revHash = exet.javaHash(JSON.stringify(rev))
        existingRevs[revHash] = true
      }
    }
    let numRevs = 0
    let numRevsMerged = 0
    let numDupRevs = 0
    let numNonLatest = 0
    const mergeOnlyLatest = document.getElementById(
      'xet-merge-only-latest-revs').checked ? true : false;
    for (let id in allSavedRevs) {
      savedRevs = allSavedRevs[id]['revs']
      if (!savedRevs || savedRevs.length == 0) {
        continue
      }
      const start = mergeOnlyLatest ? savedRevs.length - 1 : 0
      if (mergeOnlyLatest) {
        numNonLatest += savedRevs.length - 1
      }
      revsToSplice = []
      for (let i = start; i < savedRevs.length; i++) {
        numRevs++
        const rev = savedRevs[i]
        const revHash = exet.javaHash(JSON.stringify(rev))
        if (existingRevs[revHash]) {
          numDupRevs++
          continue
        }
        revsToSplice.push(rev) 
      }
      if (revsToSplice.length == 0) {
        continue
      }
      let stored = window.localStorage.getItem(id)
      if (stored) {
        try {
          stored = JSON.parse(stored)
        } catch (err) {
          console.log('Skipped id in merging as JSON.parse() failed, id: ' + id)
          continue;
        }
      }
      if (!stored) {
        stored = { id: id, maxRevNum: 0, revs: [] }
      }
      for (rev of revsToSplice) {
        stored['revs'].push(rev)
      }
      stored['revs'].sort((r1, r2) => r1.timestamp - r2.timestamp);
      for (rev of stored['revs']) {
        if (rev.revNum > stored.maxRevNum) {
          stored.maxRevNum = rev.revNum
        }
      }
      exetRevManager.saveLocal(id, JSON.stringify(stored))
      numRevsMerged += revsToSplice.length
    }
    const ignored = (numNonLatest > 0) ?
        `Ignored ${numNonLatest} non-latest revisions.` : '';
    alert(`From ${numRevs} revisions considered across ` +
          `${Object.keys(allSavedRevs).length} crosswords, merged ` +
          `${numRevsMerged} revisions. There were ${numDupRevs} revisions ` +
          `that already existed. ${ignored}`);
  } 
  let f = document.getElementById('xet-merge-revs-file').files[0]
  fr.readAsText(f)
}

function ExetRev(id, title, revNum, revType, timestamp, details="") {
  this.id = id;
  this.title = title
  this.revNum = revNum;
  this.revType = revType;
  this.timestamp = timestamp;
  this.details = details;
  // prefix, suffix, exolve should be set directly.
};

function Exet() {
  this.version = 'v0.33 March 13 2021'
  this.puz = null
  this.prefix = ''
  this.suffix = ''
  this.otherSections = ''
  this.preflex = []
  this.unpreflex = {}
  this.noProperNouns = false
  this.DEFAULT_MINPOP = 85
  this.setMinPop(this.DEFAULT_MINPOP)
  this.DRAFT = '[DRAFT]'

  // Start in the Exet tab
  this.currTab = "exet"
  this.savedIndsSelect = ""

  // State for throttled handlers
  this.throttledGridTimer = null;
  this.throttledPreflexTimer = null;
  this.throttledUnpreflexTimer = null;
  this.throttledClueTimer = null;
  this.throttledMetadataTimer = null;
  this.throttledCharadeTimer = null;
  this.viabilityUpdateTimer = null;
  this.inputLagMS = 400
  this.sweepMS = 500

  // Params for light choices shown.
  this.sweepMaxChoices = 500
  this.sweepMaxChoicesSmall = 4
  this.shownLightChoices = 200

  // Set of all letters in the lexicon.
  this.allLetters = {}
  for (let c of exetLexicon.letters) {
    this.allLetters[c.toUpperCase()] = true
  }
};

Exet.prototype.setMinPop = function(m) {
  if (m < 0) m = 0
  this.minpop = m
  this.indexMinPop = Math.floor(exetLexicon.startLen * (100 - m) / 100)
}

Exet.prototype.startNav = function(dir='A', row=0, col=0) {
  if (!this.puz) return;
  if (row < 0 || row >= this.puz.gridHeight ||
      col < 0 || col >= this.puz.gridWidth) {
    row = 0
    col = 0
  }
  if (dir != 'A' && dir != 'D') {
    dir = 'A'
    let gridCell = this.puz.grid[row][col]
    if (gridCell.isLight && !gridCell.acrossClueLabel &&
        gridCell.downClueLabel) {
      dir = 'D'
    }
  }
  this.puz.currRow = row
  this.puz.currCol = col
  this.puz.currDir = dir
  if (this.puz.grid[row][col].isLight) {
    this.puz.activateCell(row, col)
  } else {
    this.navDarkness(row, col)
  }
}

Exet.prototype.setPuzzle = function(puz) {
  if (puz.hasDgmlessCells) {
    alert('Diagramless cells not yet supported')
    return false
  }
  if (puz.hasNodirClues) {
    alert('Nodir clues not yet supported')
    return false
  }
  if (puz.offNumClueIndices.length > 0) {
    alert('Non-numeric clues not yet supported')
    return false
  }
  if (puz.columnarLayout) {
    puz.columnarLayout = false;
    puz.gridcluesContainer.className = 'xlv-grid-and-clues-flex'
    puz.cluesContainer.className = 'xlv-clues xlv-clues-flex'
  }
  let gridFillChanges = false
  for (let i = 0; i < puz.gridHeight; i++) {
    for (let j = 0; j < puz.gridWidth; j++) {
      let gridCell = puz.grid[i][j]
      if (gridCell.skipNum) {
        alert('Skipped-number cells not yet supported')
        return false
      }
      if (gridCell.solution == '0') {
        gridCell.solution = '?'
        gridFillChanges = true
      }
    }
  }
  this.puz = puz
  puz.revealAll(false)

  if (!this.prefix && !this.suffix) {
    this.prefix = '' +
        '<!DOCTYPE html>\n' +
        '<html lang="en">\n' +
        '<head>\n' +
        '<meta charset="utf-8"/>\n' +
        '<meta name="viewport" ' +
            'content="width=device-width, initial-scale=1"/>\n' +
        '<link rel="stylesheet" type="text/css" href="' +
            exetState.exolveUrl + 'exolve-m.css"/>\n' +
        '<script src="' + exetState.exolveUrl + 'exolve-m.js"><\/script>\n' +
        '<\/head>\n' +
        '<body>\n' +
        '<script>\n' +
        'createExolve(`'
    this.suffix = '' +
        '`);\n' +
        '<\/script>\n' +
        '<\/body>\n' +
        '<\/html>\n'
  }
  this.otherSections = ''
  for (let l = 0; l < puz.numLines; l++) {
    if (puz.specLines[l].trim().startsWith('exolve-end')) {
      break
    }
    if (puz.specLines[l].trim().startsWith('exolve-id')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-title')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-setter')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-copyright')) {
      continue
    }
    if (puz.gridFirstLine && puz.gridLastLine &&
        l >= puz.gridFirstLine - 1 && l <= puz.gridLastLine) {
      continue
    }
    if (puz.acrossFirstLine && puz.acrossLastLine &&
        l >= puz.acrossFirstLine - 1 && l <= puz.acrossLastLine) {
      continue
    }
    if (puz.downFirstLine && puz.downLastLine &&
        l >= puz.downFirstLine - 1 && l <= puz.downLastLine) {
      continue
    }
    if (puz.makerFirstLine && puz.makerLastLine &&
        l >= puz.makerFirstLine - 1 && l <= puz.makerLastLine) {
      continue
    }
    this.otherSections = this.otherSections + puz.specLines[l] + '\n'
  }

  if (gridFillChanges) {
    this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
    return;
  }

  let clueChanges = false
  let numA = 0
  let numD = 0
  for (let idx in puz.clues) {
    let clue = puz.clues[idx]
    if (clue.dir == 'A') numA++
    else if (clue.dir == 'D') numD++
    if (!clue.clue) {
      clue.clue = this.draftClue(idx);
      clueChanges = true
      break
    }
    // Restore enum possibly hidden by *
    const parseEnum = this.puz.parseEnum(clue.clue)
    if (parseEnum.enumLen == 0 && clue.enumStr) {
      clue.clue += ' ' + clue.enumStr
      clueChanges = true
      break
    }
    this.renderClue(clue)
  }
  if (clueChanges) {
    this.updatePuzzle(exetRevManager.REV_CLUE_CHANGE)
    return;
  }

  // No more updatePuzzle() calls below inside this function: we're
  // satisfied with what we have and do not need to tweak it.

  puz.gridInput.addEventListener('keydown', this.handleKeyDown.bind(this));
  puz.gridInput.addEventListener('input', this.throttledGridInput.bind(this));

  this.tabs = {
    "exet": {
      id: "exet",
      display: "Exet",
      hover: "Main Exet functions: load, save, grid-fill, edit, etc...",
      sections: [],
      url: "",
    },
    "dicts": {
      id: "dicts",
      display: "Dictionaries",
      hover: "Chambers, The Free Dictionary, Onelook, Google, Etymonline: " +
             "definitions, roots, synonyms, encycolopedia...",
      sections: [],
    },
    "wordplay0": {
      id: "wordplay0",
      display: "Charades",
      hover: "Charades, including anagrams, reversals, and containers...",
      sections: [{id: "xet-charades", maker: this.makeCharadeParam,
                  title: "Charades, including anagrams, reversals, and " +
                         "containers"}],
    },
    "wordplay1": {
      id: "wordplay1",
      display: "Anagrams",
      hover: "Nutrimatic anagrams, composite anagrams...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeAnagramParam,
         title: "Anagrams"},
        {id: "xet-companag", maker: this.makeCAParam,
         title: "Composite and extended anagrams"},
      ],
    },
    "wordplay2": {
      id: "wordplay2",
      display: "Hidden",
      hover: "Nutrimatic: hidden answers and reversed hidden answers...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeHiddenParam,
         title: "Hidden answers"},
        {url: "https://nutrimatic.org/?q=", maker: this.makeRevHiddenParam,
         title: "Reversed hidden answers"},
      ]
    },
    "alternations": {
      id: "alternations",
      display: "Alternations",
      hover: "Nutrimatic: alternations and reversed alternations...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeAlternationParam,
         title: "Alternations"},
        {url: "https://nutrimatic.org/?q=", maker: this.makeRevAlternationParam,
         title: "Reversed alternations"},
      ]
    },
    "inds": {
      id: "inds",
      display: "Lists",
      hover: "Crossword Unclued, Wikipedia: cryptic indicators and " +
             "abbreviations lists...",
      sections: [],
    },
  }

  this.replaceHandlers()
  document.getElementById(`${this.puz.prefix}-controls`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-saving`).style.display = 'none'
  document.getElementById(
      `${this.puz.prefix}-tools-link`).style.display = 'none'
  document.getElementById(
      `${this.puz.prefix}-report-bug`).style.display = 'none'
  document.getElementById(
      `${this.puz.prefix}-exolve-link`).style.display = 'none'

  this.copyright = document.getElementById(`${this.puz.prefix}-copyright`)
  this.copyright.innerHTML = `<span class="xet-action">Edit optional
      copyright notice: Ⓒ &nbsp;</span><span
      class="xet-editable"
      id="xet-copyright" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.copyright}</span>`
  this.copyright.style.display = ''
  this.xetCopyright = document.getElementById('xet-copyright')

  this.title = document.getElementById(`${this.puz.prefix}-title`)
  this.title.innerHTML = `<span class="xet-action">Edit optional
      title:</span><span
      class="xet-editable"
      id="xet-title" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.title}</span>`
  this.title.style.display = ''
  this.xetTitle = document.getElementById('xet-title')

  this.setter = document.getElementById(`${this.puz.prefix}-setter`)
  this.setter.innerHTML = `<span class="xet-action">Edit optional
      setter(s):</span><span
      class="xet-editable"
      id="xet-setter" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.setter}</span>`
  this.setter.style.display = ''
  this.xetSetter = document.getElementById('xet-setter')

  // Make clues-box divs wider
  const cbs = document.getElementsByClassName('xlv-clues-box')
  for (let x = 0; x < cbs.length; x++) {
    cbs[x].style.width = '600px'
  }

  let aLabel = document.getElementById(`${this.puz.prefix}-across-label`)
  aLabel.insertAdjacentHTML('beforeend', ` (${numA} clues)`)
  let dLabel = document.getElementById(`${this.puz.prefix}-down-label`)
  dLabel.insertAdjacentHTML('beforeend', ` (${numD} clues)`)

  this.frame = document.createElement('div')
  this.frame.className = 'xet-frame'
  this.frame.id = 'xet-frame'
  this.puz.gridPanel.after(this.frame)

  delete this.shownChoicesHash
  this.populateFrame()

  // Add darkness and viability indicators ("viablots").
  for (let i = 0; i < puz.gridHeight; i++) {
    for (let j = 0; j < puz.gridWidth; j++) {
      let gridCell = puz.grid[i][j]
      if (gridCell.isLight && gridCell.solution == '?') {
        const viablot =
            document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        viablot.setAttributeNS(
            null, 'cx', puz.cellLeftPos(j, puz.circleR + puz.GRIDLINE));
        viablot.setAttributeNS(
            null, 'cy', puz.cellTopPos(i, puz.circleR + puz.GRIDLINE));
        viablot.setAttributeNS(null, 'class', 'xlv-cell-circle');
        viablot.style.fill = 'transparent'
        viablot.setAttributeNS(null, 'r', puz.circleR * 0.1);
        gridCell.viablot = viablot
        puz.svg.appendChild(viablot)
        viablot.addEventListener('click', puz.cellActivator.bind(puz, i, j));
      } else if (!gridCell.isLight) {
        const border = 4
        let darkness =
          document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        darkness.setAttributeNS(null, 'x', this.puz.cellLeftPos(
            j, this.puz.GRIDLINE + border))
        darkness.setAttributeNS(null, 'y', this.puz.cellTopPos(
            i, this.puz.GRIDLINE + border))
        darkness.setAttributeNS(null, 'width',
                                this.puz.squareDim - (2 * border));
        darkness.setAttributeNS(null, 'height',
                                this.puz.squareDim - (2 * border));
        darkness.style.fill = 'transparent'
        puz.svg.appendChild(darkness)
        gridCell.darkness = darkness
        darkness.addEventListener('click', this.navDarkness.bind(this, i, j))
      }
    }
  }

  // Display lexicon info
  const status = document.getElementById(`${this.puz.prefix}-status`)
  status.insertAdjacentHTML(
      'beforeend',
      `<span> Lexicon: ${exetLexicon.id} ${exetLexicon.language}
          ${exetLexicon.script}.</span>`)
  // Make the puzzle ID visible.
  const idDiv = document.getElementById(this.puz.prefix + '-id')
  if (idDiv) {
    status.insertAdjacentElement('beforebegin', idDiv)
  }

  // Display sweeping activity indicator
  const gridParent = document.getElementById(`${this.puz.prefix}-grid-parent`)
  gridParent.insertAdjacentHTML('beforeend',
    `<div class="xet-sweeping-box"
       title="When there is a flashing red circle here, Exet is ` +
       'autofilling and/or pruning away non-viable grid-fill suggestions ' +
       'in the background"> ' +
       '<div class="xet-sweeping" id="xet-sweeping"></div></div>')
  this.sweepIndicator = document.getElementById('xet-sweeping')

  this.puz.viable = true
  this.fillState = new ExetFillState(this.puz)

  this.initAutofill()
  this.resetViability();
  this.updateSweepInd()

  return true
}

Exet.prototype.makeExetTab = function() {
  let exetTab = this.tabs["exet"]
  exetTab.content.innerHTML = `
<div class="xet-controls-col">
  <div class="xet-menu">
    <ul>
      <li class="xet-dropdown">
        <div class="xet-dropbtn"
            title="Click to open a new or previously saved puzzle">Open</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" id="xet-show-puz-chooser">
            Choose a puzzle previously opened with Exet
          </div>
          <div class="xet-dropdown-item" id="xet-show-rev-chooser">
            Go back to a specific revision of the current puzzle
          </div>
          <div class="xet-dropdown-item">
            Open Exolve file: <input id="xet-file"
                onchange="exetLoadFile();" type="file"></input>
          </div>
          <div class="xet-dropdown-item">
            New grid:
            <div class="xet-dropdown-submenu">
              <div style="padding:4px;text-align:center">
                <div>
                  <input id="xet-w" name="xet-w" value="15"
                    type="text" size="3" maxlength="3" placeholder="W">
                  </input>
                  &times;
                  <input id="xet-h" name="xet-h" value="15"
                    type="text" size="3" maxlength="3" placeholder="H">
                  </input>
                </div>
                <br>
                <div>
                  Unique ID:
                  <input id="xet-id" name="xet-id"
                    value="xet-${Math.random().toString(36).substring(2, 8)}"
                    title="Please change to a meaningful alphanumeric id (beginning with a letter) to identify easily later"
                    type="text" size="15" maxlength="30" placeholder="alphanumeric unique id">
                  </input>
                </div>
                <br>
                <div title="When this is checked, Exet will automagically ` +
                  'add blocked cells to create a valid grid. You can ' +
                  'further edit the blocks and add more automagic blocks ' +
                  'from the Edit menu">' +
                  `Add automagic blocks:
                  <input id="xet-autoblock" name="xet-autoblock"
                      value="autoblock" checked=true type="checkbox">
                  </input>
                </div>
              </div>
              <hr>
              <div class="xet-controls-row">
                <div class="xet-dropdown-subitem"
                     title="Blocked with no top/left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, ` +
                      `document.getElementById('xet-h').value, ` +
                      `document.getElementById('xet-id').value, ` +
                      `document.getElementById('xet-autoblock').checked, ` +
                      `true, false, false);">
                  <img class="xet-icon" src="no-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem"
                     title="Blocked with top but not left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, ` +
                      `document.getElementById('xet-h').value, ` +
                      `document.getElementById('xet-id').value, ` +
                      `document.getElementById('xet-autoblock').checked, ` +
                      `true, true, false);">
                  <img class="xet-icon" src="t-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem"
                     title="Blocked with left but not top unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, ` +
                      `document.getElementById('xet-h').value, ` +
                      `document.getElementById('xet-id').value, ` +
                      `document.getElementById('xet-autoblock').checked, ` +
                      `true, false, true);">
                  <img class="xet-icon" src="l-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem"
                     title="Blocked with top/left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, ` +
                      `document.getElementById('xet-h').value, ` +
                      `document.getElementById('xet-id').value, ` +
                      `document.getElementById('xet-autoblock').checked, ` +
                      `true, true, true);">
                  <img class="xet-icon" src="tl-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="No blocks"
                  onclick="exetBlank(document.getElementById('xet-w').value, ` +
                      `document.getElementById('xet-h').value, ` +
                      `document.getElementById('xet-id').value, ` +
                      `document.getElementById('xet-autoblock').checked, ` +
                      `false);">
                  <img class="xet-icon" src="no-blocks.png"/>
                </div>
              </div>
            </div>
          </div>
          <hr>
          <hr>
          <div class="xet-dropdown-item" id="xet-manage-storage">
            Manage local storage (Used:
            ${exetRevManager.inMB(exetRevManager.spaceUsed)} MB
            Available: 
              <span class="xet-red">${exetRevManager.inMB(
                  exetRevManager.spaceUsedAtStart +
                  exetRevManager.spaceLeftAtStart -
                  exetRevManager.spaceUsed)}</span> MB)
          </div>
          <div class="xet-dropdown-item"
             onclick="exetRevManager.saveAllRevisions()">
            Save all revisions to file (exet-revisions-<i>timestamp</i>.json)
          </div>
          <div class="xet-dropdown-item">
            Merge saved revisions file:
            <input id="xet-merge-revs-file"
               onchange="exetRevManager.mergeRevisionsFile()" type="file"
               accept=".json"></input><br>
            <input id="xet-merge-only-latest-revs"
               name="xet-merge-only-latest-revs"
              checked=true value="merge-only-latest-revs" type="checkbox">
            </input>
            Take only the latest revision per crossword
          </div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to save, with some formatting options">Save</div>
        <div class="xet-dropdown-content" id="xet-save" title="The * shown in file names will be replaced by '-[title]', if there is a non-empty puzzle title">
          <div class="xet-dropdown-div">
            <b>Settings:</b>
            <div title="Set this option for American-style grids that do ` +
              `not show enums in clues">
              Show enums in clues:
              <input id="xet-show-enums" name="xet-show-enums"
                ${exetState.showEnums ? "checked=true" : ""}
                value="show-enums" type="checkbox">
              </input>
            </div>
            <div title="Change this to your own URL prefix for exolve-m.js ` +
              `and exolve-m.css. Only used when saving as Exolve if the ` +
              `Exolve data did not already have these URLs. Press Esc after ` +
              `clicking in the box to revert to default.">
              Exolve URL prefix:
              <input id="xet-xlv-url-prefix" name="xet-xlv-url-prefix"
                value="${exetState.exolveUrl}"
                placeholder="Press Esc after clicking in the box to revert ` +
                  `to default" type="text" size="40" maxlength="100">
              </input>
            </div>
          </div>
          <hr>
          <div id="xet-save-warnings" class="xet-dropdown-div xet-red"></div>
          <hr>
          <div class="xet-dropdown-item" onclick="exet.download(true)">
              Download Exolve file with solutions<br>(exet-exolve-<span
                  class="xet-filetitle"></span>-solved.html)</div>
          <div class="xet-dropdown-item" onclick="exet.download(false)">
              Download Exolve file without solutions<br>(exet-exolve-<span
                  class="xet-filetitle"></span>-unsolved.html)</div>
          <div class="xet-dropdown-item" onclick="exet.downloadDotPuz()">
              Download PUZ file<br>
              (exet-<span class="xet-filetitle"></span>.puz)
          </div>
          <div class="xet-dropdown-item"
              onclick="exet.toClipboard(true, 'xet-xlv-widget')">
            Copy Exolve widget code with solutions &#128203;
            <div class="xet-dropdown-submenu">
              <textarea rows="25" cols="40" id="xet-xlv-widget">
              </textarea>
            </div>
          </div>
          <div class="xet-dropdown-item"
              onclick="exet.toClipboard(false, 'xet-xlv-widget-nosol')">
            Copy Exolve widget code without solutions &#128203;
            <div class="xet-dropdown-submenu">
              <textarea rows="25" cols="40" id="xet-xlv-widget-nosol">
              </textarea>
            </div>
          </div>
          <div class="xet-dropdown-item" onclick="exet.print(true)">
              Print or download PDF file with solutions</div>
          <div class="xet-dropdown-item" onclick="exet.print(false)">
              Print or download PDF file without solutions</div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to make grid changes (please ` +
            `also note the listed keyboard shortcuts)">Edit</div>
        <div class="xet-dropdown-content">
          <div title="Try to autmatically add random blocks while ` +
              `maintaining a valid grid"
              class="xet-dropdown-item" onclick="exet.handleKeyDown('#')">
            Add automagic blocks (#)
          </div>
          <div title="Try to autofill the remaining grid"
              class="xet-dropdown-item" id="xet-start-autofill">Autofill:
            <div class="xet-dropdown-submenu xet-autofill-panel">
              <div>
                <button id="xet-autofill-startstop"
                    class="xlv-button">Start</button>
                <button id="xet-autofill-accept" style="float:right"
                    title="Accept autofill suggestions"
                    class="xlv-button">Accept</button>
                <button id="xet-autofill-clear" style="float:right"
                    title="Stop the autofill and clear all its suggestions"
                    class="xlv-button">Clear</button>
              </div>
              <hr>
              <div style="padding:4px">
                Beam search width:
                <input id="xet-autofill-max-beam" name="xet-autofill-max-beam"
                    value="64" type="text" size="4" maxlength="4"
                    style="padding:0;margin:0">
                </input>
              </div>
              <div style="padding:4px">
                Try to get a pangram:
                <input id="xet-autofill-boost-pangram"
                    name="xet-autofill-boost-pangram" value="pangram"
                    type="checkbox">
                </input>
              </div>
              <hr>
              <div style="padding:4px" title="You can edit the list of ` +
                  `preferred fills by clicking on the 'Set preferred fills' ` +
                  `button">
                Preferred fills used: <span
                  id="xet-autofill-preflex-used">0</span> of <span
                  id="xet-autofill-preflex-total">${this.preflex.length}</span>
              </div>
              <div title="You can edit the list of undesired fills, ` +
                  `restrict fills by a popularity cutoff, and allow/disallow ` +
                  `proper nouns by clicking on the 'Set fill exclusions' ` +
                  `button">
                <div style="padding:4px">
                  Min popularity: <span
                      id="xet-autofill-minpop">${this.minpop}</span> %ile
                  (<span id="xet-autofill-index-minpop">${Number(
                        this.indexMinPop).toLocaleString()}` +
                  `</span> entries)
                </div>
                <div style="padding:4px" title="You can edit the list of ` +
                    `undesired fills, restrict fills by a popularity cutoff, ` +
                    `and allow/disallow proper nouns by clicking on the 'Set ` +
                    `fill exclusions' button">
                  Proper nouns: <span
                      id="xet-autofill-proper-nouns">${this.noProperNouns ?
                          "disallowed" : "allowed"}</span>&nbsp;
                  Undesired fills: <span
                      id="xet-autofill-unpreflex-total">${Object.keys(
                          this.unpreflex).length}</span>
                </div>
              </div>
              <div style="padding:4px">
                Letters used: <span id="xet-autofill-pangram">0</span> of
                ${exetLexicon.letters.length}
              </div>
              <hr>
              <div style="padding:4px">
                Step: <span id="xet-autofill-step"></span> &nbsp
                Score: <span id="xet-autofill-score">0.00</span>
                <span style="font-size:12px">
                (<span id="xet-autofill-score-v">0.00</span> viab + 
                <span id="xet-autofill-score-f">0.00</span> full)
                </span>
              </div>
              <div style="padding:4px">
                Time taken: <span id="xet-autofill-time">--</span> ms
                (<span id="xet-autofill-speed">--</span> ms/step)
              </div>
              <div style="padding:4px">
                Last status: <span id="xet-autofill-status"></span>
                (beam width: <span id="xet-autofill-curr-beam"></span>)&nbsp;
              </div>
            </div>
          </div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('=')">
            Accept autofilled entries (=)</div>
          <hr>
          <hr>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('@')">
            Toggle encircling (@)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('!')">
            Toggle marking prefilled (!)</div>
          <hr>
          <hr>
          <table>
            <tr>
              <td>
              <div class="xet-dropdown-item" onclick="exet.handleKeyDown('.')">
                Toggle block (.)</div>
              <div class="xet-dropdown-item" onclick="exet.handleKeyDown('|')">
                Toggle bar-after (|)</div>
              <div class="xet-dropdown-item" onclick="exet.handleKeyDown('_')">
                Toggle bar-under (_)</div>
              </td>
              <td style="max-width:140px;padding:4px 10px"
                title="If you check this, then the next Toggle block/bar ` +
                    `will not automatically do the same on the symmetric cell">
                <input id="xet-asymmetry-ok" name="xet-asymmetry-ok"
                  value="asymmetric" type="checkbox" style="margin:6px 0">
                </input>
                <br>
                <i>Do not force symmetry on the next "Toggle block/bar"</i>
              </td>
            </tr>
          </table>
          <hr>
          <hr>
          <div class="xet-dropdown-item" onclick="exet.clearAll()">
              Clear all the lights!</div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to see analyses of the ` +
            `crossword (grid, grid-fill, clues)">Analysis</div>
        <div class="xet-dropdown-content xet-analysis" id="xet-analysis">
        </div>
      </li>
      <li class="xet-dropdown" style="float:right;">
        <div class="xet-dropbtn" id="xet-about" title="Click to see notes, ` +
            `notices, and pointers about Exet...">About <span
            id='xet-outdated' style='display:none'>&#9888;</span></div>
        <div class="xet-dropdown-content"
            style="right:0;width:90ch;padding:8px;">
          <div id="xet-outdated-message" style="display:none"></div>
          <iframe id="xet-about-iframe" class="xet-iframe"
              style="height:450px"
              src="about-exet.html">
          </iframe>
        </div>
      </li>
    </ul>
    <div id="xet-rev-chooser" class="xet-rev-chooser" style="display:none">
    </div>
  </div>
  <hr class="xet-full-width"/>
  <div id="xet-temp" style="display:none">
  </div>

  <div class="xet-controls-row xet-panel xet-high-tall-box">
    <div class="xet-controls-col" style="position:relative">
      <div>
        <span style="font-weight:bold" title="Please note that any lexicon ` +
            `in use by this software is inevitably likely to have some ` +
            `errors and omissions.">Choose grid-fill</span>
        <button class="xlv-small-button" style="padding:5px 4px"
            onclick="exet.clearCurr()">Clear light</button>
      </div>
      <div class="xet-choices-box" id="xet-light-choices-box">
        <table id="xet-light-choices" class="xet-choices">
        </table>
      </div>
      <div title="You can provide up to 100 preferred words/phrases to try ` +
          `and use in the grid-fill">
        <button class="xlv-small-button" style="padding:5px 4px"
          id="xet-edit-preflex">Set preferred fills</button>
        <span id="xet-preflex-used">0</span>/<span
          id="xet-preflex-size">${this.preflex.length}</span> used
      </div>
      <div title="You can provide words/phrases to exclude from the ` +
        `grid-fill, set a minimum popularity, and include/exclude proper nouns">
        <button class="xlv-small-button"
            style="padding:5px 4px;color:chocolate"
            id="xet-edit-unpreflex">Set fill exclusions</button>
        <span id="xet-unpreflex-size">${Object.keys(
            this.unpreflex).length}</span> set
      </div>
      <div class="xet-preflex-editor"
          title="Click anywhere outside this box to dismiss it"
          id="xet-preflex-editor" style="display:none">
        <div>
          List of preferred words/phrases (up to 100):
        </div>
        <div class="xet-choices-box xet-mid-tall-box">
          <textarea rows="100" cols="30" id="xet-preflex-input"
            oninput="exet.throttledUpdatePreflex()"
            class="xlv-answer"></textarea>
        </div>
      </div>
      <div class="xet-preflex-editor"
          title="Click anywhere outside this box to dismiss it"
          id="xet-unpreflex-editor" style="display:none">
        <div>
           List of words/phrases that you do not want as fills:
        </div>
        <div class="xet-choices-box xet-mid-tall-box">
          <textarea rows="100" cols="30" id="xet-unpreflex-input"
            oninput="exet.throttledUpdateUnpreflex()"
            class="xlv-answer"></textarea>
        </div>
      </div>
    </div>
    <div class="xet-controls-col">
      <div class="xet-controls-row xet-clues-box">
        <div class="xet-fill-settings">
          <div>
            <b title="Limit fill suggestions to words/phrases above this ` +
              `percentile threshold of popularity">Minimum popularity score:</b>
            <input id="xet-minpop" name="xet-minpop" class="xlv-answer"
              size="4" maxlength="4" type="text"></input> %ile<br>
            <span id="xet-minpop-incl">${Number(
                this.indexMinPop).toLocaleString()}</span> out of
            ${Number(exetLexicon.startLen).toLocaleString()} words/phrases
            <br>
            <br>
            <b title="If checked, this excludes proper nouns from ` +
                `fill suggestions">Disallow proper nouns:</b>
            <input id="xet-no-proper-nouns" name="xet-no-proper-nouns"
                value="no-proper-nouns" type="checkbox">
            </input>
          </div>
        </div>
        <div id="xet-scratch-pad" class="xet-scratch-pad">
        </div>
      </div>
    </div>
  </div>
</div>
  `;
  // Set up menu click handling
  let menuButtons = exetTab.content.getElementsByClassName('xet-dropbtn')
  for (let i = 0; i < menuButtons.length; i++) {
    let menuPanel = menuButtons[i].nextElementSibling
    menuButtons[i].addEventListener('click', e => {
      if (menuPanel.id && menuPanel.id == "xet-analysis") {
        exet.updateAnalysis(menuPanel)
      } else if (menuPanel.id && menuPanel.id == "xet-save") {
        exet.updateSavePanel(menuPanel)
      }
      exetModals.showModal(menuPanel)
      e.stopPropagation()
    })
    menuButtons[i].addEventListener('mouseenter', e => {
      exetModals.hide()
    })
  }

  this.lChoices = document.getElementById("xet-light-choices")
  this.preflexUsed = document.getElementById("xet-preflex-used")
  this.preflexSize = document.getElementById("xet-preflex-size")
  this.preflexEditor = document.getElementById("xet-preflex-editor")
  this.preflexInput = document.getElementById("xet-preflex-input")
  let preflexText = ''
  for (let p of this.preflex) {
    if (preflexText) preflexText += '\n'
    preflexText += p
  }
  this.preflexInput.value = preflexText
  document.getElementById("xet-edit-preflex").addEventListener('click', e=> {
    exetModals.showModal(exet.preflexEditor)
    e.stopPropagation()
  })
  this.unpreflexSize = document.getElementById("xet-unpreflex-size")
  this.unpreflexEditor = document.getElementById("xet-unpreflex-editor")
  this.unpreflexInput = document.getElementById("xet-unpreflex-input")
  this.renderUnpreflex()
  document.getElementById("xet-edit-unpreflex").addEventListener('click', e=> {
    exetModals.showModal(exet.unpreflexEditor)
    e.stopPropagation()
  })
  this.minpopInclSpan = document.getElementById("xet-minpop-incl")
  this.minpopInput = document.getElementById("xet-minpop")
  this.minpopInput.value = this.minpop
  this.minpopInput.addEventListener('change', e => {
    if (isNaN(this.minpopInput.value) ||
        this.minpopInput.value < 0 || this.minpopInput.value >= 100) {
      this.minpopInput.value = this.minpop
      return
    }
    this.setMinPop(this.minpopInput.value)
    this.minpopInclSpan.innerText = Number(this.indexMinPop).toLocaleString()
    this.resetViability()
    exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
  })
  this.noProperNounsInput = document.getElementById("xet-no-proper-nouns")
  this.noProperNounsInput.checked = this.noProperNouns
  this.noProperNounsInput.addEventListener('change', e => {
    this.noProperNouns = this.noProperNounsInput.checked
    this.resetViability()
    exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
  })

  this.revChooser = document.getElementById("xet-rev-chooser")
  let showPuzChooser = document.getElementById("xet-show-puz-chooser")
  showPuzChooser.addEventListener('click', e => {
    exetRevManager.choosePuzRev(false, null, exet.revChooser, exetFromHistory);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })
  let showRevChooser = document.getElementById("xet-show-rev-chooser")
  showRevChooser.addEventListener('click', e => {
    exetRevManager.choosePuzRev(false, this.puz, exet.revChooser,
                                exetFromHistory);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })
  let manageStorage = document.getElementById("xet-manage-storage")
  manageStorage.addEventListener('click', e => {
    exetRevManager.choosePuzRev(true, null, exet.revChooser, null);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })

  // Saving options
  let showEnums = document.getElementById("xet-show-enums")
  showEnums.addEventListener('change', e => {
    exetState.showEnums = showEnums.checked ? true : false;
    exetRevManager.saveLocal(exetRevManager.SPECIAL_KEY,
                             JSON.stringify(exetState))
  });
  let exolveUrl = document.getElementById("xet-xlv-url-prefix")
  exolveUrl.addEventListener('change', e => {
    exolveUrl.value = exolveUrl.value.trim();
    if (exolveUrl.value.length > 0 &&
        exolveUrl.value[exolveUrl.value.length - 1] != '/') {
      exolveUrl.value = exolveUrl.value + '/';
    }
    exetState.exolveUrl = exolveUrl.value;
    exetRevManager.saveLocal(exetRevManager.SPECIAL_KEY,
                             JSON.stringify(exetState))
  });
  exolveUrl.addEventListener('keyup', e => {
    if (e.key == "Escape") {
      exolveUrl.value = "https://viresh-ratnakar.github.io/";
      exetState.exolveUrl = exolveUrl.value;
      exetRevManager.saveLocal(exetRevManager.SPECIAL_KEY,
                               JSON.stringify(exetState))
    }
  });

  // Editing options
  this.asymOK = document.getElementById("xet-asymmetry-ok")

  // Move the scratch pad over to here.
  const scratchP = document.getElementById("xet-scratch-pad")
  this.puz.scratchPad.rows = "3"
  this.puz.scratchPad.cols = "38"
  const scratchPLabel = document.getElementById(this.puz.prefix + '-shuffle')
  scratchPLabel.style.padding = '8px 0'
  scratchPLabel.style.fontWeight = 'bold'
  scratchP.appendChild(scratchPLabel)
  scratchP.appendChild(this.puz.scratchPad)

  // Pull in the clues.
  this.cluesPanel = document.createElement('div')
  this.cluesPanel.id = 'xet-clues'
  this.cluesPanel.className = 'xet-panel xet-mid-tall-box xet-clues-box'
  this.cluesPanel.title = 'You can edit the current clue as shown above ' +
                          'the grid by clicking on it.'
  scratchP.after(this.cluesPanel)
  this.cluesPanel.appendChild(document.getElementById(
        `${this.puz.prefix}-clues`))
}

Exet.prototype.stripInputLF = function(inp) {
  if (!inp) return
  if (inp.innerText.indexOf('\n') < 0) return
  inp.innerText = inp.innerText.replace(/\n/g, ' ')
}

Exet.prototype.addStat = function(dict, stat, details) {
  if (!dict[stat]) {
    dict[stat] = {
      count: 0,
      details: ''
    }
  }
  dict[stat].count++
  if (details) {
    if (dict[stat].details) dict[stat].details += ', '
    dict[stat].details += details
  }
}

Exet.prototype.depunct = function(s) {
  let out = ''
  for (let c of s) {
    if (c == ' ' || c == '-' || c == "'" || this.allLetters[c.toUpperCase()]) {
      out += c
    }
  }
  return out.replace(/ [ ]*/g, ' ').toLowerCase().trim()
}

Exet.prototype.essenceOfAnno = function(s) {
  // Remove 'def ...'
  s = s.replace(/[dD]ef[^\.]*\./g, ' ')
  let out = ''
  for (let c of s) {
    if (c == '*') {
      out += ' anagram '
    } else if (c == '.' || c == '!' || c == '?' || c == '+' || c == ':') {
      out += ' '
    } else {
      out += c
    }
  }
  out = out.replace(/ [ ]*/g, ' ').trim()
  // Remove words containing {}
  out = out.replace(/[^ ]*{[^}]*}[^ ]*/g, ' ')
  // Remove words containing ()
  out = out.replace(/[^ ]*\([^)]*\)[^ ]*/g, ' ')
  // Remove words containing []
  out = out.replace(/[^ ]*\[[^\]]*\][^ ]*/g, ' ')
  // Remove ".."
  out = out.replace(/"[^"]*"/g, ' ')
  // Remove '..'
  out = out.replace(/'[^']*'/g, ' ')
  // Remove words with 2 or more uppercase letters
  out = out.replace(/[a-zA-Z'-]*[A-Z][a-zA-Z'-]*[A-Z][a-zA-Z'-]*/g, ' ')
  // Remove parens
  out = out.replace(/[\[\]}){(]/g, '')
  // Remove single-letter words
  out = out.replace(/( [A-Za-z])+ /g, ' ')
  out = out.replace(/^([A-Za-z] )+/g, ' ')
  out = out.replace(/( [A-Za-z])+$/g, ' ')

  if (s.match(/-[^ ]\+/) || s.match(/\+[^ ]-/)) {
    out += ' substitution'
  }
  out = out.replace(/ [ ]*/g, ' ').trim().toLowerCase()
  if (!out) {
    out = 'charade or other'
  }
  return out
}

function ExetLightInfo() {
  this.lights = 0
  this.filled = 0
  this.lengths = {}
  this.popularities = {}
  this.letters = {}
  for (let c of exetLexicon.letters) {
    this.letters[c] = {count: 0, details: ''}
  }
  this.ischild = 0
  this.set = 0
  this.annos = 0
  this.words = {}
  this.annotations = {}
}

Exet.prototype.getLightInfos = function() {
  let infos = {
    All: new ExetLightInfo(),
    Across: new ExetLightInfo(),
    Down: new ExetLightInfo(),
    Other: new ExetLightInfo(),
  }
  let allInfo = infos['All']
  let aInfo = infos['Across']
  let dInfo = infos['Down']
  let oInfo = infos['Other']
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    let dirInfo = theClue.dir == 'A' ? aInfo : (theClue.dir == 'D' ?
                                                dInfo : oInfo)
    allInfo.lights++
    dirInfo.lights++
    if (theClue.parentClueIndex) {
      allInfo.ischild++
      dirInfo.ischild++
      continue
    }
    let label = theClue.label + theClue.dir.toLowerCase()
    if (theClue.solution && theClue.solution.indexOf('?') < 0) {
      allInfo.filled += 1
      dirInfo.filled += 1
      let lexl = exetLexicon.lexicon.length
      let index = lexl
      let fillClue = this.fillState.clues[ci]
      if (fillClue && fillClue.lChoices.length == 1) {
        index = fillClue.lChoices[0]
      }
      let pop = 5 * Math.round(20 * (lexl - index) / lexl)
      label += ': ' + exetLexicon.lexicon[index]
      this.addStat(allInfo.popularities, pop, label)
      this.addStat(dirInfo.popularities, pop, label)
    }
    this.addStat(allInfo.lengths, theClue.enumLen, label)
    this.addStat(dirInfo.lengths, theClue.enumLen, label)
    let depunctClue = this.depunct(theClue.clue)
    if (depunctClue && !this.isDraftClue(theClue.clue)) {
      allInfo.set += 1
      dirInfo.set += 1
      let words = depunctClue.split(' ')
      for (let word of words) {
        this.addStat(allInfo.words, word, label)
        this.addStat(dirInfo.words, word, label)
      }
    }
    if (theClue.anno) {
      allInfo.annos += 1
      dirInfo.annos += 1
      let anno = this.essenceOfAnno(theClue.anno)
      if (anno) {
        this.addStat(allInfo.annotations, anno, label)
        this.addStat(dirInfo.annotations, anno, label)
      }
    }
  }
  // In *.words, retain only those that have count > 1
  for (let key of Object.keys(infos)) {
    let info = infos[key]
    for (let word of Object.keys(info.words)) {
      if (info.words[word].count <= 1) delete info.words[word]
    }
  }
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let h = this.puz.gridHeight
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      let gridCell = grid[i][j]
      if (!gridCell.isLight || gridCell.solution == '?') continue
      let rowcol = 'row-' + (h - i) + ',' + 'col-' + (j + 1)
      this.addStat(allInfo.letters, gridCell.solution, rowcol)
      if (gridCell.acrossClueLabel) {
        this.addStat(aInfo.letters, gridCell.solution, rowcol)
      }
      if (gridCell.downClueLabel) {
        this.addStat(dInfo.letters, gridCell.solution, rowcol)
      }
    }
  }
  if (oInfo.lights == 0) {
    delete infos['Other']
  }
  return infos
}

Exet.prototype.updateAnalysis = function(elt) {
  let html = '<p><b>Grid</b></p><p><ul>'
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let h = this.puz.gridHeight
  html = html + `<li>${w*h} cells, dimensions: ${w} &times; ${h}</li>`
  if (!this.gridConnected(grid, w, h)) {
    html += '<li><i>Does not have all light cells connected</i></li>'
  } else {
    html += '<li>All light cells are connected</li>'
  }
  if (!this.gridSymmetric(grid, w, h)) {
    html += '<li><i>Not symmetric</i></li>'
  } else {
    html += '<li>Symmetric</li>'
  }
  let numBlocks = this.gridNumBlocks(grid, w, h)
  if (numBlocks > 0) {
    html += `<li>${numBlocks} (${(numBlocks * 100 /
          (w * h)).toFixed(2)}%) blocked cells</li>`
  } else {
    html += '<li>No blocked cells</li>'
  }
  let numBars = this.gridNumBars(grid, w, h)
  if (numBars > 0) {
    html += `<li>${numBars} bars</li>`
  } else {
    html += '<li>No bars</li>'
  }
  if (this.gridUnchequeredOK(grid, w, h, false)) {
    html += '<li>Every light cell is checked</li>'
  } else  if (this.gridChequeredOK(grid, w, h, false)) {
    html += '<li>No consecutive unches</li>'
  } else {
    html += '<li><i>Has consecutive unches</i></li>'
  }
  html += '</ul></p>'

  let lightInfos = this.getLightInfos()
  html += `<p><select name="xet-analysis-select"
          id="xet-analysis-select" style="font-weight:bold" value="All"
    onchange="exet.selectAnalysis()">`
  for (let key in lightInfos) {
    html = html + `
      <option value="${key}">${key}</option>`
  }
  html += '</select> <b>Grid-fills and Clues</b></p>'
  html += '<p><i>Hover on the blue bars to see details</i></p>'
  for (let key in lightInfos) {
    html += `<div id="xet-analysis-${key}" class="xet-analysis-choices"
            style="display:none"><ul>`
    let info = lightInfos[key]
    html += `<li><b>Number of lights</b>: ${info.lights}</li>`
    let unparented = info.lights - info.ischild
    html += `<li><b>Number of words/phrases</b>: ${unparented}</li>`
    html += `<li><b>Word/phrase lengths</b>: ${this.plotStats(
        info.lengths)}</li>`
    html += `<li><b>Filled words/phrases</b>: ${info.filled} (${(
          info.lights > 0 ? 100*info.filled/info.lights : 0).toFixed(2)}%)</li>`
    html += `<li><b>Clues set (i.e., not ${this.DRAFT})</b>: ${info.set} (${(
          unparented > 0 ? 100*info.set/unparented : 0).toFixed(2)}%)</li>`
    html += `<li><b>Words repeated in clues</b>: ${this.plotStats(
        info.words)}</li>`
    html += `<li><b>Annotations provided</b>: ${info.annos} (${(
          unparented > 0 ? 100*info.annos/unparented : 0).toFixed(2)}%)
    ${this.plotStats(info.annotations)}</li>`
    html += `<li><b>Letters used</b>: ${this.plotStats(info.letters)}</li>`
    html += `<li title="Popularity, when available in the lexicon, is ` +
      `the percentile by occurrence count over a large corpus such ` +
      `as Wikipedia"><b>Word/phrase popularity percentiles</b>: ${
        this.plotStats(info.popularities, 5)}</li>`
    html += '</ul></div>'
  }
  elt.innerHTML = html
  this.selectAnalysis()
}

Exet.prototype.plotStats = function(stats, numericstep=1) {
  let keys = Object.keys(stats)
  let numeric = true
  let totalCount = 0
  for (let key of keys) {
    if (isNaN(key)) {
      numeric = false
    }
    totalCount += stats[key].count
  }
  if (numeric) {
    keys.sort((a, b) => a - b);
  } else {
    keys.sort((a, b) => stats[b].count - stats[a].count);
  }
  let min = Number.MAX_VALUE
  let max = Number.MIN_VALUE
  let count = 0
  let distinct = 0
  let sum = 0
  let median = 0
  let medianFound = false
  let html = '<p>'
  let maxv = 1
  for (let key of keys) {
    let v = stats[key].count
    count += v
    if (v > 0) distinct++
    if (v > maxv) maxv = v
    if (numeric) {
      key = Number(key)
      if (key > max) max = key
      if (key < min) min = key
      sum += (key * v)
      if (!medianFound && count >= (totalCount / 2)) {
        median = key
        medianFound = true
      }
    }
  }
  if (numeric) {
    let next = min + numericstep
    while (next < max) {
      if (!stats[next]) stats[next] = {count: 0, details: ''}
      next += numericstep
    }
    keys = Object.keys(stats)
    keys.sort((a, b) => a - b);
  }
  html += '<table>'
  const BARMAX = 150
  for (let key of keys) {
    html += '<tr>'
    html += `<td style="text-align:right">${stats[key].count}</td>`
    html += numeric ? '<td>occurrences of</td>' : '<td>&times;</td>'
    html += `<td>${key}</td>`
    html += `<td><div class="xet-plotbar"
            style="width:${BARMAX * stats[key].count / maxv}px"`
    if (stats[key].details) {
      html += ` title="${stats[key].details}"`
    }
    html += '></div></td>'
    html += '</tr>'
  }
  html += '</table>'
  html += '</p>'
  html += `<p>Distinct values: ${distinct}</p>`
  if (numeric && count > 0) {
    html += `<p>
      Range: ${min} - ${max},
      Average: ${(sum / count).toFixed(1)},
      Median: ${median}
    </p>`
  }
  return html
}

Exet.prototype.selectAnalysis = function() {
  let picker = document.getElementById('xet-analysis-select')
  if (!picker) return
  let id = 'xet-analysis-' + picker.value
  let choices = document.getElementsByClassName('xet-analysis-choices')
  for (let i = 0; i < choices.length; i++) {
    choices[i].style.display = (choices[i].id == id ? '' : 'none')
  }
}

Exet.prototype.updateMetadata = function() {
  if (!this.puz) {
    return
  }
  if (this.throttledMetadataTimer) {
    clearTimeout(this.throttledMetadataTimer);
  }
  this.throttledMetadataTimer = setTimeout(() => {
    this.saveCursor()
    if (this.xetTitle) {
      this.stripInputLF(this.xetTitle)
      this.puz.title = this.xetTitle.innerText
    }
    if (this.xetSetter) {
      this.stripInputLF(this.xetSetter)
      this.puz.setter = this.xetSetter.innerText
    }
    if (this.xetCopyright) {
      this.stripInputLF(this.xetCopyright)
      this.puz.copyright = this.xetCopyright.innerText
    }
    this.restoreCursor()
    this.throttledMetadataTimer = null;
    exetRevManager.throttledSaveRev(exetRevManager.REV_METADATA_CHANGE)
  }, 2000);
}

Exet.prototype.indsTabNav = function() {
  if (this.indsIframe.src == this.indsSelect.value) {
    return
  }
  this.indsIframe.src = this.indsSelect.value;
  this.indsUrl.innerText = this.indsSelect.value;
  this.indsUrl.href = this.indsSelect.value;
}

Exet.prototype.makeIndsTab = function(panelH) {
  let inds = [
    {name: "Please select", url: ""},
    {name: "separator"},
    {name: "Crossword Unclued's anagram indicators",
     url: "https://www.crosswordunclued.com/2008/09/anagram-indicators.html"},
    {name: "Crossword Unclued's hidden words indicators",
     url: "https://www.crosswordunclued.com/2009/03/" +
          "hidden-word-indicators.html"},
    {name: "Crossword Unclued's reversal indicators",
     url: "https://www.crosswordunclued.com/2009/07/reversal-indicators.html"},
    {name: "Crossword Unclued's homophone indicators",
     url: "https://www.crosswordunclued.com/2009/02/homophone-indicators.html"},
    {name: "separator"},
    {name: "Highlight Press's deletion and letter-picking indicators",
     url: "https://www.highlightpress.com.au/subtractions.html"},
    {name: "Crossword Unclued's deletion indicators",
     url: "https://www.crosswordunclued.com/2009/04/deletion-indicators.html"},
    {name: "Crossword Unclued's letter-picking indicators",
     url: "https://www.crosswordunclued.com/2009/04/" +
          "letter-sequence-indicators.html"},
    {name: "separator"},
    {name: "Highlight Press's containment indicators",
     url: "https://www.highlightpress.com.au/containers.html"},
    {name: "Crossword Unclued's containment indicators",
     url: "https://www.crosswordunclued.com/2009/02/" +
          "container-and-content-indicators.html"},
    {name: "separator"},
    {name: "Crossword Unclued's list of abbreviations",
     url: "https://www.crosswordunclued.com/2008/10/" +
          "cryptic-abbreviations.html"},
    {name: "Wikipedia's list of abbreviations",
     url: "https://en.wikipedia.org/wiki/Crossword_abbreviations"},
    {name: "Mythic beasts list of abbreviations",
     url: "http://sphinx.mythic-beasts.com/~mark/random/indicators/"},
  ]
  let indsTab = this.tabs["inds"]
  let html = `
  <div>
  <select name="xet-inds-select" id="xet-inds-select"
    onchange="exet.indsTabNav()">`
  for (let ind of inds) {
    if (ind.name == "separator") {
      html = html + '<option disabled>' +
        '&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;' +
        '&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;' +
        '&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;' +
        '</option>'; 
      continue;
    }
    html = html + `
    <option value="${ind.url}">${ind.name}</option>`
  }
  html = html + '</select></div><br>'
  html = html + `
  <a href="" target="_blank" id="xet-inds-choice-url"
      class="xet-blue xet-small"></a><br>
  <iframe id="xet-inds-iframe" class="xet-iframe" src=""
    style="height:${panelH}px" height="${panelH}"></iframe>
  `;
  indsTab.content.innerHTML = html;
  this.indsIframe = document.getElementById('xet-inds-iframe')
  this.indsSelect = document.getElementById('xet-inds-select')
  this.indsSelect.value = this.savedIndsSelect
  this.indsUrl = document.getElementById('xet-inds-choice-url')
}

Exet.prototype.dictsTabNav = function() {
  let words = this.tabs["dicts"].words
  if (this.dictsIframe.src == this.dictsSelect.value + words) {
    return
  }
  this.dictsIframe.src = this.dictsSelect.value + words;
  this.dictsUrl.innerText = this.dictsSelect.value + words;
  this.dictsUrl.href = this.dictsSelect.value + words;
}

Exet.prototype.makeDictsTab = function(panelH) {
  let dicts = [
    {url: "https://chambers.co.uk/search/?title=21st&query=",
     name: "Chambers"},
    {url: "https://chambers.co.uk/search/?title=thes&query=",
     name: "Chambers Thesaurus"},
    {url: "https://thefreedictionary.com/", name: "The Free Dictionary"},
    {url: "https://onelook.com/?w=", name: "Onelook"},
    {url: "https://api.dictionaryapi.dev/api/v1/entries/en/",
     name: "Google Dictionary"},
    {url: "https://www.etymonline.com/search?q=", name: "Etymonline"},
  ]
  let dictsTab = this.tabs["dicts"]
  let html = `
  <div>
  <select name="xet-dicts-select" id="xet-dicts-select" value="${dicts[0].url}"
    onchange="exet.dictsTabNav()">`
  for (let dict of dicts) {
    html = html + `
    <option value="${dict.url}">${dict.name}</option>`
  }
  html = html + '</select></div><br>'
  html = html + `
  <a href="" target="_blank" id="xet-dicts-choice-url"
      class="xet-blue xet-small"></a><br>
  <iframe id="xet-dicts-iframe" class="xet-iframe" src=""
    style="height:${panelH}px" height="${panelH}"></iframe>
  `;
  dictsTab.content.innerHTML = html;
  this.dictsIframe = document.getElementById('xet-dicts-iframe')
  this.dictsSelect = document.getElementById('xet-dicts-select')
  this.dictsUrl = document.getElementById('xet-dicts-choice-url')
}

Exet.prototype.getAllSplits = function(fodder, k) {
  let n = fodder.length
  if (n < 1 || k < 1 || k > n ) return []
  if (k == 1) {
    return [[fodder]]
  }
  if (k == n) {
    let pieces = []
    for (let i = 0; i < n; i++) {
      pieces.push(fodder.charAt(i))
    }
    return [pieces]
  }
  let splits = []
  // For long fodders, skip some splits.
  for (let last_span = (fodder.length > 10 ? fodder.length - 9 : 1);
       last_span <= n - k + 1; last_span++) {
    let last_piece = fodder.substr(n - last_span, last_span);
    let prefix = fodder.substr(0, n - last_span);
    let subsplits = this.getAllSplits(prefix, k - 1)
    for (let subsplit of subsplits) {
      subsplit.push(last_piece);
      splits.push(subsplit);
    }
  }
  return splits
}

Exet.prototype.pushCharadeCandidate = function(elements) {
  if (!elements || elements.length == 0) {
    return
  }
  let charade = ''
  let score = 0;
  let i = 0
  let numScores = elements.length
  while (i < elements.length) {
    let x = elements[i]
    if (!x.possible) {
      return
    }
    if (charade) charade = charade + '<span class="xet-blue"> + </span>'
    charade = charade + x.possible
    score += x.score
    i++
    if (x.container) {
      contents = ''
      while (i < x.container) {
        let y = elements[i]
        if (!y.possible) {
          return
        }
        if (contents) contents = contents + ' '
        contents = contents + y.possible
        score += y.score
        i++
      }
      charade = charade + ' <span class="xet-blue">around (</span>' +
        contents + '<span class="xet-blue">)</span>'
      i++
      numScores = elements.length - 1
    }
  }
  score = score / numScores
  if (charade) {
    this.charadeCandidates.push({
      charade: charade,
      score: score
    })
  }
}

Exet.prototype.updateCharades = function(fodder) {
  if (this.throttledCharadeTimer) {
    clearTimeout(this.throttledCharadeTimer);
  }
  this.throttledCharadeTimer = null
  this.charadeCandidates = []
  this.charadeParts = 1;
  this.charadeSplits = null;
  this.charadeSplitIndex = 0;
  this.charadeMax = Math.min(fodder.length, 4)
  this.charadeFodder = fodder
  this.updateCharadesPartial()
}

Exet.prototype.updateCharadesPartial = function(work=100, sleep=50) {
  let startTS = Date.now()
  while (this.charadeParts <= this.charadeMax) {
    if (!this.charadeSplits) {
      this.charadeSplits = this.getAllSplits(
          this.charadeFodder, this.charadeParts)
      this.charadeSplitIndex = 0
    }
    while (this.charadeSplitIndex < this.charadeSplits.length) {
      let split = this.charadeSplits[this.charadeSplitIndex]
      let viable = []
      for (let part of split) {
        let possible = ''
        let score = 0
        let choices = this.getAnagrams(part)
        if (choices.length > 0) {
          score = part.length
          let rpart = ''
          if (part.length > 1) {
            rpart = part.split('').reverse().join('')
          }
          for (let choice of choices) {
            if (possible) possible = possible + ', '
            let key = this.makeCharadeParam(choice)
            if (key == part) {
              possible = possible + choice
            } else if (key == rpart) {
              possible = possible + choice + '<span class="xet-blue"><<</span>'
            } else {
              possible = possible + choice + '<span class="xet-blue">*</span>'
            }
          }
          if (choices.length > 1) {
            possible = '<span class="xet-blue">[</span>' + possible +
                       '<span class="xet-blue">]</span>'
          }
        }
        viable.push({possible: possible, score: score})
      }
      if (viable.length < this.charadeParts) {
        continue
      }
      this.pushCharadeCandidate(viable)
      for (let c1 = 0; c1 < this.charadeParts - 2; c1++) {
        for (let c2 = c1 + 2; c2 < this.charadeParts; c2++) {
          // Everything else must be viable
          let ok = true
          for (let i = 0; i < this.charadeParts; i++) {
            if (i != c1 && i != c2 && !viable[i].possible) {
              ok = false
              break
            }
          }
          if (!ok) {
            continue
          }
          let container = split[c1] + split[c2]
          let choices = this.getAnagrams(container)
          if (choices.length > 0) {
            let rcontainer = container.split('').reverse().join('')
            let possible = ''
            for (let choice of choices) {
              if (possible) possible = possible + ', '
              let key = this.makeCharadeParam(choice)
              if (key == container) {
                possible = possible + choice
              } else if (key == rcontainer) {
                possible = possible + choice +
                           '<span class="xet-blue"><<</span>'
              } else {
                possible = possible + choice + '<span class="xet-blue">*</span>'
              }
            }
            if (choices.length > 1) {
              possible = '<span class="xet-blue">[</span>' + possible +
                         '<span class="xet-blue">]</span>'
            }
            let vcopy = viable.slice(0, viable.length)
            vcopy[c1] = {}
            vcopy[c1].possible = possible
            vcopy[c1].score = container.length
            vcopy[c1].container = c2
            this.pushCharadeCandidate(vcopy)
          }
        }
      }
      this.charadeSplitIndex++
      if (Date.now() - startTS >= work) {
        break
      }
    }
    if (this.charadeSplitIndex == this.charadeSplits.length) {
      this.charadeSplits = null
      this.charadeParts++;
    }
    if (Date.now() - startTS >= work) {
      break
    }
  }
  let candidates = this.charadeCandidates.sort((a, b) => b.score - a.score);
  let html = '<table id="xet-charade-choices">'
  for (let candidate of candidates) {
    html = html + `
      <tr><td><span style="color:gray">[${
        candidate.score.toFixed(1)}]</span> ${candidate.charade}</td></tr>`
  }
  html = html + '</table>'
  this.charades.innerHTML = html;
  if (this.charadeParts <= this.charadeMax) {
    this.throttledCharadeTimer = setTimeout(() => {
      this.updateCharadesPartial(work, sleep)
    }, sleep);
  }
}

Exet.prototype.updateCA = function() {
  let fodder = this.caFodder.value.toLowerCase().replace(
      /[^a-z]/g, '').split('').sort()
  let anagram = this.caAnagram.value.toLowerCase().replace(
      /[^a-z]/g, '').split('').sort()
  let f = 0;
  let a = 0;
  let extra = []
  let unused = []
  while (f < fodder.length && a < anagram.length) {
    if (fodder[f] == anagram[a]) {
      f++;
      a++;
    } else if (fodder[f] < anagram[a]) {
      unused.push(fodder[f++])
    } else {
      extra.push(anagram[a++])
    }
  }
  while (f < fodder.length) {
    unused.push(fodder[f++])
  }
  while (a < anagram.length) {
    extra.push(anagram[a++])
  }
  extraS = extra.join('')
  this.caExtra.innerText = extraS
  let html = ''
  let extraAnags = this.getAnagrams(extraS)
  for (let choice of extraAnags) {
    html = html + `
      <tr><td>${choice}</td></tr>`
  }
  this.caExtraAnags.innerHTML = html
  unusedS = unused.join('')
  this.caUnused.innerText = unusedS
  html = ''
  let unusedAnags = this.getAnagrams(unusedS)
  for (let choice of unusedAnags) {
    html = html + `
      <tr><td>${choice}</td></tr>`
  }
  this.caUnusedAnags.innerHTML = html
}

Exet.prototype.populateCompanag = function() {
  let ca = document.getElementById('xet-companag')
  ca.className = 'xet-companag'
  ca.innerHTML = `
    <table class="xet-table-midline">
      <tr>
        <td class="xet-td">Fodder:</td>
        <td class="xet-td">Anagram:</td>
      </tr>
      <tr>
        <td class="xet-td"><input type="text"
           class="xlv-answer xet-companag-text" id='xet-ca-fodder'></input></td>
        <td class="xet-td"><input type="text"
          title="Enter a phrase that's only roughly an anagram of ` +
            `some of the letters in the fodder"
          class="xlv-answer xet-companag-text" id='xet-ca-anagram'></input></td>
      </tr>
      <tr>
        <td class="xet-td">Extra in anagram:</td>
        <td class="xet-td"><div>Unused from fodder:</td>
      </tr>
      <tr>
        <td class="xet-td"><div class="xet-companag-text"
            id='xet-ca-extra'></div></td>
        <td class="xet-td"><div class="xet-companag-text"
            id='xet-ca-unused'></div></td>
      </tr>
      <tr>
        <td class="xet-td">
          Extra* anagrams:
          <table id="xet-ca-extra-anags">
          </table>
        </td>
        <td class="xet-td">
          Unused* anagrams:
          <table id="xet-ca-unused-anags">
          </table>
        </td>
      </tr>
    </table>`
  this.caFodder = document.getElementById('xet-ca-fodder')
  this.caAnagram = document.getElementById('xet-ca-anagram')
  this.caExtra = document.getElementById('xet-ca-extra')
  this.caUnused = document.getElementById('xet-ca-unused')
  this.caFodder.addEventListener('input', this.updateCA.bind(this))
  this.caAnagram.addEventListener('input', this.updateCA.bind(this))
  this.caExtraAnags = document.getElementById('xet-ca-extra-anags')
  this.caUnusedAnags = document.getElementById('xet-ca-unused-anags')
}

Exet.prototype.populateFrame = function() {
  let frameHTML = ''
  frameHTML = frameHTML + '<div class="xet-tab">'
  for (let id in this.tabs) {
    let tab = this.tabs[id]
    frameHTML = frameHTML +
        `<button id="xet-${id}">${tab.display}</button>`
  }
  frameHTML = frameHTML + '</div>'

  const panelH = 500
  const panelInnerH = 450
  for (let id in this.tabs) {
    let tab = this.tabs[id]
    frameHTML = frameHTML + `<div class="xet-tabcontent" id="xet-${id}-frame">`
    if (tab.sections.length > 0) {
      // We show the first (presumably main) section in the left column,
      // and stack up all the other sections in the right column.
      let numRows = 1
      let panelW = 900
      let secondH = panelInnerH
      if (tab.sections.length > 1) {
        numRows = tab.sections.length - 1
        panelW = 440
      }
      if (numRows > 1) {
        secondH = 200
      }
      frameHTML = frameHTML + '<div class="xet-section"><table>'
      for (let i = 0; i < tab.sections.length; i++) {
        let section = tab.sections[i]
        if (i != 1) {
          frameHTML = frameHTML + '<tr>'
        }
        let h = secondH
        if (i == 0) {
          frameHTML = frameHTML + `<td class="xet-td" rowspan="${numRows}">`
          h = panelInnerH
        } else {
          frameHTML = frameHTML + '<td class="xet-td">'
        }
        if (section.url) {
          frameHTML = frameHTML + `
            <div class="xet-bold">${section.title || ''}</div>
            <a href="" target="_blank" id="xet-${id}-url-${i}"
                class="xet-blue xet-small"></a><br>
            <iframe class="xet-iframe" style="height:${h}px;width:${panelW}px;"
               height="${h}" width="${panelW}px" id="xet-${id}-content-${i}">
            </iframe>`
        } else {
          frameHTML = frameHTML + `
            <div class="xet-bold">${section.title || ''}</div>
            <div id=${section.id}
              class="xet-panel"
              style="height:${h}px;width:${panelW}px;">
            </div>`
        }
        if (i > 0 && i < tab.sections.length - 1) {
          frameHTML = frameHTML + '<hr/><br>'
        }
        frameHTML = frameHTML + '</td>'
        if (i > 0 || tab.sections.length == 1) {
          frameHTML = frameHTML + '</tr>'
        }
      }
      frameHTML = frameHTML + `
        </table>
        </div>`
    } else {
      frameHTML = frameHTML + `
        <div class="xet-section" id="xet-${id}-content"></div>`
    }
    frameHTML = frameHTML + '</div>'
  }
  this.frame.innerHTML = frameHTML

  for (let id in this.tabs) {
    let tab = this.tabs[id]
    tab.button = document.getElementById(`xet-${id}`)
    tab.button.title = tab.hover
    tab.button.addEventListener(
      'click', this.handleTabClick.bind(this, id));
    tab.frame = document.getElementById(`xet-${id}-frame`)
    if (tab.sections.length > 0) {
      for (let i = 0; i < tab.sections.length; i++) {
        let section = tab.sections[i]
        if (!section.url) {
          continue
        }
        section.content = document.getElementById(`xet-${id}-content-${i}`)
        section.urldisp = document.getElementById(`xet-${id}-url-${i}`)
      }
    } else {
      tab.content = document.getElementById(`xet-${id}-content`)
    }
  }
  let ch = document.getElementById('xet-charades')
  ch.innerHTML = `
    <div id="xet-charades-box" style="margin:16px 0;border:0">
    </div>
  `
  this.charades = document.getElementById('xet-charades-box')
  this.populateCompanag()

  this.makeExetTab()
  this.makeIndsTab(panelInnerH)
  this.makeDictsTab(panelInnerH)
}

Exet.prototype.fileTitle = function() {
  return this.puz.title.replace(/[^a-z0-9]+/gi, '-').toLowerCase();
}

Exet.prototype.updateSavePanel = function() {
  const filetitle = this.fileTitle()
  const tlist = document.getElementsByClassName('xet-filetitle')
  for (let i = 0; i < tlist.length; i++) {
    tlist[i].innerText = filetitle
  }
  const w = document.getElementById('xet-save-warnings')
  let warnings = ''
  const info = this.getLightInfos()['All']
  const numUnfilled = info.lights - info.ischild - info.filled
  if (numUnfilled == 1) {
    warnings += 'The crossword still has 1 unfilled entry!<br>'
  } else if (numUnfilled > 1) {
    warnings += 'The crossword still has ' + numUnfilled +
                ' unfilled entries!<br>'
  }
  const numDraft = info.lights - info.ischild - info.set
  if (numDraft == 1) {
    warnings += `The crossword still has 1 clue marked ${this.DRAFT}!<br>`
  } else if (numDraft > 1) {
    warnings += `The crossword still has ${numDraft} clues ` +
                `marked ${this.DRAFT}!<br>`
  }
  w.innerHTML = warnings
  w.style.display = warnings ? '' : 'none'
}

Exet.prototype.download = function(solved=true) {
  let html = this.getHTML(solved, exetState.showEnums)
  const a = document.createElement("a");
  a.style.display = "none";
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([html], {type: "text/html"})
  );
  let fileprefix = "exet-exolve"
  let filetitle = this.fileTitle()
  if (filetitle) fileprefix += "-" + filetitle
  a.setAttribute("download", fileprefix +
    (solved ? "-solved.html" : "-unsolved.html"));
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

Exet.prototype.print = function(solved=true) {
  const revealer = solved ?
    `exolvePuzzles['${this.puz.id}'].revealAll(false);` :
    `exolvePuzzles['${this.puz.id}'].clearAll(false);`;
  const html = '' +
        '<!DOCTYPE html>\n' +
        '<html lang="en">\n' +
        '<head>\n' +
        '<meta charset="utf-8"/>\n' +
        '<meta name="viewport" content="width=device-width, initial-scale=1"/>\n' +
        '<link rel="stylesheet" type="text/css" href="exolve-m.css"/>\n' +
        '<script src="exolve-m.js"><\/script>\n' +
        '<\/head>\n' +
        '<body ' +
        'onload="' +
        revealer +
        'window.print();window.close();">\n' +
        '<script>\n' +
        'createExolve(`' +  '\n' +
        this.getExolve('', false, solved, exetState.showEnums) +
        '`);\n' +
        '<\/script>\n' +
        '<\/body>\n' +
        '<\/html>\n'
  const pwin = window.open('', '', 'left=0,top=0');
  pwin.document.write(html);
  pwin.document.close();
  pwin.focus();
  exetModals.hide()
}

Exet.prototype.toClipboard = function(solved=true, inpid) {
  const inp = document.getElementById(inpid);

  let prefix = '' +
      '<link rel="stylesheet" type="text/css" href="' + exetState.exolveUrl +
          'exolve-m.css"/>\n' +
      '<script src="' + exetState.exolveUrl + 'exolve-m.js">\n' +
      '<\/script>\n' +
      '<div id="exolve">\n' +
      '<\/div>\n' +
      '<script>\n' +
      '  createExolve(`\n';
  let suffix = '' +
      '  `);\n' +
      '<\/script>\n'
  inp.value = prefix + this.getExolve('', false, solved, exetState.showEnums) +
              suffix;

  inp.select();
  inp.setSelectionRange(0, 99999);
  document.execCommand("copy");
  setTimeout(() => {
    inp.value = ''
    exetModals.hide()
    alert('Exolve widget code has been copied to clipboard')
  }, 1000);
}

Exet.prototype.dotPuzCksum = function(uint8array, offset, len, cksum) {
  for (let i = 0; i < len; i++) {
    if (cksum & 0x0001) {
      cksum = (cksum >> 1) | 0x8000;
    } else {
      cksum = cksum >> 1;
    }
    cksum += uint8array[offset + i]
    cksum = cksum & 0xffff
  }
  return cksum;
}

Exet.prototype.dotPuzShort = function(buffer, offset, shortval) {
  buffer[offset] = shortval & 0xFF
  buffer[offset + 1] = shortval >> 8
}

Exet.prototype.enc8859 = function(s, buffer, offset) {
  if (!this.chars8859) {
    this.chars8859 = {};
    let decoder = new TextDecoder('iso-8859-1');
    const buff = new Uint8Array(1);
    for (let i = 128; i < 256; i++) {
      buff[0] = i;
      const char = decoder.decode(buff);
      this.chars8859[char] = i;
    }
  }
  for (let i = 0; i < s.length; i++) {
    let code = s.charCodeAt(i);
    if (code >= 128) {
      const char = s.charAt(i);
      if (this.chars8859.hasOwnProperty(char)) {
        code = this.chars8859[char];
      } else {
        throw 'Character not supported in ISO-8859-1: ' + char
      }
    }
    buffer[offset++] = code;
  }
  return offset;
}

Exet.prototype.getDotPuz = function() {
  try {
    // Generously estimate length of the buffer needed.
    let exolve = this.getExolve();
    let estDotPuzLen = 2 * (1000 + exolve.length)
    let buffer = new Uint8Array(estDotPuzLen);
    let offset = 0;

    offset = 0x02
    offset = this.enc8859('ACROSS&DOWN', buffer, offset);
    buffer[offset++] = 0;

    offset = 0x18
    offset = this.enc8859('1.3', buffer, offset);
    buffer[offset++] = 0;

    offset = 0x2c
    buffer[offset++] = this.puz.gridWidth
    buffer[offset++] = this.puz.gridHeight

    this.dotPuzShort(buffer, 0x2E, this.puz.allClueIndices.length)
    buffer[0x30] = 1  // Unknown bitmask

    let numCells = this.puz.gridWidth * this.puz.gridHeight;

    let solution = ''
    let playerState = ''
    let orderedClueIndices = []
    let circleLocs = []
    for (let i = 0; i < this.puz.gridHeight; i++) {
      for (let j = 0; j < this.puz.gridWidth; j++) {
        let gridCell = this.puz.grid[i][j]
        if (gridCell.hasBarAfter || gridCell.hasBarUnder) {
          throw 'This puzzle has barred cells';
        }
        if (!gridCell.isLight) {
          solution = solution + '.'
          playerState = playerState + '.'
        } else {
          solution = solution + (gridCell.currLetter != '0' ?
            gridCell.currLetter : '?')
          playerState = playerState + '-'
          if (gridCell.startsAcrossClue) {
            orderedClueIndices.push('A' + gridCell.startsClueLabel)
          }
          if (gridCell.startsDownClue) {
            orderedClueIndices.push('D' + gridCell.startsClueLabel)
          }
          if (gridCell.hasCircle) {
            circleLocs.push((i * this.puz.gridWidth) + j)
          }
        }
      }
    }
    if (this.puz.allClueIndices.length != orderedClueIndices.length) {
      throw 'Non-standard clue types';
    }

    offset = 0x34
    offset = this.enc8859(solution, buffer, offset);
    offset = this.enc8859(playerState, buffer, offset);

    let titleOffset = offset
    offset = this.enc8859(this.puz.title, buffer, offset);
    let titleLen = offset - titleOffset;
    buffer[offset++] = 0;

    let setterOffset = offset
    offset = this.enc8859(this.puz.setter, buffer, offset);
    let setterLen = offset - setterOffset;
    buffer[offset++] = 0

    let copyrightOffset = offset
    offset = this.enc8859(this.puz.copyright, buffer, offset);
    let copyrightLen = offset - copyrightOffset;
    buffer[offset++] = 0

    let clueOffsets = []
    let clueLens = []
    for (let ci of orderedClueIndices) {
      let theClue = this.puz.clues[ci]
      if (theClue.parentClueIndex) {
        throw 'This puzzle has linked clues';
      }
      const startOffset = offset;
      clueOffsets.push(startOffset);
      offset = this.enc8859(this.showClue(
            theClue.clueSpan.innerText.replace(/\s+/g,' '),
        false, exetState.showEnums), buffer, offset);
      clueLens.push(offset - startOffset);
      buffer[offset++] = 0
    }
    // Empty Notes section:
    buffer[offset++] = 0

    let gextOffset = -1
    if (circleLocs.length > 0) {
      gextOffset = offset
      offset = this.enc8859('GEXT', buffer, offset);
      this.dotPuzShort(buffer, offset, numCells);
      offset += 4
      for (let loc of circleLocs) {
        buffer[offset + loc] = 0x80
      }
      offset += numCells
      buffer[offset++] = 0
      let c_gext = this.dotPuzCksum(buffer, gextOffset + 8, numCells, 0);
      this.dotPuzShort(buffer, gextOffset + 6, c_gext);
    }

    // Need to fill checksums
    let c_cib = this.dotPuzCksum(buffer, 0x2C, 8, 0);
    this.dotPuzShort(buffer, 0x0E, c_cib);

    let cksum = c_cib;
    cksum = this.dotPuzCksum(buffer, 0x34, numCells, cksum);
    cksum = this.dotPuzCksum(buffer, 0x34 + numCells, numCells, cksum);

    if (titleLen > 0) {
      cksum = this.dotPuzCksum(buffer, titleOffset, titleLen + 1, cksum);
    }
    if (setterLen > 0) {
      cksum = this.dotPuzCksum(buffer, setterOffset, setterLen + 1, cksum);
    }
    if (copyrightLen > 0) {
      cksum = this.dotPuzCksum(
          buffer, copyrightOffset, copyrightLen + 1, cksum);
    }

    for (let i = 0; i < orderedClueIndices.length; i++) {
      cksum = this.dotPuzCksum(buffer, clueOffsets[i], clueLens[i], cksum);
    }
    this.dotPuzShort(buffer, 0x00, cksum);

    let c_sol = this.dotPuzCksum(buffer, 0x34, numCells, 0);
    let c_grid = this.dotPuzCksum(buffer, 0x34 + numCells, numCells, 0);
    let c_part = 0;
    if (titleLen > 0) {
      c_part = this.dotPuzCksum(buffer, titleOffset, titleLen + 1, c_part);
    }
    if (setterLen > 0) {
      c_part = this.dotPuzCksum(buffer, setterOffset, setterLen + 1, c_part);
    }
    if (copyrightLen > 0) {
      c_part = this.dotPuzCksum(
          buffer, copyrightOffset, copyrightLen + 1, c_part);
    }
    for (let i = 0; i < orderedClueIndices.length; i++) {
      c_part = this.dotPuzCksum(buffer, clueOffsets[i], clueLens[i], c_part);
    }

    buffer[0x10] = 0x49 ^ (c_cib & 0xFF);
    buffer[0x11] = 0x43 ^ (c_sol & 0xFF);
    buffer[0x12] = 0x48 ^ (c_grid & 0xFF);
    buffer[0x13] = 0x45 ^ (c_part & 0xFF);

    buffer[0x14] = 0x41 ^ ((c_cib & 0xFF00) >> 8);
    buffer[0x15] = 0x54 ^ ((c_sol & 0xFF00) >> 8);
    buffer[0x16] = 0x45 ^ ((c_grid & 0xFF00) >> 8);
    buffer[0x17] = 0x44 ^ ((c_part & 0xFF00) >> 8); 
    return buffer.slice(0, offset)
  } catch (err) {
    alert('Cannot save this crossword as .puz: ' + err);
    return null
  }
}

Exet.prototype.downloadDotPuz = function() {
  let dotPuz = this.getDotPuz()
  if (!dotPuz) {
    exetModals.hide()
    return
  }
  const a = document.createElement("a");
  a.style.display = "none";
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([dotPuz], {type: "application/x-crossword"})
  );
  let filetitle = this.fileTitle()
  a.setAttribute("download",
    filetitle ? "exet-" + filetitle + ".puz" : "exet.puz");
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

Exet.prototype.makeWordParam = function(s) {
  return s.toLowerCase()
}

Exet.prototype.makeCharadeParam = function(s) {
  return s.toLowerCase().replace(/\?/g, '').replace(/[^a-z]/g, '')
}

Exet.prototype.makeAnagramParam = function(s) {
  s = this.makeCharadeParam(s)
  return "<" + s + ">"
}

Exet.prototype.makeCAParam = function(s) {
  return s.toLowerCase().replace(/\?/g, '')
}

Exet.prototype.makeAlternationParam = function(s) {
  s = this.makeCharadeParam(s)
  let out = 'A%3F'
  for (let c of s) {
    out = out + c + 'A'
  }
  return out + '%3F'
}

Exet.prototype.makeRevAlternationParam = function(s) {
  s = this.makeCharadeParam(s)
  let out = 'A%3F'
  for (let i = s.length - 1; i >= 0; i--) {
    out = out + s.charAt(i) + 'A'
  }
  return out + '%3F'
}

Exet.prototype.makeHiddenParam = function(s) {
  s = this.makeCharadeParam(s)
  if (s.length < 2) return s
  return 'A*"A' + s.charAt(0) + '"' + s.substr(1, s.length - 2) +
         '"' + s.charAt(s.length - 1) + 'A"A*'
}

Exet.prototype.makeRevHiddenParam = function(s) {
  s = this.makeCharadeParam(s)
  if (s.length < 2) return s
  let sr = ''
  for (let i = s.length - 1; i >= 0; i--) {
    sr = sr + s.charAt(i)
  }
  return 'A*"A' + sr.charAt(0) + '"' + sr.substr(1, sr.length - 2) +
         '"' + sr.charAt(sr.length - 1) + 'A"A*'
}

Exet.prototype.currClueIndex = function() {
  return this.puz.clueOrParentIndex(this.puz.currClueIndex);
}
Exet.prototype.currClue = function() {
  const ci = this.currClueIndex()
  if (!ci) return null
  return this.puz.clues[ci]
}

Exet.prototype.draftClue = function(ci) {
  const clue = this.puz.clues[ci]
  if (!clue) {
    return '';
  }
  if (clue.parentClueIndex) {
    const parent = this.puz.clues[clue.parentClueIndex];
    return 'See ' + parent.label + parent.dir.toLowerCase();
  }
  let ret = this.DRAFT + ` Set clue and clear draft marker...`
  let cells = this.cellsOfClue(clue)
  if (cells.length > 0) {
    ret = ret + ' (' + cells.length + ')'
  }
  return ret;
}

Exet.prototype.handleTabClick = function(id) {
  let tab = this.tabs[id]
  if (!tab) {
    return
  }
  this.currTab = id
  for (let x in this.tabs) {
    let xtab = this.tabs[x]
    xtab.frame.style.display = "none"
    xtab.button.className = xtab.button.className.replace(" active", "");
  }

  tab.frame.style.display = "block";
  tab.button.className += " active";

  if (id == "exet") {
    return
  }
  if (id == "inds") {
    this.indsTabNav();
    return
  }

  let theClue = this.currClue()
  if (!theClue) {
    return
  }
  let words = theClue.solution
  if (!words) {
    return
  }
  if (id == "dicts") {
    tab.words = this.makeWordParam(words);
    this.dictsTabNav();
    return
  }
  for (let i = 0; i < tab.sections.length; i++) {
    let section = tab.sections[i]
    let wordParam = section.maker ? section.maker.call(this, words) :
                    this.makeWordParam(words)
    if (section.url && (!section.param || section.param != wordParam)) {
      section.param = wordParam
      let url = section.url + wordParam
      section.content.src = url
      section.urldisp.innerText = url
      section.urldisp.href = url
    } else if (section.id == 'xet-charades' && section.param != wordParam) {
      section.param = wordParam
      this.updateCharades(wordParam)
    } else if (section.id == 'xet-companag' && section.param != wordParam) {
      section.param = wordParam
      this.caFodder.value = wordParam
      this.caAnagram.value = ''
      this.updateCA()
    }
  }
}

Exet.prototype.navDarkness = function(row, col) {
  darkness = this.puz.grid[row][col].darkness
  if (!darkness) {
    return
  }
  this.puz.deactivateCurrCell()
  this.puz.currRow = row
  this.puz.currCol = col

  darkness.style.fill = this.puz.colorScheme['caret']

  let cellLeft = this.puz.cellLeftPos(col, this.puz.GRIDLINE)
  let cellTop = this.puz.cellTopPos(row, this.puz.GRIDLINE)
  this.puz.gridInputWrapper.style.left = '' + cellLeft + 'px'
  this.puz.gridInputWrapper.style.top = '' + cellTop + 'px'
  this.puz.gridInput.value = ''
  this.puz.gridInputRarr.style.display = 'none'
  this.puz.gridInputDarr.style.display = 'none'
  this.puz.gridInputWrapper.style.display = ''
  this.puz.gridInput.focus()
}

Exet.prototype.arrowNav = function(key) {
  let row = this.puz.currRow
  let col = this.puz.currCol
  let useSaved = false
  if (key == 39) {
    // right arrow
    col = col + 1
    if (col >= this.puz.gridWidth) {
      useSaved = true
    }
  } else if (key == 37) {
    // left arrow
    col = col - 1
    if (col < 0) {
      useSaved = true
    }
  } else if (key == 40) {
    // down arrow
    row = row + 1
    if (row >= this.puz.gridHeight) {
      useSaved = true
    }
  } else if (key == 38) {
    // up arrow
    row = row - 1
    if (row < 0) {
      useSaved = true
    }
  }
  if (useSaved || this.puz.grid[row][col].isLight) {
    return this.hkuiSaved.apply(exet.puz, arguments);
  }
  this.navDarkness(row, col)
  return true
}

Exet.prototype.scrollCluesIfNeeded = function() {
  let clue = this.puz.clues[this.currClueIndex()]
  if (!clue) return
  let elt = clue.clueTR
  if (!elt) return
  const parPos = this.cluesPanel.getBoundingClientRect();
  if (parPos.bottom < 0) {
    return
  }
  let windowH = this.puz.getViewportHeight()
  if (!windowH || windowH <= 0) {
    return
  }
  if (parPos.top >= windowH) {
    return
  }
  const pos = elt.getBoundingClientRect();
  let ref = this.cluesPanel.firstElementChild
  if (pos.bottom < 0 || pos.bottom < parPos.top || pos.top >= windowH ||
      pos.top < parPos.top || pos.top >= parPos.bottom) {
    this.cluesPanel.scrollTop = pos.top - ref.getBoundingClientRect().top
  }
}

Exet.prototype.replaceHandlers = function() {
  this.puz.cnavToInner = (function() {
    exet.cnavToInnerSaved = exet.puz.cnavToInner;
    return function() {
      let ret = exet.cnavToInnerSaved.apply(exet.puz, arguments);
      exet.scrollCluesIfNeeded()
      exet.makeClueEditable()
      exet.renderClue()
      exet.updateFillChoices()
      exet.startDeadendSweep(exet.currClueIndex());
      exet.handleTabClick(exet.currTab)
      return ret
    };
  })();
  this.puz.activateCell = (function() {
    exet.activateCellSaved = exet.puz.activateCell;
    return function() {
      let ret = exet.activateCellSaved.apply(exet.puz, arguments);
      let gridCell = exet.puz.currCell()
      if (gridCell && !gridCell.isLight && gridCell.darkness) {
        exet.navDarkness(exet.puz.currRow, exet.puz.currCol)
      }
      return ret
    };
  })();
  this.puz.deactivateCurrCell = (function() {
    exet.dccSaved = exet.puz.deactivateCurrCell;
    return function() {
      let gridCell = exet.puz.currCell()
      if (gridCell && gridCell.darkness) {
        gridCell.darkness.style.fill = 'transparent'
      }
      exet.dccSaved.apply(exet.puz);
    };
  })();
  this.puz.handleKeyUpInner = (function() {
    exet.hkuiSaved = exet.puz.handleKeyUpInner;
    return function(key, shift=false) {
      if (key >= 37 && key <= 40) {
        return exet.arrowNav(key)
      }
      return exet.hkuiSaved.apply(exet.puz, arguments);
    };
  })();
  this.puz.updateAndSaveState = (function() {
    exet.uassSaved = exet.puz.updateAndSaveState;
    return function() {
      exet.uassSaved.apply(exet.puz);
      exet.throttledGridInput(null);
    };
  })();
}

Exet.prototype.isDraftClue = function(clueText) {
  return clueText.trim().startsWith(this.DRAFT)
}
Exet.prototype.renderClue = function(theClue=null) {
  if (!theClue) {
    theClue = exet.currClue()
  }
  if (!theClue || !theClue.clueSpan || theClue.parentClueIndex) {
    return
  }
  const c = theClue.clue
  let modC = c
  if (this.isDraftClue(c)) {
    modC = '<span class="xet-draft-marker">' +
      this.DRAFT + '</span> ' + c.substr(this.DRAFT.length).trim()
    theClue.clueTR.className = "xet-draft"
  } else {
    theClue.clueTR.className = "xlv-solved"
  }
  theClue.clue = modC
  this.puz.renderClueSpan(theClue, theClue.clueSpan)
  this.puz.revealClueAnno(theClue.index)
  theClue.clue = c
}

Exet.prototype.setDraftToggler = function() {
  const xetClue = document.getElementById("xet-clue")
  if (!xetClue) return
  const xetClueStat = document.getElementById("xet-clue-stat")
  if (this.currClueIsDraft) {
    xetClueStat.innerHTML = `<span
      class="xet-draft-marker">${this.DRAFT}</span>`
    xetClueStat.title = `Click to remove the ${this.DRAFT} marker from the clue`
  } else {
    xetClueStat.innerHTML = `<span class="xet-done-marker">${this.DRAFT}</span>`
    xetClueStat.title = `Click to add the ${this.DRAFT} marker back to the clue`
  }
}

Exet.prototype.makeClueEditable = function() {
  let theClue = this.currClue();
  if (!theClue) {
    return
  }
  let currClueText = document.getElementById(
      `${exet.puz.prefix}-curr-clue-text`)
  currClueText.innerHTML = `<span class="xet-action">Edit clue: </span><span
    id="xet-clue-stat" class="xet-clue-stat"></span>
    <span contenteditable="true" class="xet-editable" id="xet-clue"></span>`
  this.currClueIsDraft = this.isDraftClue(theClue.clue)
  // We make the raw clue text editable here, including any tags or
  // in-clue-anno markers (~{...}~).
  let xetClue = document.getElementById("xet-clue")
  xetClue.innerText = this.currClueIsDraft ?
    theClue.clue.substr(this.DRAFT.length).trim() : theClue.clue
  let handler = this.throttledClueChange.bind(this)
  xetClue.addEventListener('input', handler)
  this.setDraftToggler()
  let xetClueStat = document.getElementById("xet-clue-stat")
  xetClueStat.addEventListener('click', e => {
    exet.currClueIsDraft = !exet.currClueIsDraft;
    exet.setDraftToggler()
    exet.handleClueChange()
  });

  let spacer = document.createElement('span')
  spacer.innerHTML = `<br><span class="xet-action">Edit
      optional anno: </span>`
  this.puz.currClue.appendChild(spacer)

  let inCurrAnno = document.createElement('span')
  inCurrAnno.className = 'xet-anno xet-editable'
  inCurrAnno.id = 'xet-anno'
  inCurrAnno.contentEditable = true
  inCurrAnno.innerText = theClue.anno
  this.puz.currClue.appendChild(inCurrAnno)
  inCurrAnno.addEventListener('input', handler)

  this.puz.currClue.insertAdjacentHTML('afterbegin', `
    <div id="xet-linking" class="xet-linking">
    <button id="xet-add-linked" class="xlv-small-button">Add</button>
    <input id="xet-add-linked-num" name="xet-add-linked-num"
      title="Enter a clue number, optionally followed by A/D"
          class="xlv-answer" size="4" type="text"></input>
    as a linked clue.
    </div>
    `);
  let addLinked = document.getElementById("xet-add-linked");
  addLinked.addEventListener('click', this.addLinkedClue.bind(this));
  const linking = document.getElementById('xet-linking');
  linking.style.display = 'none';
  if (theClue.childrenClueIndices && theClue.childrenClueIndices.length > 0) {
    linking.insertAdjacentHTML('beforeend', `
      &nbsp;
      <button class="xlv-small-button" id="xet-unlink" style="color:red">
      Break linked clues
      </button>`)
    let unlink = document.getElementById("xet-unlink");
    unlink.addEventListener('click', this.unlinkCurrClue.bind(this));
  }
  let ccLabel = document.getElementById(`${this.puz.prefix}-curr-clue-label`)
  ccLabel.title = 'Click to add or break up linked clues';
  ccLabel.addEventListener('click', e => {
    exetModals.showModal(linking)
    e.stopPropagation()
  });

  this.puz.makeCurrClueVisible()
}

Exet.prototype.throttledClueChange = function() {
  if (this.throttledClueTimer) {
    clearTimeout(this.throttledClueTimer);
  }
  this.throttledClueTimer = setTimeout(() => {
    this.handleClueChange()
    this.throttledClueTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.handleClueChange = function() {
  let ci = this.currClueIndex()
  if (!ci) {
    return
  }
  let currClueText = document.getElementById('xet-clue')
  if (!currClueText) {
    return
  }
  let theClue = this.puz.clues[ci]
  if (!theClue) {
    return
  }
  let clueTR = theClue.clueTR
  if (!clueTR) {
    return
  }
  let clueSpan = theClue.clueSpan
  if (!clueSpan) {
    return
  }

  let currClueAnno = document.getElementById('xet-anno')
  if (!currClueAnno) {
    return
  }
  if (!theClue.annoSpan) {
    return
  }

  this.saveCursor()

  let expEnumLen = this.cellsOfClue(theClue).length
  this.stripInputLF(currClueText)
  let clue = currClueText.innerText.trim()
  let clueSansEnum = clue
  let oldEnum = ''
  let enumPos = theClue.clue.lastIndexOf('(')
  if (enumPos >= 0) {
    oldEnum = theClue.clue.substr(enumPos).trim()
  }
  let newEnum = ''
  enumPos = clue.lastIndexOf('(')
  if (enumPos >= 0) {
    newEnum = clue.substr(enumPos).trim()
    clueSansEnum = clue.substr(0, enumPos).trim()
  }
  if (this.puz.parseEnum(newEnum).enumLen != expEnumLen) {
    if (expEnumLen > 0) {
      newEnum = oldEnum || ('(' + expEnumLen + ')')
      clue = clueSansEnum + ' ' + newEnum
    } else {
      newEnum = ''
      clue = clueSansEnum
    }
    currClueText.innerText = clue
  }
  if (this.currClueIsDraft) {
    clue = this.DRAFT + ' ' + clue
  }
  this.setDraftToggler()

  theClue.clue = clue
  this.puz.parseInClueAnnos(theClue)
  this.renderClue(theClue)

  this.stripInputLF(currClueAnno)
  theClue.anno = currClueAnno.innerText
  theClue.annoSpan.lastElementChild.innerText = currClueAnno.innerText
  this.puz.revealClueAnno(ci)

  this.puz.makeCurrClueVisible()

  this.restoreCursor()

  if (oldEnum != newEnum) {
    if (this.handleGridInput()) {
      // throttledSaveRev() got called already
      return
    }
  }
  exetRevManager.throttledSaveRev(exetRevManager.REV_CLUE_CHANGE)
}

Exet.prototype.gridAcrossSpans = function(grid, w, row) {
  let spans = []
  let start = -1
  let len = 0
  for (let j = 0; j < w; j++) {
    if (grid[row][j].isLight) {
      if (start >= 0 && j > 0 && grid[row][j-1].isLight &&
          !grid[row][j-1].hasBarAfter) {
        len++
      } else {
        if (len > 1) {
          spans.push([start, len])
        }
        start = j
        len = 1
      }
    } else {
      if (len > 1) {
        spans.push([start, len])
      }
      start = -1
      len = 0
    }
  }
  if (len > 1) {
    spans.push([start, len])
  }
  return spans;
}

Exet.prototype.gridDownSpans = function(grid, h, col) {
  let spans = []
  let start = -1
  let len = 0
  for (let i = 0; i < h; i++) {
    if (grid[i][col].isLight) {
      if (start >= 0 && i > 0 && grid[i-1][col].isLight &&
          !grid[i-1][col].hasBarUnder) {
        len++
      } else {
        if (len > 1) {
          spans.push([start, len])
        }
        start = i
        len = 1
      }
    } else {
      if (len > 1) {
        spans.push([start, len])
      }
      start = -1
      len = 0
    }
  }
  if (len > 1) {
    spans.push([start, len])
  }
  return spans;
}

Exet.prototype.gridSymmetric = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      let symi = h - 1 - i
      let symj = w - 1 - j
      if (grid[i][j].isLight != grid[symi][symj].isLight) {
        return false
      }
      if (!grid[i][j].isLight) continue
      if (symj > 0 &&
          grid[i][j].hasBarAfter != grid[symi][symj - 1].hasBarAfter) {
        return false
      }
      if (symi > 0 &&
          grid[i][j].hasBarUnder != grid[symi - 1][symj].hasBarUnder) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridNumBlocks = function(grid, w, h) {
  let count = 0
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      if (!grid[i][j].isLight) {
        count++
      }
    }
  }
  return count
}

Exet.prototype.gridNumBars = function(grid, w, h) {
  let count = 0
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      if (!grid[i][j].isLight) {
        continue
      }
      if (j < w - 1 && grid[i][j].hasBarAfter) {
        count++
      }
      if (i < h - 1 && grid[i][j].hasBarUnder) {
        count++
      }
    }
  }
  return count
}

Exet.prototype.gridChequeredOK = function(grid, w, h, checkStrict=true) {
  let crossers = new Array(h)
  for (let i = 0; i < h; i++) {
    crossers[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      crossers[i][j] = 0
      if (!grid[i][j].isLight) {
        continue
      }
      if ((j > 0 && grid[i][j-1].isLight && !grid[i][j-1].hasBarAfter) ||
          (j < w - 1 && grid[i][j+1].isLight && !grid[i][j].hasBarAfter)) {
        crossers[i][j]++
      }
      if ((i > 0 && grid[i-1][j].isLight && !grid[i-1][j].hasBarUnder) ||
          (i < h - 1 && grid[i+1][j].isLight && !grid[i][j].hasBarUnder)) {
        crossers[i][j]++
      }
      if (crossers[i][j] == 1 &&
          ((j > 0 && crossers[i][j-1] == 1 && !grid[i][j-1].hasBarAfter) ||
           (i > 0 && crossers[i-1][j] == 1 && !grid[i-1][j].hasBarUnder))) {
        return false
      }
    }
  }
  const minSpan = 4
  for (let i = 0; i < h; i++) {
    let spans = this.gridAcrossSpans(grid, w, i)
    for (let span of spans) {
      if (checkStrict && span[1] < minSpan) {
        return false
      }
      let numChecked = 0
      let numUnches = 0
      for (let j = span[0]; j < span[0] + span[1]; j++) {
        if (crossers[i][j] < 2) numUnches++
        else numChecked++
      }
      if (numUnches > numChecked + 1) {
        return false
      }
      if (checkStrict && numUnches == numChecked + 1 && numUnches < 5) {
        return false
      }
    }
  }
  for (let j = 0; j < w; j++) {
    let spans = this.gridDownSpans(grid, h, j)
    for (let span of spans) {
      if (checkStrict && span[1] < minSpan) {
        return false
      }
      let numChecked = 0
      let numUnches = 0
      for (let i = span[0]; i < span[0] + span[1]; i++) {
        if (crossers[i][j] < 2) numUnches++
        else numChecked++
      }
      if (numUnches > numChecked + 1) {
        return false
      }
      if (checkStrict && numUnches == numChecked + 1 && numUnches < 5) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridUnchequeredOK = function(grid, w, h, checkStrict=true) {
  let crossers = new Array(h)
  for (let i = 0; i < h; i++) {
    crossers[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      crossers[i][j] = 0
      if (!grid[i][j].isLight) {
        continue
      }
      if ((j > 0 && grid[i][j-1].isLight && !grid[i][j-1].hasBarAfter) ||
          (j < w - 1 && grid[i][j+1].isLight && !grid[i][j].hasBarAfter)) {
        crossers[i][j]++
      }
      if ((i > 0 && grid[i-1][j].isLight && !grid[i-1][j].hasBarUnder) ||
          (i < h - 1 && grid[i+1][j].isLight && !grid[i][j].hasBarUnder)) {
        crossers[i][j]++
      }
      if (crossers[i][j] < 2) {
        return false
      }
    }
  }
  if (!checkStrict) {
    return true
  }
  const minSpan = 3
  for (let i = 0; i < h; i++) {
    let spans = this.gridAcrossSpans(grid, w, i)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
    }
  }
  for (let j = 0; j < w; j++) {
    let spans = this.gridDownSpans(grid, h, j)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridConnected = function(grid, w, h) {
  let cells = []
  let visited = new Array(h)
  for (let i = 0; i < h; i++) {
    visited[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      visited[i][j] = false
      if (grid[i][j].isLight) {
        cells.push([i,j])
      }
    }
  }
  if (cells.length == 0) return false
  let reachable = [cells[0]]
  visited[cells[0][0]][cells[0][1]] = true
  let x = 0
  while (x < reachable.length) {
    let r = reachable[x][0]
    let c = reachable[x][1]
    x++
    if (c > 0 && grid[r][c-1].isLight && !grid[r][c-1].hasBarAfter &&
        !visited[r][c-1]) {
      visited[r][c-1] = true
      reachable.push([r,c-1])
    }
    if (c < w - 1 && grid[r][c+1].isLight && !grid[r][c].hasBarAfter &&
        !visited[r][c+1]) {
      visited[r][c+1] = true
      reachable.push([r,c+1])
    }
    if (r > 0 && grid[r-1][c].isLight && !grid[r-1][c].hasBarUnder &&
        !visited[r-1][c]) {
      visited[r-1][c] = true
      reachable.push([r-1,c])
    }
    if (r < h - 1 && grid[r+1][c].isLight && !grid[r][c].hasBarUnder &&
        !visited[r+1][c]) {
      visited[r+1][c] = true
      reachable.push([r+1,c])
    }
  }
  return reachable.length == cells.length
}

// Return < 0 if randomness suggests picking nothing.
Exet.prototype.randomIndex = function(candidates) {
  if (candidates.length <= 0 || Math.random() > 0.85) return -1
  if (candidates.length == 1) {
    return 0
  }
  return Math.floor(Math.random() * candidates.length)
}

Exet.prototype.automagicBlocksInner = function(chequered, showAlerts=true) {
  const minSpan = chequered ? 4 : 3
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let wby2 = Math.ceil(w / 2)
  let h = this.puz.gridHeight
  let hby2 = Math.ceil(h / 2)
  let numCandidates = 0
  let numChanges = 0
  let rowcols = []
  let minwhby2 = Math.min(wby2, hby2)
  for (let x = 0; x < minwhby2; x++) {
    rowcols.push(["row", x])
    rowcols.push(["col", x])
  }
  for (let i = minwhby2 + 1; i < hby2; i++) {
    rowcols.push(["row", i])
  }
  for (let j = minwhby2 + 1; j < wby2; j++) {
    rowcols.push(["col", j])
  }
  for (rc of rowcols) {
    let k1 = rc[1]
    let isRow = (rc[0] == "row")
    let symk1 = w - 1 - k1
    if (isRow) {
      symk1 = h - 1 - k1
    }
    let spans = isRow ? this.gridAcrossSpans(grid, w, k1) :
                this.gridDownSpans(grid, h, k1)
    let candidates = []
    for (let span of spans) {
      for (let x = minSpan; x < span[1] - minSpan; x++) {
        let k2 = span[0] + x
        let symk2 = w - 1 - k2
        if (isRow) {
          symk2 = h - 1 - k2
        }
        let gridCell = isRow ? grid[k1][k2] : grid[k2][k1]
        let gridSymCell = isRow ? grid[symk1][symk2] : grid[symk2][symk1]
        if (gridCell.solution != '?' || gridSymCell.solution != '?') {
          continue
        }
        gridCell.isLight = false
        gridSymCell.isLight = false
        if (this.gridConnected(grid, w, h) &&
            ((chequered && this.gridChequeredOK(grid, w, h)) ||
             (!chequered && this.gridUnchequeredOK(grid, w, h)))) {
          candidates.push(k2)
        }
        gridCell.isLight = true
        gridSymCell.isLight = true
      }
    }
    if (candidates.length == 0) {
      continue
    }
    numCandidates += candidates.length
    let randIndex = this.randomIndex(candidates)
    if (randIndex < 0) {
      // We randomly chose not to make a change
      continue
    }
    let k2 = candidates[randIndex]
    let symk2 = w - 1 - k2
    if (isRow) {
      symk2 = h - 1 - k2
    }
    let gridCell = isRow ? grid[k1][k2] : grid[k2][k1]
    let gridSymCell = isRow ? grid[symk1][symk2] : grid[symk2][symk1]
    gridCell.isLight = false
    gridSymCell.isLight = false
    numChanges += 2
  }
  if (numChanges > 0) {
    this.killInvalidatedClues()
  } else {
    if (showAlerts) {
      if (numCandidates == 0) {
        alert('Add automagic blocks: found no further candidate cells ' +
              'for turning into blocks')
      } else {
        alert('Add automagic blocks: found some candidate cells for ' +
              'turning into blocks, but random numbers favoured no changes')
      }
    }
  }
  return numChanges > 0;
}

Exet.prototype.automagicBlocks = function(showAlerts=true) {
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let h = this.puz.gridHeight
  if (this.gridNumBars(grid, w, h) > 0) {
    if (showAlerts) {
      alert('Cannot add automagic blocks when the grid has barred cells');
    }
    return false
  }
  if (!this.gridConnected(grid, w, h)) {
    if (showAlerts) {
      alert('Cannot add automagic blocks when the grid cells are not ' +
            'fully connected');
    }
    return false
  }
  if (!this.gridSymmetric(grid, w, h)) {
    if (showAlerts) {
      alert('Cannot add automagic blocks when the grid is not fully symmetric');
    }
    return false
  }
  if (this.gridUnchequeredOK(grid, w, h)) {
    return this.automagicBlocksInner(false, showAlerts)
  } else  if (this.gridChequeredOK(grid, w, h)) {
    return this.automagicBlocksInner(true, showAlerts)
  } else {
    if (showAlerts) alert('Cannot add automagic blocks to the current grid');
    return false
  }
  return false
}

Exet.prototype.setScore = function(fillState) {
  fillState.scoreF = 0
  fillState.scoreV = 0
  fillState.score = 0

  // Treat viability/5 = independent probability.
  const log5 = 1.6094379124341003
  fillState.unfilled = []
  fillState.lettersUsed = {}
  let numLights = 0
  for (let i = 0; i < fillState.gridHeight; i++) {
    for (let j = 0; j < fillState.gridWidth; j++) {
      let gridCell = fillState.grid[i][j]
      if (!gridCell.isLight) {
        continue
      }
      numLights++
      if (gridCell.solution != '?' || gridCell.currLetter != '?') {
        let c = gridCell.solution
        if (c == '?') c = gridCell.currLetter
        console.assert(c, i, j, gridCell)
        fillState.lettersUsed[c] = true
        continue
      }
      if (gridCell.viability <= 0) {
        fillState.unfilled.push([i, j, gridCell.viability]);
        fillState.scoreV = - Number.MAX_VALUE
        fillState.score = fillState.scoreV
        fillState.viable = false
        return
      }
      fillState.scoreV += Math.log(gridCell.viability)
      fillState.unfilled.push([i, j, gridCell.viability]);
    }
  }
  fillState.numLettersUsed = Object.keys(fillState.lettersUsed).length
  if (numLights == 0) {
    return
  }
  fillState.unfilled.sort((a, b) => a[2] - b[2]);
  fillState.scoreV /= 100
  fillState.score += fillState.scoreV

  fillState.scoreF = 25 * (numLights - fillState.unfilled.length) / 100
  fillState.score += fillState.scoreF
}

Exet.prototype.getAutofillBase = function() {
  let fillState = new ExetFillState(this.fillState)
  fillState.delta = []
  fillState.preflexUsed = {}
  fillState.numPreflexUsed = 0
  this.setScore(fillState)
  return fillState
}

Exet.prototype.isFull = function(candidate) {
  return candidate.unfilled.length == 0
}

Exet.prototype.addToBeam = function(candidate) {
  // this.autofill.candidates[] is sorted on increasing score
  // (last entry is the best)
  if (this.autofill.candidates.length == 0) {
    this.autofill.candidates.push(candidate)
    return
  }
  if (this.autofill.candidates.length >= this.autofill.beamWidth) {
    if (candidate.score < this.autofill.candidates[0].score) {
      return
    } else if (candidate.score == this.autofill.candidates[0].score) {
      if (Math.random() >= 0.5) {
        this.autofill.candidates[0] = candidate;
      }
      return
    }
  }
  let idx = 0;
  while (idx < this.autofill.candidates.length &&
         candidate.score > this.autofill.candidates[idx].score) {
    idx++
  }
  let start = this.autofill.candidates.length ==
    this.autofill.beamWidth ? 1 : 0
  let newbeam = this.autofill.candidates.slice(start, idx)
  newbeam.push(candidate)
  this.autofill.candidates = newbeam.concat(
      this.autofill.candidates.slice(idx))
}

Exet.prototype.beamSearchStep = function() {
  if (this.autofill.throttledTimer) {
    clearTimeout(this.autofill.throttledTimer)
  }
  if (this.autofill.candidates.length == 0) {
    return
  }
  let startTS = Date.now()
  this.autofill.throttledTimer = null;
  let candidate = this.autofill.candidates.pop()
  this.autofill.step++
  this.autofill.stepSpan.innerText = this.autofill.step
  this.addAutofillChildren(candidate)
  this.autofill.currBeamSpan.innerText = this.autofill.candidates.length

  this.autofill.msUsed += (Date.now() - startTS)
  this.autofill.timeSpan.innerText = this.autofill.msUsed
  this.autofill.speedSpan.innerText = (this.autofill.msUsed /
      this.autofill.step).toFixed(0)

  if (this.autofill.candidates.length > 0) {
    let index = this.autofill.candidates.length - 1
    let best = this.autofill.candidates[index];
    this.autofill.preflexUsedSpan.innerText = best.numPreflexUsed
    this.autofill.pangramSpan.innerText = best.numLettersUsed
    this.autofill.scoreSpan.innerText = best.score.toFixed(2)
    this.autofill.scoreVSpan.innerText = best.scoreV.toFixed(2)
    this.autofill.scoreFSpan.innerText = best.scoreF.toFixed(2)
    this.updateAutofill(best)

    if (this.isFull(best)) {
      this.autofill.accept.disabled = false
      this.autofill.clear.disabled = false
      this.resetAutofill('Succeeded!')
    } else {
      this.autofill.throttledTimer = setTimeout(() => {
        exet.beamSearchStep();
      }, this.autofill.lag);
    }
  } else {
    this.autofill.accept.disabled = false
    this.autofill.clear.disabled = false
    this.resetAutofill('Failed')
  }
}

Exet.prototype.shuffle = function(arr) {
  // Fisher-Yates shuffle of arr[]
  for (let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

Exet.prototype.letterRarity = function(c) {
  if (c == 'Z' || c == 'J' || c == 'Q') return 0
  if (c == 'B' || c == 'V' || c == 'X') return 1
  if (c == 'K' || c == 'Y') return 2
  return 3
}

Exet.prototype.addAutofillChildren = function(candidate) {
  if (!candidate || !candidate.unfilled || candidate.unfilled.length == 0) {
    return
  }

  let constrainerLimit = 2000

  if (this.autofill.priorityCluesIndex < this.autofill.priorityClues.length) {
    let ciToTry = this.autofill.priorityClues[
        this.autofill.priorityCluesIndex++]
    if (this.autofill.priorityCluesIndex ==
        this.autofill.priorityClues.length) {
      // Recover, if all preferred fills were bad choices
      this.addToBeam(this.autofill.base)
    }
    let ci = ciToTry[0]
    let toTry = ciToTry[1]
    let theClue = candidate.clues[ci]
    if (!theClue || !theClue.lChoices || theClue.lChoices.length <= 1) {
      // Move to the next priorityClue
      this.addAutofillChildren(candidate)
      return
    }
    let numChoices = theClue.lChoices.length
    let toTryAndViable = []
    let numToTry = Object.keys(toTry).length
    for (let i = 0; i < numChoices && numToTry > toTryAndViable.length; i++) {
      let idx = theClue.lChoices[i]
      if (toTry[idx]) {
        toTryAndViable.push(idx)
      }
    }
    if (toTryAndViable.length == 0) {
      // Move to the next priorityClue
      this.addAutofillChildren(candidate)
      return
    }
    let cells = this.cellsOfClue(theClue)
    for (let lchoice of toTryAndViable) {
      let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
      let child = new ExetFillState(candidate)
      child.clues[ci].lChoices = [lchoice]
      child.delta = candidate.delta.slice()
      for (let j = 0; j < cells.length; j++) {
        let row = cells[j][0]
        let col = cells[j][1]
        let childCell = child.grid[row][col]
        let c = key.charAt(j).toUpperCase()
        childCell.cChoices = {}
        childCell.cChoices[c] = true
        childCell.currLetter = c
        child.delta.push([row, col, c])
      }
      this.refineLightChoices(child, constrainerLimit)
      if (child.viable) {
        this.setScore(child)
        this.addToBeam(child)
      }
    }
    return
  }

  // Pick a random offset from 0,1,2,3
  let cellIndex = Math.floor(Math.random() *
                             Math.min(candidate.unfilled.length, 4))
  let row = candidate.unfilled[cellIndex][0]
  let col = candidate.unfilled[cellIndex][1]
  let cell = candidate.grid[row][col]

  let choices = Object.keys(cell.cChoices)
  if (this.autofill.boostPangram) {
    // Try unused and rare letters first
    let choices1 = []
    let choices2 = []
    for (let c in cell.cChoices) {
      if (!candidate.lettersUsed[c]) choices1.push(c)
      else choices2.push(c)
    }
    choices1.sort((c1, c2) => this.letterRarity(c1) - this.letterRarity(c2));
    choices = choices1.concat(choices2)
  }
  for (let c of choices) {
    let child = new ExetFillState(candidate)
    let childCell = child.grid[row][col]
    childCell.cChoices = {}
    childCell.cChoices[c] = true
    childCell.currLetter = c
    child.delta = candidate.delta.slice()
    child.delta.push([row, col, c])
    this.refineLightChoices(child, constrainerLimit)
    if (child.viable) {
      this.setScore(child)
      this.addToBeam(child)
    }
  }
}

Exet.prototype.getAutofillPriorityClues = function() {
  let pclues = []
  if (this.preflex.length == 0) {
    return pclues
  }
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (theClue.solution.indexOf('?') < 0) continue
    if (this.preflexByLen[theClue.enumLen]) {
      let toTry = {}
      for (let idx of this.preflexByLen[theClue.enumLen]) {
        toTry[idx] = true
      }
      pclues.push([ci, toTry])
    }
  }
  this.shuffle(pclues)
  return pclues
}

Exet.prototype.updateAutofillPreflex = function() {
  this.autofill.preflexTotalSpan.innerText = this.preflex.length
  this.autofill.unpreflexTotalSpan.innerText = Object.keys(
      this.unpreflex).length
  this.autofill.minpopSpan.innerText = this.minpop
  this.autofill.indexMinPopSpan.innerText = Number(
      this.indexMinPop).toLocaleString()
  this.autofill.properNounsSpan.innerText = this.noProperNouns ?
      "disallowed" : "allowed"
}

Exet.prototype.startstopAutofill = function() {
  if (!this.autofill.running) {
    if (this.puz.numCellsToFill == this.puz.numCellsFilled) {
      alert('The grid is already full')
      return
    }
    if (this.autofill.candidates.length == 0) {
      let candidate = this.getAutofillBase()
      if (!candidate.viable) {
        alert('Autofill will not work on the current grid. Perhaps retry ' +
              'after clearing some constraining lights?')
        return
      }
      this.autofill.base = candidate
      this.autofill.candidates.push(candidate)
      this.autofill.currBeamSpan.innerText = this.autofill.candidates.length
      this.autofill.priorityClues = this.getAutofillPriorityClues()
      this.autofill.priorityCluesIndex = 0
    }

    if (this.viabilityUpdateTimer) {
      clearTimeout(this.viabilityUpdateTimer);
      this.viabilityUpdateTimer = null;
    }

    this.updateAutofillPreflex()
    this.autofill.running = true
    this.autofill.status = 'Running'
    this.autofill.accept.disabled = true
    this.autofill.clear.disabled = true
    this.autofill.statusSpan.innerText = this.autofill.status
    this.sweepIndicator.className = 'xet-sweeping-animated'
    this.autofill.startstop.innerText = 'Pause'
    this.autofill.startstop.className = 'xlv-button xet-pink-button'
    let beamWidth = parseInt(this.autofill.beamWidthInput.value)
    if (isNaN(beamWidth) || beamWidth <= 0) {
      this.autofill.beamWidthInput.value = this.autofill.beamWidth
    } else {
      this.autofill.beamWidth = beamWidth
    }
    this.autofill.boostPangram = this.autofill.pangramInput.checked
    if (this.autofill.throttledTimer) {
      clearTimeout(this.autofill.throttledTimer)
    }
    this.autofill.throttledTimer = setTimeout(() => {
      this.beamSearchStep();
    }, this.autofill.lag);
  } else {
    this.autofill.running = false
    this.updateSweepInd()
    this.autofill.startstop.innerText = 'Start'
    this.autofill.startstop.className = 'xlv-button'
    this.autofill.status = 'Stopped'
    this.autofill.accept.disabled = false
    this.autofill.clear.disabled = false
    this.autofill.statusSpan.innerText = this.autofill.status
    clearTimeout(this.autofill.throttledTimer)
    this.autofill.throttledTimer = null
  }
}

Exet.prototype.resetAutofill = function(status) {
  this.autofill.candidates = []
  this.autofill.step = 0
  this.autofill.msUsed = 0
  this.updateAutofillPreflex()
  if (!this.autofill.running) {
    return
  }
  if (this.autofill.throttledTimer) {
    clearTimeout(this.autofill.throttledTimer)
    this.autofill.throttledTimer = null
  }
  this.autofill.status = status
  this.autofill.statusSpan.innerText = status
  this.autofill.running = false
  this.updateSweepInd()
  this.autofill.startstop.innerText = 'Start'
  this.autofill.startstop.className = 'xlv-button'
}

Exet.prototype.updateAutofill = function(candidate) {
  console.assert(this.autofill.base, this.autofill)
  this.fillState = new ExetFillState(this.autofill.base)
  // Only use suggestions from full lights
  for (let ci in candidate.clues) {
    let lChoices = candidate.clues[ci].lChoices
    if (lChoices.length != 1) {
      continue
    }
    let theClue = this.fillState.clues[ci]
    console.assert(theClue, ci)
    theClue.lChoices = lChoices
    let cells = this.cellsOfClue(theClue)
    for (let c of cells) {
      let row = c[0]
      let col = c[1]
      this.fillState.grid[row][col].cChoices =
          candidate.grid[row][col].cChoices
    }
  }
  this.updateViablots()
}

Exet.prototype.initAutofill = function() {
  if (!this.autofill) {
    this.autofill = {
      candidates: [],
      beamWidth: 64,
      step: 0,
      running: false,
      throttledTimer: null,
      lag: 200,
      status: 'None',
      boostPangram: false,
    }
  }
  this.autofill.clear = document.getElementById("xet-autofill-clear")
  this.autofill.clear.disabled = true
  this.autofill.clear.addEventListener('click', e => {
    this.autofill.accept.disabled = true
    this.autofill.clear.disabled = true
    exet.resetAutofill('Cleared')
    exet.resetViability()
  })
  this.autofill.accept = document.getElementById("xet-autofill-accept")
  this.autofill.accept.disabled = true
  this.autofill.accept.addEventListener('click', e => {
    this.autofill.accept.disabled = true
    this.autofill.clear.disabled = true
    exet.handleKeyDown('=')
  })
  this.autofill.startstop = document.getElementById("xet-autofill-startstop")
  if (this.autofill.running) {
    this.autofill.startstop.innerText = 'Pause'
    this.autofill.startstop.className = 'xlv-button xet-pink-button'
  }
  this.autofill.startstop.addEventListener(
      'click', this.startstopAutofill.bind(this))

  this.autofill.beamWidthInput = document.getElementById(
      'xet-autofill-max-beam')
  this.autofill.beamWidthInput.value = this.autofill.beamWidth

  this.autofill.pangramInput = document.getElementById(
      'xet-autofill-boost-pangram')
  this.autofill.pangramInput.checked = this.autofill.boostPangram

  this.autofill.stepSpan = document.getElementById('xet-autofill-step')
  this.autofill.stepSpan.innerText = this.autofill.step

  this.autofill.statusSpan = document.getElementById('xet-autofill-status')
  this.autofill.statusSpan.innerText = this.autofill.status

  this.autofill.timeSpan = document.getElementById('xet-autofill-time')
  this.autofill.speedSpan = document.getElementById('xet-autofill-speed')

  this.autofill.currBeamSpan = document.getElementById('xet-autofill-curr-beam')
  this.autofill.currBeamSpan.innerText = this.autofill.candidates.length

  this.autofill.scoreSpan = document.getElementById('xet-autofill-score')
  this.autofill.scoreVSpan = document.getElementById('xet-autofill-score-v')
  this.autofill.scoreFSpan = document.getElementById('xet-autofill-score-f')

  this.autofill.preflexTotalSpan = document.getElementById(
      'xet-autofill-preflex-total')
  this.autofill.preflexUsedSpan = document.getElementById(
      'xet-autofill-preflex-used')
  this.autofill.unpreflexTotalSpan = document.getElementById(
      'xet-autofill-unpreflex-total')
  this.autofill.minpopSpan = document.getElementById('xet-autofill-minpop')
  this.autofill.indexMinPopSpan = document.getElementById(
      'xet-autofill-index-minpop')
  this.autofill.properNounsSpan = document.getElementById(
      'xet-autofill-proper-nouns')
  this.autofill.pangramSpan = document.getElementById('xet-autofill-pangram')
  if (this.autofill.candidates.length > 0) {
    let candidate = this.autofill.candidates[
      this.autofill.candidates.length - 1]
    this.autofill.preflexUsedSpan.innerText = candidate.numPreflexUsed
    this.autofill.pangramSpan.innerText = candidate.numLettersUsed
    this.autofill.scoreSpan.innerText = candidate.score.toFixed(2)
    this.autofill.scoreVSpan.innerText = candidate.scoreV.toFixed(2)
    this.autofill.scoreFSpan.innerText = candidate.scoreF.toFixed(2)
  }
}

// Can be called with e as an event or as a key directly
Exet.prototype.handleKeyDown = function(e) {
  let key = e.key || e
  if (key == '=') {
    if (this.acceptAll()) {
      this.handleGridInput(exetRevManager.REV_AUTOFILL_GRIDFILL_CHANGE)
    }
    return
  }
  let gridCell = this.puz.currCell()
  if (!gridCell) {
    return
  }
  let revType = exetRevManager.REV_GRID_CHANGE
  let row = this.puz.currRow
  let col = this.puz.currCol
  if (key == '.') {
    gridCell.isLight = !gridCell.isLight
    if (!this.asymOK.checked) {
      let symRow = this.puz.gridHeight - 1 - row
      let symCol = this.puz.gridWidth - 1 - col
      let symCell = this.puz.grid[symRow][symCol]
      symCell.isLight = gridCell.isLight
    }
    this.killInvalidatedClues()
  } else if (key == '|') {
    if (col >= this.gridWidth - 1) {
      return
    }
    gridCell.hasBarAfter = !gridCell.hasBarAfter
    if (!this.asymOK.checked) {
      let symRow = this.puz.gridHeight - 1 - row
      let symCol = this.puz.gridWidth - 2 - col
      let symCell = this.puz.grid[symRow][symCol]
      symCell.hasBarAfter = gridCell.hasBarAfter
    }
    this.killInvalidatedClues()
  } else if (key == '_') {
    if (row >= this.gridHeight - 1) {
      return
    }
    gridCell.hasBarUnder = !gridCell.hasBarUnder
    if (!this.asymOK.checked) {
      let symRow = this.puz.gridHeight - 2 - row
      let symCol = this.puz.gridWidth - 1 - col
      let symCell = this.puz.grid[symRow][symCol]
      symCell.hasBarUnder = gridCell.hasBarUnder
    }
    this.killInvalidatedClues()
  } else if (key == '#') {
    if (!this.automagicBlocks()) {
      return
    }
  } else if (key == '!') {
    gridCell.prefill = !gridCell.prefill
    revType = exetRevManager.REV_METADATA_CHANGE
  } else if (key == '@') {
    gridCell.hasCircle = !gridCell.hasCircle
    revType = exetRevManager.REV_METADATA_CHANGE
  } else {
    return
  }
  this.updatePuzzle(revType)
}

Exet.prototype.throttledGridInput = function(e) {
  if (this.throttledGridTimer) {
    clearTimeout(this.throttledGridTimer);
  }
  this.throttledGridTimer = setTimeout(() => {
    this.handleGridInput()
    this.throttledGridTimer = null;
  }, this.inputLagMS);
}

// Thie will be called after Exolve's handleGridInput has done its thing.
Exet.prototype.handleGridInput = function(revType=null) {
  let needsUpdate = false
  for (let row = 0; row < this.puz.gridHeight; row++) {
    for (let col = 0; col < this.puz.gridWidth; col++) {
      let gridCell = this.puz.grid[row][col]
        if (!gridCell.isLight) {
          continue
        }
        let newSol = (gridCell.currLetter != '0' ?  gridCell.currLetter : '?')
        if (gridCell.solution != newSol) {
          gridCell.solution = newSol
          needsUpdate = true
        }
        if (gridCell.currLetter != '0' && gridCell.currLetter != '?' &&
            gridCell.viablot) {
          gridCell.viablot.style.fill = 'transparent'
        }
     }
  }
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    let oldPH = theClue.placeholder
    let oldSol = theClue.solution
    theClue.placeholder = ''
    theClue.solution = ''
    let enumPos = theClue.clue.lastIndexOf('(')
    if (enumPos >= 0) {
      theClue.placeholder = this.puz.parseEnum(
          theClue.clue.substr(enumPos)).placeholder
    }
    this.puz.setClueSolution(ci)
    if (theClue.placeholder != oldPH || theClue.solution != oldSol) {
      needsUpdate = true
    }
  }
  if (needsUpdate) {
    if (!revType) revType = exetRevManager.REV_GRIDFILL_CHANGE
    this.updatePuzzle(revType)
  }
  return needsUpdate
}

Exet.prototype.killInvalidatedClues = function(row, col) {
  let tempId = this.puz.id + '-temp'
  let specs = this.getExolve(tempId, true)
  document.getElementById("xet-temp").innerHTML = ''
  let newPuz = new Exolve(specs, "xet-temp", null, false, 0, 0, false)
  for (let ci in this.puz.clues) {
    if (!newPuz.clues[ci] ||
        !newPuz.sameCells(newPuz.clues[ci].cells, this.puz.clues[ci].cells)) {
      let theClue = this.puz.clues[ci];
      if (theClue.parentClueIndex) {
        this.unlinkClue(theClue.parentClueIndex);
      } else if (theClue.childrenClueIndices &&
                 theClue.childrenClueIndices.length > 0) {
        this.unlinkClue(ci);
      }
      delete this.puz.clues[ci]
    }
  }
  document.getElementById("xet-temp").innerHTML = ''
  delete exolvePuzzles[tempId]
}

Exet.prototype.makeExolve = function(specs) {
  let xlvFrame = document.getElementById('xet-xlv-frame')
  xlvFrame.innerHTML = ''
  if (this.puz) {
    delete exolvePuzzles[this.puz.id]
  }
  try {
    let ptemp = new Exolve(specs, 'xet-xlv-frame', this.setPuzzle.bind(this), false, 0, 0, false)
  } catch (err) {
    this.puz = null
    alert('Could not create/parse Exolve puzzle. Please reload and retry. The JavaScript console might show some diagnostic messages.')
    console.log('Could not parse Exolve specs:')
    console.log(specs)
    console.log('Error thrown was:')
    console.log(err)
  }

  if (!this.puz) {
    return
  }

  this.handleTabClick(this.currTab);
  exetState.lastId = this.puz.id
  exetRevManager.saveLocal(
      exetRevManager.SPECIAL_KEY, JSON.stringify(exetState))
}

Exet.prototype.unlinkClue = function(ci) {
  let theClue = this.puz.clues[ci];
  if (!theClue || !theClue.childrenClueIndices ||
      theClue.childrenClueIndices.length == 0) {
    return;
  }
  for (let cci of theClue.childrenClueIndices) {
    const cClue = this.puz.clues[cci];
    delete cClue.parentClueIndex
    cClue.clue = this.draftClue(cci);
    cClue.solution = ''
    cClue.anno = ''
  }
  theClue.childrenClueIndices = [];
  theClue.displayLabel = theClue.label;
  theClue.clue = this.draftClue(ci);
  theClue.solution = ''
  theClue.anno = ''
}

Exet.prototype.unlinkCurrClue = function() {
  if (!this.puz) return
  let ci = this.currClueIndex()
  this.unlinkClue(ci);
  this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
}

Exet.prototype.addLinkedClue = function() {
  if (!this.puz) return
  let ci = this.currClueIndex()
  let theClue = this.puz.clues[ci];
  if (!theClue) return;
  const num = document.getElementById("xet-add-linked-num");
  if (!num) return;
  let parsed = this.puz.parseClueLabel(num.value);
  if (!parsed.label) {
    alert('Please provide a clue number');
    return
  }
  let aClue = this.puz.clues['A' + parsed.label];
  let dClue = this.puz.clues['D' + parsed.label];
  let dispDir = ''
  if (!parsed.dir) {
    if (aClue && !dClue) {
      parsed.dir = 'A';
    } else if (dClue && !aClue) {
      parsed.dir = 'D';
    } else if (!aClue && !dClue) {
      alert('There is no ' + parsed.label + ' Across/Down clue');
      return
    } else {
      parsed.dir = theClue.dir
    }
  } else {
    if (parsed.dir == 'A') {
      if (!aClue) {
        alert('There is no ' + parsed.label + ' Across clue');
        return
      }
      if (dClue && theClue.dir != 'A') dispDir = 'a';
    } else if (parsed.dir == 'D') {
      if (!dClue) {
        alert('There is no ' + parsed.label + ' Down clue');
        return
      }
      if (aClue && theClue.dir != 'D') dispDir = 'd';
    } else {
      alert('Unsupported direction: ' + parsed.dir)
      return
    }
  }
  const cci = parsed.dir + parsed.label
  if (cci == ci) {
    alert('Cannot link a clue to itself');
    return;
  }
  const cClue = this.puz.clues[cci];
  if (cClue.parentClueIndex) {
    alert(parsed.label + parsed.dir +
          ' is already part of another linked clue');
    return
  }
  if (cClue.childrenClueIndices && cClue.childrenClueIndices.length > 0) {
    alert(parsed.label + parsed.dir + ' is itself a linked clue');
    return
  }
  cClue.parentClueIndex = ci
  cClue.clue = this.draftClue(cci);
  cClue.solution = ''
  cClue.anno = ''
  theClue.childrenClueIndices.push(cci)
  theClue.displayLabel = theClue.displayLabel + ', ' + parsed.label + dispDir;
  theClue.clue = this.draftClue(ci);
  theClue.solution = ''
  theClue.anno = ''
  this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
}

Exet.prototype.clearCurr = function() {
  if (!this.puz) return
  exet.puz.clearCurr()
  theClue = this.currClue()
  theClue.clue = this.draftClue(this.currClueIndex());
  theClue.solution = ''
  theClue.anno = ''
  this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
}

Exet.prototype.clearAll = function() {
  if (!this.puz) return
  if (exet.puz.clearAll()) {
    for (let ci in this.puz.clues) {
      this.puz.clues[ci].clue = this.draftClue(ci)
      this.puz.clues[ci].solution = ''
      this.puz.clues[ci].anno = ''
    }
    this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
  }
}

Exet.prototype.saveCursor = function() {
  this.savedCaretPos = 0
  this.savedCaretPosId = ''
  let sel = window.getSelection();
  if (!sel) {
    return
  }
  if (sel.rangeCount) {
    let range = sel.getRangeAt(0);
    parentNode = range.commonAncestorContainer.parentNode
    if (parentNode) {
      this.savedCaretPosId = parentNode.id
      this.savedCaretPos = range.endOffset
    }
  }
}

Exet.prototype.restoreCursor = function() {
  if (this.savedCaretPosId) {
    const elt = document.getElementById(this.savedCaretPosId)
    if (elt && elt.firstChild) {
      window.getSelection().collapse(elt.firstChild, this.savedCaretPos)
    }
  }
  this.savedCaretPos = 0
  this.savedCaretPosId = ''
}

Exet.prototype.updatePuzzle = function(revType=0) {
  if (revType <= exetRevManager.REV_GRIDFILL_CHANGE &&
      revType != exetRevManager.REV_AUTOFILL_GRIDFILL_CHANGE) {
    this.resetAutofill('Aborted')
  }
  let row = this.puz.currRow
  let col = this.puz.currCol
  let dir = this.puz.currDir
  let scratch = this.puz.scratchPad.value
  this.savedIndsSelect = this.indsSelect ? this.indsSelect.value : ''
  this.saveCursor()

  let exolve = this.getExolve()
  this.makeExolve(exolve)

  this.puz.currDir = dir
  this.puz.currRow = row
  this.puz.currCol = col
  this.puz.scratchPad.value = scratch
  this.restoreCursor()
  if (this.puz.currCellIsValid()) {
    if (this.puz.grid[row][col].isLight) {
      this.puz.activateCell(row, col)
    } else {
      this.navDarkness(row, col)
    }
  }
  if (revType > 0) {
    exetRevManager.throttledSaveRev(revType)
  }
}

Exet.prototype.getGrid = function(solved=true) {
  if (!this.puz) {
    return ''
  }
  let grid = ''
  for (let i = 0; i < this.puz.gridHeight; i++) {
    let gridRow = '    '
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight) {
        gridRow = gridRow + '.   '
      } else {
        gridRow = gridRow + (gridCell.currLetter != '0' ?
                             (solved ? gridCell.currLetter : '0') : '?')
        gridRow  = gridRow + (gridCell.hasCircle ? '@' : ' ')
        gridRow  = gridRow + (gridCell.prefill ? '!' : ' ')
        gridRow  = gridRow + (gridCell.hasBarAfter && gridCell.hasBarUnder ?
                              '+' : (gridCell.hasBarAfter ?
                              '|' : (gridCell.hasBarUnder ? '_' : ' ')))
      }
    }
    grid = grid + '\n' + gridRow
  }
  return grid
}

Exet.prototype.showClue = function(clue, forExolve=true, showEnums=true) {
  clue = clue.trim()
  if (showEnums) {
    return clue;
  }
  const idx = clue.lastIndexOf('(');
  if (idx < 0 || clue[clue.length - 1] != ')') {
    return clue;
  }
  return forExolve ? (clue + '*') : clue.substr(0, idx)
}

Exet.prototype.getClues = function(dir, solved=true, showEnums=true) {
  if (!this.puz) {
    return ''
  }
  let clues = ''
  for (let ci in this.puz.clues) {
    let clue = this.puz.clues[ci]
    if (clue.dir != dir) {
      continue
    }
    clues = clues + '\n  ' + (clue.displayLabel || clue.label) + ' ' + this.showClue(clue.clue, true, showEnums)
    if (clue.parentClueIndex) {
      continue
    }
    if (solved && clue.solution) {
      clues = clues + ' [' + clue.solution + ']'
    }
    if (solved && clue.anno) {
      clues = clues + ' ' + clue.anno
    }
  }
  return clues
}

Exet.prototype.getExolve = function(id='', skipClues=false,
                                    solved=true, showEnums=true) {
  maker = `
    Software: <a target="_blank" href="http://exet.app">Exet</a><br>
    Version: ${this.version}<br>
    Lexicon: ${exetLexicon.id}<br>
    Timestamp: ${(new Date()).toString()}<br>`
  return `  ${this.otherSections}
  exolve-id: ${(id ? id : this.puz.id)}` +
  (this.puz.title ? `
  exolve-title: ${this.puz.title}` : '') +
  (this.puz.setter ? `
  exolve-setter: ${this.puz.setter}` : '') +
  (this.puz.copyright ? `
  exolve-copyright: ${this.puz.copyright}` : '') + `
  exolve-maker: ${maker}
  exolve-grid: ${this.getGrid(solved)}` +
  (!skipClues ? `
  exolve-across: ${this.getClues('A', solved, showEnums)}
  exolve-down: ${this.getClues('D', solved, showEnums)}` : '') + `
  exolve-end
  `
}

Exet.prototype.getHTML = function(solved=true, showEnums=true) {
  return this.prefix + '\n' + this.getExolve('', false, solved, showEnums) +
         '\n' + this.suffix
}

Exet.prototype.makeLexKey = function(partialSol) {
  let key = ''
  if (!partialSol) return key;
  let lowerSol = partialSol.toLowerCase()
  for (let i = 0; i < partialSol.length; ++i) {
    let c = lowerSol.charAt(i);
    if ((c >= 'a' && c <= 'z') || c == '?') {
      key = key + c;
    }
  }
  return key;
}

Exet.prototype.generalizeKey = function(key) {
  for (let i = key.length - 1; i >= 0; --i) {
    if (key.charAt(i) != '?') {
      return key.substr(0, i) + '?' + key.substr(i + 1);
    }
  }
  return key;
}

Exet.prototype.keyMatchesPhrase = function(key, phrase) {
  let phraseKey = this.makeLexKey(phrase)
  if (phraseKey.length != key.length) {
    return false;
  }
  for (let i = 0; i < key.length; i++) {
    if (key.charAt(i) != '?' &&
        key.charAt(i) != phraseKey.charAt(i)) {
      return false;
    }
  }
  return true
}

Exet.prototype.isProperNoun = function(s) {
  let first = s.charAt(0)
  return first.toUpperCase() == first
}

Exet.prototype.getLexChoices = function(partialSol, limit=0, dontReuse={}) {
  let choices = []
  let key = this.makeLexKey(partialSol);
  if (!key) return choices
  // First look at preferred choices (these may have idx >= this.indexMinPop)
  let seen = {}
  if (this.preflexByLen[key.length]) {
    for (idx of this.preflexByLen[key.length]) {
      if (dontReuse[idx]) continue
      let phrase = exetLexicon.lexicon[idx]
      if (this.keyMatchesPhrase(key, phrase)) {
        choices.push(idx)
        seen[idx] = true
      }
    }
  }
  let gkey = key;
  while (!exetLexicon.index[gkey]) {
    let ngkey = this.generalizeKey(gkey)
    if (ngkey == gkey) return choices
    gkey = ngkey;
  }
  let indices = exetLexicon.index[gkey];
  for (let idx of indices) {
    if (idx >= this.indexMinPop) break
    if (dontReuse[idx]) continue
    if (this.unpreflex[idx]) continue
    let phrase = exetLexicon.lexicon[idx]
    if (this.noProperNouns && this.isProperNoun(phrase)) {
      continue
    }
    if (this.keyMatchesPhrase(key, phrase) && !seen[idx]) {
      choices.push(idx)
      if (limit > 0 && choices.length >= limit) break
    }
  }
  return choices;
}

Exet.prototype.makeAnagramKey = function(phrase) {
  return phrase.toLowerCase().replace(/ /g, '').split('').sort().join('')
}

Exet.prototype.javaHash = function(key) {
  let hash = 0;
  for (let i = 0; i < key.length; i++) {
    let c = key.charCodeAt(i);
    hash = ((hash << 5) - hash) + c;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

Exet.prototype.getAnagrams = function(phrase) {
  const key = this.makeAnagramKey(phrase);
  const NUM_SHARDS = exetLexicon.anagrams.length
  let shard = this.javaHash(key) % NUM_SHARDS
  if (shard < 0) shard += NUM_SHARDS
  let anagrams = []
  for (let idx of exetLexicon.anagrams[shard]) {
    let candidate = exetLexicon.lexicon[idx]
    if (this.makeAnagramKey(candidate) == key) {
      anagrams.push(candidate)
    }
  }
  return anagrams
}

Exet.prototype.cellsOfClue = function(theClue) {
  if (theClue.parentClueIndex) {
    return []
  } else if (!theClue.childrenClueIndices ||
             theClue.childrenClueIndices.length == 0) {
    return theClue.cells
  }
  let cells = []
  let linked = this.puz.getLinkedClues(theClue.index)
  for (let lci of linked) {
    cells = cells.concat(this.puz.clues[lci].cells)
  }
  return cells
}

Exet.prototype.IntersectChoices = function(set1, set2) {
  let result = {}
  for (let x in set2) {
    if (set1[x]) result[x] = true
  }
  return result
}

Exet.prototype.Set2Trims = function(set1, set2) {
  for (let x in set1) {
    if (!set2[x]) return true
  }
  return false
}

// A data structure encapsulating clues and a grid, along with available fill
// choices. Used for figuring out viability, weeding out non-viable choices,
// and doing autofill. Note that you can initialize this from exet.puz as well
// as from another ExetFillState.
function ExetFillState(obj) {
  this.gridWidth = obj.gridWidth
  this.gridHeight = obj.gridHeight
  this.grid = new Array(this.gridHeight)
  this.viable = obj.viable
  for (let i = 0; i < this.gridHeight; i++) {
    this.grid[i] = new Array(this.gridWidth)
    for (let j = 0; j < this.gridWidth; j++) {
      let gridCell = obj.grid[i][j]
      this.grid[i][j] = {}
      let thisCell = this.grid[i][j]
      thisCell.isLight = gridCell.isLight
      if (!thisCell.isLight) continue
      thisCell.solution = gridCell.solution
      thisCell.currLetter = gridCell.currLetter
      thisCell.cChoices = gridCell.cChoices || {}
      thisCell.viability = gridCell.viability
    }
  }
  this.clues = {}
  for (let ci in obj.clues) {
    let theClue = obj.clues[ci]
    this.clues[ci] = {}
    let thisClue = this.clues[ci]
    thisClue.solution = theClue.solution
    thisClue.parentClueIndex = theClue.parentClueIndex || null;
    thisClue.childrenClueIndices = theClue.childrenClueIndices || []
    thisClue.dir = theClue.dir
    thisClue.index = theClue.index
    thisClue.cells = theClue.cells
    thisClue.enumLen = theClue.enumLen
    thisClue.lChoices = theClue.lChoices || []
  }
}

Exet.prototype.refineLightChoices = function(fillState, limit=0) {
  fillState.preflexUsed = {}
  let dontReuse = {}
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) {
      continue;
    }
    if (theClue.solution.indexOf('?') >= 0) {
      continue
    }
    let key = this.makeLexKey(theClue.solution)
    let choices = this.getLexChoices(key, 1, dontReuse)
    if (choices.length > 0) {
      let p = choices[0]
      dontReuse[p] = true
      if (this.preflexSet[p]) fillState.preflexUsed[p] = true
    }
  }
  let changes = 0;
  for (let ci in fillState.clues) {
    let theClue = fillState.clues[ci]
    if (theClue.parentClueIndex ||
        !theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let cells = this.cellsOfClue(theClue);
    let toConsider = (limit <= 0) ? theClue.lChoices.length :
        Math.min(limit, theClue.lChoices.length)
    let choices = theClue.lChoices.slice(0, toConsider)
    let remChoices = theClue.lChoices.slice(toConsider)
    theClue.lChoices = []
    let cellChoiceSets = []
    for (let cell of cells) {
      cellChoiceSets.push({})
    }
    for (let lchoice of choices) {
      if (dontReuse[lchoice]) {
        changes++;
        continue
      }
      let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
      let viable = true
      for (let i = 0; i < key.length; i++) {
        let cell = cells[i]
        console.assert(cell && cell.length == 2, ci, i);
        let gridCell = fillState.grid[cell[0]][cell[1]]
        let letter = key.charAt(i).toUpperCase()
        if (gridCell.solution == '?' && !gridCell.cChoices[letter]) {
          viable = false
          break
        }
      }
      if (viable) {
        theClue.lChoices.push(lchoice)
        for (let i = 0; i < key.length; i++) {
          let letter = key.charAt(i).toUpperCase()
          cellChoiceSets[i][letter] = true
        }
      } else {
        changes++;
      }
    }
    let isForced = true
    for (let i = 0; i < cells.length; i++) {
      let cell = cells[i]
      let gridCell = fillState.grid[cell[0]][cell[1]]
      if (gridCell.solution != '?') {
        continue
      }
      gridCell.cChoices = this.IntersectChoices(
          gridCell.cChoices, cellChoiceSets[i])
      let choices = Object.keys(gridCell.cChoices)
      if (choices.length > 1) {
        isForced = false
      }
    }
    if (isForced && theClue.lChoices.length == 1) {
      let p = theClue.lChoices[0]
      dontReuse[p] = true
      if (this.preflexSet[p]) fillState.preflexUsed[p] = true
    }
    if (!isForced && remChoices.length > 0) {
      theClue.lChoices = theClue.lChoices.concat(remChoices)
    }
  }
  fillState.numPreflexUsed = Object.keys(fillState.preflexUsed).length
  for (let i = 0; i < fillState.gridHeight; i++) {
    for (let j = 0; j < fillState.gridWidth; j++) {
      let gridCell = fillState.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let choices = Object.keys(gridCell.cChoices)
      if (choices.length == 0) {
        fillState.viable = false
      }
      gridCell.viability = this.viability(choices.length)
    }
  }
  return changes
}

Exet.prototype.findDeadendsByCell = function(fillState) {
  return this.refineLightChoices(fillState, this.sweepMaxChoices)
}

Exet.prototype.updateViablots = function() {
  let fillState = this.fillState
  let dead = 0
  for (let i = 0; i < fillState.gridHeight; i++) {
    for (let j = 0; j < fillState.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let fillStateCell = fillState.grid[i][j]
      let choices = Object.keys(fillStateCell.cChoices)
      let viablot = gridCell.viablot
      let opacity = dead > 3 ? 0.1 : (dead == 0 ? 0.6 : 0.3)
      viablot.style.fill = (fillStateCell.viability >= 5) ?
        'transparent' :
        (fillStateCell.viability == 0 ? `rgba(255,0,255,${opacity})` :
          `rgba(255,0,0,${opacity})`)
      viablot.setAttributeNS(
          null, 'r', this.puz.circleR * 0.1 * (5 - fillStateCell.viability));
      if (fillStateCell.viability == 0) {
        dead++
      }
      if (choices.length == 1) {
        if (!gridCell.forcedLetter) {
          let cellText =
            document.createElementNS('http://www.w3.org/2000/svg', 'text');
          cellText.setAttributeNS(
            null, 'x', this.puz.cellLeftPos(j, this.puz.lightStartX));
          cellText.setAttributeNS(
            null, 'y', this.puz.cellTopPos(i, this.puz.lightStartY));
          cellText.setAttributeNS(null, 'text-anchor', 'middle');
          cellText.setAttributeNS(null, 'editable', 'simple');
          let cellClass = 'xlv-cell-text'
          cellText.style.fill = 'gray'
          cellText.style.fontSize = this.puz.letterSize + 'px'
          cellText.setAttributeNS(null, 'class', cellClass)
          cellText.addEventListener(
              'click', this.puz.cellActivator.bind(this.puz, i, j));

          const text = document.createTextNode(choices[0]);
          cellText.appendChild(text);
          this.puz.svg.appendChild(cellText)
          gridCell.forcedLetter = text
        }
        gridCell.forcedLetter.nodeValue = choices[0]
        viablot.style.fill = 'transparent'
      } else {
        if (gridCell.forcedLetter) {
          gridCell.forcedLetter.nodeValue = ''
        }
      }
    }
  }
  if (!fillState.viable) {
    if (this.viabilityUpdateTimer) {
      clearTimeout(this.viabilityUpdateTimer);
    }
    this.viabilityUpdateTimer = null;
    this.updateSweepInd()
  }
}

Exet.prototype.acceptAll = function() {
  if (this.autofill.running) {
    alert('Wait while autofill is running, as partial solutions may ' +
          'turn out to be non-viable')
    return false
  }
  let changed = false;
  // First do it by clue, to get hyphens/word-breaks.
  for (let ci in this.fillState.clues) {
    let theClue = this.fillState.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let choices = theClue.lChoices
    if (choices.length != 1) {
      continue
    }
    this.fillLight(choices[0], ci, exetRevManager.REV_AUTOFILL_GRIDFILL_CHANGE)
    changed = true
  }
  for (let i = 0; i < this.fillState.gridHeight; i++) {
    for (let j = 0; j < this.fillState.gridWidth; j++) {
      let gridCell = this.fillState.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let choices = Object.keys(gridCell.cChoices)
      if (choices.length == 1) {
        this.puz.grid[i][j].currLetter = choices[0]
        changed = true
      }
    }
  }
  return changed
}

// Finds a clue that becomes non-viable when it previously was viable.
// Return true if such a clue can be found.
Exet.prototype.someClueTurnsNonViable = function(tempFillState) {
  let changes = 1
  let tempClues = {}
  for (let ci in tempFillState.clues) {
    tempClues[ci] = {}
    let theClue = tempFillState.clues[ci]
    if (theClue.lChoices) {
      tempClues[ci].lChoices = theClue.lChoices.slice()
    }
  }
  let count = 0
  while (changes > 0 && count < 1) {
    count++
    changes = 0
    for (let ci in tempFillState.clues) {
      let theClue = tempFillState.clues[ci]
      if (theClue.parentClueIndex ||
          !theClue.solution || theClue.solution.indexOf('?') < 0) {
        continue
      }
      let cells = this.cellsOfClue(theClue);
      let cellChoiceSets = []
      for (let cell of cells) {
        cellChoiceSets.push({})
      }
      let tempClue = tempClues[ci]
      let limit = Math.min(this.shownLightChoices, tempClue.lChoices.length)
      for (let i = 0; i < limit; i++) {
        let lchoice = tempClue.lChoices[i]
        let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
        console.assert(key.length = cells.length, key.length, cells.length)
        for (let k = 0; k < key.length; k++) {
          let letter = key.charAt(k).toUpperCase()
          cellChoiceSets[k][letter] = true
        }
      }
      for (let i = 0; i < cells.length; i++) {
        let cell = cells[i]
        let gridCell = tempFillState.grid[cell[0]][cell[1]]
        if (gridCell.solution != '?') {
          continue
        }
        gridCell.cChoices = this.IntersectChoices(
            gridCell.cChoices, cellChoiceSets[i])
      }
    }
    for (let ci in tempFillState.clues) {
      let theClue = tempFillState.clues[ci]
      if (theClue.parentClueIndex ||
          !theClue.solution || theClue.solution.indexOf('?') < 0) {
        continue
      }
      let cells = this.cellsOfClue(theClue)
      let tempClue = tempClues[ci]
      if (tempClue.lChoices.length > this.sweepMaxChoicesSmall) {
        continue
      }
      let choices = tempClue.lChoices.slice()
      tempClue.lChoices = []
      for (let i = 0; i < choices.length; i++) {
        let lchoice = choices[i]
        let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
        let viable = true
        for (let j = 0; j < key.length; j++) {
          let cell = cells[j]
          let gridCell = tempFillState.grid[cell[0]][cell[1]]
          if (gridCell.solution != '?') {
            continue
          }
          let letter = key.charAt(j).toUpperCase()
          if (!gridCell.cChoices[letter]) {
            viable = false
            break
          }
        }
        if (viable) {
          tempClue.lChoices.push(lchoice)
        } else {
          changes++;
        }
      }
      if (choices.length > 0 && tempClue.lChoices.length == 0) {
        return true
      }
    }
  }
  return false
}

// Returns true if should be called again
Exet.prototype.findDeadendsByClue = function() {
  let ci = this.deadendClueCheck
  if (!ci) {
    return false
  }
  let theClue = this.fillState.clues[ci]
  if (!theClue) {
    return false
  }
  if (theClue.parentClueIndex ||
      !theClue.solution || theClue.solution.indexOf('?') < 0) {
    return false
  }
  let cells = this.cellsOfClue(theClue)
  if (this.deadendClueLightCheck >= theClue.lChoices.length ||
      cells.length == 0) {
    return false
  }
  if (this.deadendClueLightCheck >= this.shownLightChoices) {
    return false
  }
  const CHOICES_TO_CHECK = 3
  let prefix = theClue.lChoices.slice(0, this.deadendClueLightCheck)
  let choices = theClue.lChoices.slice(
      this.deadendClueLightCheck, this.deadendClueLightCheck + CHOICES_TO_CHECK)
  let viableChoices = []
  let suffix = theClue.lChoices.slice(
      this.deadendClueLightCheck + CHOICES_TO_CHECK)
  let oldLen = theClue.lChoices.length
  for (let lchoice of choices) {
    let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
    console.assert(key.length = cells.length, key.length, cells.length)
    let tempFillState = new ExetFillState(this.fillState)
    for (let i = 0; i < cells.length; i++) {
      let cell = cells[i]
      let tempGridCell = tempFillState.grid[cell[0]][cell[1]]
      tempGridCell.cChoices = {}
      let letter = key.charAt(i).toUpperCase()
      tempGridCell.cChoices[letter] = true
    }
    if (!this.someClueTurnsNonViable(tempFillState)) {
      viableChoices.push(lchoice)
    }
  }
  theClue.lChoices = prefix.concat(viableChoices, suffix)
  this.deadendClueCheckChanges += (oldLen - theClue.lChoices.length)
  this.deadendClueLightCheck +=  viableChoices.length
  return this.deadendClueLightCheck < theClue.lChoices.length
}

Exet.prototype.startDeadendSweep = function(ci='') {
  if (this.viabilityUpdateTimer) {
    clearTimeout(this.viabilityUpdateTimer);
  }
  this.viabilityUpdateTimer = null;
  if (!this.puz || this.puz.numCellsFilled >= this.puz.numCellsToFill) {
    return
  }
  if (this.autofill.running) {
    return
  }
  this.deadendsGridSweep = true
  this.sweepIndicator.className = 'xet-sweeping-animated'
  this.viabilityUpdateTimer = setTimeout(() => {
    this.findAllDeadendFills(ci)
  }, this.sweepMS);
}

Exet.prototype.getClueToCheckDeadends = function(ci) {
  if (ci) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) {
      ci = theClue.parentClueIndex
      theClue = this.puz.clues[ci]
    }
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      return ''
    }
    return ci
  }
  // Find most constrained unsolved and still-viable clue
  let res = ''
  let resChoices = exetLexicon.lexicon.length
  for (ci in this.fillState.clues) {
    let theClue = this.fillState.clues[ci]
    if (theClue.parentClueIndex) continue
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) continue
    if (theClue.lChoices.length > 0 && theClue.lChoices.length < resChoices) {
      resChoices = theClue.lChoices.length
      res = ci
    }
  }
  return res
}

Exet.prototype.updateSweepInd = function() {
  this.sweepIndicator.className =
      (this.viabilityUpdateTimer || this.autofill.running) ?
      'xet-sweeping-animated' : 'xet-sweeping';
}

Exet.prototype.findAllDeadendFills = function(ci) {
  if (this.viabilityUpdateTimer) {
    clearTimeout(this.viabilityUpdateTimer);
  }
  this.viabilityUpdateTimer = null;
  if (this.deadendsGridSweep) {
    let changes = this.findDeadendsByCell(this.fillState)
    this.updateViablots()
    if (changes > 0 && this.fillState.viable) {
      this.updateFillChoices()
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills(ci)
      }, this.sweepMS);
    } else {
      // Start the clue-sweep
      this.deadendsGridSweep = false
      this.deadendClueLightCheck = 0;
      this.deadendClueCheckChanges = 0;
      this.deadendClueCheck = this.getClueToCheckDeadends(ci);
      if (!this.deadendClueCheck) {
        this.updateSweepInd()
        return
      }
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills()
      }, this.sweepMS);
    }
  } else {
    let doMore = this.findDeadendsByClue()
    if (this.deadendClueCheckChanges > 0) {
      this.updateFillChoices()
    }
    if (!doMore) {
      this.deadendsGridSweep = true
      if (this.deadendClueCheckChanges > 0) {
        // Repeat the grid-sweep
        this.viabilityUpdateTimer = setTimeout(() => {
          this.findAllDeadendFills()
        }, this.sweepMS);
      } else {
        this.updateSweepInd()
      }
    } else {
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills()
      }, this.sweepMS);
    }
  }
}

Exet.prototype.viability = function(len) {
  const log2 = 0.6931471805599453;
  return len == 0 ? 0 : (len >= 16 ? 5 : (1 + (Math.log(len) / log2)));
}

Exet.prototype.initViability = function() {
  for (let i = 0; i < this.fillState.gridHeight; i++) {
    for (let j = 0; j < this.fillState.gridWidth; j++) {
      let gridCell = this.fillState.grid[i][j]
      if (!gridCell.isLight) {
        continue
      }
      if (gridCell.solution != '?') {
        gridCell.cChoices = {}
        gridCell.cChoices[gridCell.solution] = true
        gridCell.viability = 1.0;
      } else {
        gridCell.cChoices = this.allLetters
        gridCell.viability = 5.0;
      }
    }
  }
  this.fillState.viable = true
}

Exet.prototype.resetViability = function() {
  this.resetAutofill('Aborted')
  this.initViability()
  let numPreflexUsed = 0
  let dontReuse = {}
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') >= 0) {
      continue
    }
    let key = this.makeLexKey(theClue.solution)
    let choices = this.getLexChoices(key, 1, dontReuse)
    this.fillState.clues[ci].lChoices = choices
    if (choices.length > 0) {
      let p = choices[0]
      dontReuse[p] = true
      if (this.preflexSet[p]) numPreflexUsed++
    }
  }
  if (this.preflexUsed) {
    this.preflexUsed.innerText = numPreflexUsed
  }
  for (let ci in this.fillState.clues) {
    let theClue = this.fillState.clues[ci]
    let key = this.makeLexKey(theClue.solution)
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    theClue.lChoices = this.getLexChoices(key, 0, dontReuse)
  }
  this.updateFillChoices()
  this.updateViablots()
  this.startDeadendSweep()
}

Exet.prototype.fillLight = function(idx, ci='', revType=null) {
  let updateIfChanged = false
  if (!ci && this.puz) {
    ci = this.currClueIndex()
    updateIfChanged = true
  }
  if (!ci) {
    return
  }
  let solution = exetLexicon.lexicon[idx]
  let theClue = this.puz.clues[ci]
  let cells = this.cellsOfClue(theClue);
  if (!theClue || !solution ||
      theClue.parentClueIndex ||
      this.makeLexKey(solution).length != cells.length) {
    return
  }
  solution = solution.toUpperCase()
  let changed = false;
  if (theClue.solution != solution) {
    theClue.solution = solution
    changed = true
  }
  let enumStr = ''
  let enumPart = 0
  let solIndex = 0
  for (let i = 0; i < solution.length; i++) {
    let c = solution.charAt(i);
    if (enumPart > 0 && (c == ' ' || c == '-' || c == '\'')) {
      enumStr = enumStr + enumPart + (c == ' ' ? ',' : c)
      enumPart = 0
    }
    if (c >= 'A' && c <= 'Z') {
      enumPart++
      let cell = cells[solIndex++]
      let gridCell = this.puz.grid[cell[0]][cell[1]]
      if (gridCell.currLetter != c || gridCell.solution != c) {
        gridCell.currLetter = c
        changed = true
      }
    }
  }
  if (enumPart > 0) {
    enumStr = enumStr + enumPart
  }
  let clueEnumStart = theClue.clue.lastIndexOf('(')
  let clueEnumEnd = theClue.clue.lastIndexOf(')')
  if (clueEnumStart > 0 && clueEnumEnd > clueEnumStart + 1) {
    let clueEnum = theClue.clue.substring(clueEnumStart + 1, clueEnumEnd)
    if (clueEnum != enumStr) {
      theClue.clue = theClue.clue.substr(0, clueEnumStart).trim() +
        ' (' + enumStr + ')'
      changed = true
    }
  } else {
    theClue.clue = theClue.clue.trim() + ' (' + enumStr + ')'
    changed = true
  }
  if (changed && updateIfChanged) {
    this.handleGridInput(revType)
  }
}

Exet.prototype.setPreflex = function(preflex) {
  this.preflex = preflex
  this.preflexSet = {}
  if (this.preflexSize) {
    this.preflexSize.innerText = preflex.length
  }
  while (exetLexicon.lexicon.length > exetLexicon.startLen) {
    exetLexicon.lexicon.pop()
  }
  this.preflexByLen = {}
  for (let p of this.preflex) {
    let len = this.makeLexKey(p).length
    let inLexicon = this.getLexChoices(p, 1)
    if (inLexicon.length > 0) {
      p = inLexicon[0]
    } else  {
      exetLexicon.lexicon.push(p)
      p = exetLexicon.lexicon.length - 1
    }
    if (!this.preflexByLen[len]) this.preflexByLen[len] = []
    this.preflexByLen[len].push(p)
    this.preflexSet[p] = true
  }
}

Exet.prototype.throttledUpdatePreflex = function() {
  if (this.throttledPreflexTimer) {
    clearTimeout(this.throttledPreflexTimer);
  }
  this.throttledPreflexTimer = setTimeout(() => {
    this.updatePreflex()
    this.throttledPreflexTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.updatePreflex = function() {
  let preflexes = this.preflexInput.value.trim().split('\n')
  let cleaned = ''
  preflex = []
  let seen = {}
  for (let p of preflexes) {
    p = p.trim().replace(/[^a-zA-Z' -]/g, '').replace(/[ ][ ]*/g, ' ')
    if (!p) continue
    let hash = this.javaHash(p.toLowerCase())
    if (seen[hash]) continue
    seen[hash] = true

    if (cleaned) cleaned = cleaned + '\n'
    cleaned = cleaned + p
    preflex.push(p)
    if (preflex.length >= 100) break
  }
  if (cleaned != this.preflexInput.value.trim()) {
    let cursor = this.preflexInput.selectionStart
    this.preflexInput.value = cleaned
    this.preflexInput.selectionEnd = cursor
  }
  if (JSON.stringify(preflex) == JSON.stringify(this.preflex)) {
    return
  }
  if (this.autofill && this.autofill.preflexTotalSpan) {
    this.autofill.preflexTotalSpan.innerText = preflex.length
  }
  this.setPreflex(preflex)
  this.resetViability()
  exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
}

Exet.prototype.throttledUpdateUnpreflex = function() {
  if (this.throttledUnpreflexTimer) {
    clearTimeout(this.throttledUnpreflexTimer);
  }
  this.throttledUnpreflexTimer = setTimeout(() => {
    this.updateUnpreflex()
    this.throttledUnpreflexTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.renderUnpreflex = function() {
  let unpreflexText = ''
  for (let p in this.unpreflex) {
    if (unpreflexText) unpreflexText += '\n'
    unpreflexText += exetLexicon.lexicon[p]
  }
  if (this.unpreflexInput.value != unpreflexText) {
    let cursor = this.unpreflexInput.selectionStart
    this.unpreflexInput.value = unpreflexText
    this.unpreflexInput.selectionEnd = cursor
  }
  this.unpreflexSize.innerText = Object.keys(this.unpreflex).length
}

Exet.prototype.updateUnpreflex = function() {
  let unpreflexes = this.unpreflexInput.value.trim().split('\n')
  let saved = this.unpreflex
  this.unpreflex = {}
  for (let p of unpreflexes) {
    p = p.trim().replace(/[^a-zA-Z' -]/g, '').replace(/[ ][ ]*/g, ' ')
    if (!p) continue

    let len = this.makeLexKey(p).length
    let inLexicon = this.getLexChoices(p, 1)
    if (inLexicon.length != 1) {
      continue
    }
    if (this.unpreflex[p]) {
      continue
    }
    p = inLexicon[0]
    this.unpreflex[p] = true
  }
  this.unpreflexSize.innerText = Object.keys(this.unpreflex).length
  if (JSON.stringify(this.unpreflex) == JSON.stringify(saved)) {
    return
  }
  this.resetViability()
  exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
}

Exet.prototype.updateFillChoices = function() {
  let ci = this.currClueIndex();
  if (!ci) {
    return
  }
  let gridClue = this.puz.clues[ci]
  let theClue = this.fillState.clues[ci]
  console.assert(theClue && theClue.lChoices, ci)

  let html = ''
  if (theClue.lChoices.length == 0) {
    // Maybe the light was filled from outside the lexicon
    if (gridClue.solution.indexOf('?') < 0) {
      html = `<tr><td>${gridClue.solution}</td></tr>`
    }
  }

  if (!html) {
    let numShown = 0
    for (let choice of theClue.lChoices) {
      html = html + `
        <tr><td>${exetLexicon.lexicon[choice]}</td></tr>
      `
      numShown++
      if (numShown >= this.shownLightChoices) break;
    }
  }
  let htmlHash = this.javaHash(html + ci)
  if (this.shownChoicesHash && this.shownChoicesHash == htmlHash) {
    return
  }
  this.shownChoicesHash = htmlHash
  this.lChoices.innerHTML = html
  let trs = this.lChoices.getElementsByTagName('tr')
  let lim = Math.min(theClue.lChoices.length, trs.length)
  for (let i = 0; i < lim; i++) {
    trs[i].addEventListener(
    'click', this.fillLight.bind(this, theClue.lChoices[i], '',
                                 exetRevManager.REV_GRIDFILL_CHANGE))
  }
}

Exet.prototype.warnVersion = function(ver) {
  let about = document.getElementById("xet-about")
  about.style.color = "red"
  about.title = 'Please reload to update to ' + ver
  let warnMsg = document.getElementById("xet-outdated-message")
  warnMsg.innerHTML = 'Please <a href=' +
    '"javascript:window.location.reload(true)">reload</a> to update to ' + ver
  warnMsg.style.display = ''
  let warnIcon = document.getElementById("xet-outdated")
  warnIcon.style.display = ''
}

Exet.prototype.checkVersion = function() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4) {
      let now = (new Date()).toLocaleString()
      if (this.status < 200 || this.status > 299) {
        console.log(now + ": Version check request failed")
        return
      }
      let ver = this.responseText.trim()
      if (!exet.versionText) {
        exet.versionText = ver
        console.log(now + ": Initialized Exet version to " + ver)
      } else if (ver != exet.versionText) {
        exet.warnVersion(ver)
        console.log(now + ": Exet version: " + exet.versionText +
                    " needs update to: " + ver)
      } else {
        console.log(now + ": Exet version verified to be current: " + ver)
      }
    }
  };
  xhttp.open("GET", "exet-version.txt", true);
  xhttp.send();
}

Exet.prototype.initVersionChecking = function() {
  this.versionText = ''
  if (window.location.protocol == "file:") {
    return
  }
  // Check every 10 minutes
  setInterval(this.checkVersion.bind(this), 10 * 60 * 1000)
}

function exetFromHistory(exetRev) {
  exet.prefix = exetRev.prefix
  exet.suffix = exetRev.suffix
  let preflex = exetRev.preflex || []
  exet.setPreflex(preflex)
  exet.unpreflex = exetRev.unpreflex || {}
  exet.setMinPop(exetRev.minpop || 0)
  exet.noProperNouns = exetRev.noProperNouns || false
  exet.makeExolve(exetRev.exolve)
  if (exetRev.navState) {
    exet.startNav(exetRev.navState[0],
                  exetRev.navState[1], exetRev.navState[2])
  } else {
    exet.startNav()
  }
  if (exetRev.scratchPad && exet.puz && exet.puz.scratchPad) {
    exet.puz.scratchPad.value = exetRev.scratchPad
  }
  if (exet.puz && exet.puz.id && exetRev.revNum < exetRev.maxRevNum) {
    exetRevManager.throttledSaveRev(exetRevManager.REV_JUMPED_TO_REV,
                                    '' + exetRev.revNum);
  }
}

function exetBlank(w=15, h=15, id='', automagic=false, chequered=true,
                   topUnches=false, leftUnches=false) {
  if (!w || !h || w <= 0 || h <= 0 || w > 100 || h > 100) {
    alert('Width and height must be specified in the range, 1-100')
    return
  }
  if (!id) {
    id = `puz-${Math.random().toString(36).substring(2, 8)}`
  }

  let gridRow = ['', '']
  for (let j = 0; j < w; j++) {
    if (chequered) {
      if (!topUnches && !leftUnches) {
        gridRow[0] = gridRow[0] + '?'
        gridRow[1] = gridRow[1] + (j % 2 == 0 ? '?' : '.')
      } else if (!topUnches && leftUnches) {
        gridRow[0] = gridRow[0] + '?'
        gridRow[1] = gridRow[1] + (j % 2 == 0 ? '.' : '?')
      } else if (topUnches && !leftUnches) {
        gridRow[0] = gridRow[0] + (j % 2 == 0 ? '?' : '.')
        gridRow[1] = gridRow[1] + '?'
      } else if (topUnches && leftUnches) {
        gridRow[0] = gridRow[0] + (j % 2 == 0 ? '.' : '?')
        gridRow[1] = gridRow[1] + '?'
      }
    } else {
      gridRow[0] = gridRow[0] + '?'
      gridRow[1] = gridRow[1] + '?'
    }
  }
  let grid = ''
  for (let i = 0; i < h; i++) {
    grid = grid + '\n  ' + gridRow[i % 2]
  }

  let specs = `exolve-begin
    exolve-id: ${id}
    exolve-title: Crossword
    exolve-setter: Exetter
    exolve-width: ${w}
    exolve-height: ${h}
    exolve-grid: ${grid}
    exolve-across:
    exolve-down:
  exolve-end
  `
  exet.prefix = ''
  exet.suffix = ''
  exet.setPreflex([])
  exet.unpreflex = {}
  exet.setMinPop(exet.DEFAULT_MINPOP)
  exet.noProperNouns = false
  exet.makeExolve(specs)
  exet.startNav()
  if (!exet.puz || !exet.puz.id) {
    alert('Failed to create/load crossword, unfortunately. Perhaps the ' +
          'JavaScript console may have logged some error messages.')
    return
  }

  if (automagic && exet.automagicBlocks(false)) {
    exet.updatePuzzle(exetRevManager.REV_CREATED_AUTOBLOCK)
    return
  }
  exetRevManager.throttledSaveRev(exetRevManager.REV_CREATED_BLANK)
}

function exetLoadFile() {
  let fr = new FileReader(); 
  fr.onload = function(){ 
    let start = fr.result.indexOf('exolve-begin')
    let end = fr.result.indexOf('exolve-end')
    if (start < 0 || end < 0 || start >= end) {
      alert('Invalid Exolve specifications')
      return
    }
    end += 'exolve-end'.length
    exet.prefix = fr.result.substring(0, start).trim()
    exet.suffix = fr.result.substring(end).trim()
    exet.otherSections = ''
    let specs = fr.result.substring(start, end)
    exet.setPreflex([])
    exet.unpreflex = {}
    exet.setMinPop(exet.DEFAULT_MINPOP)
    exet.noProperNouns = false
    exet.makeExolve(specs)
    exet.startNav()
    if (exet.puz && exet.puz.id) {
      // See if this has a preflex/unpreflex, recover if so.
      let stored = window.localStorage.getItem(exet.puz.id)
      if (stored) {
        stored = JSON.parse(stored)
        if (stored.revs.length > 0) {
          let lastRev = stored.revs[stored.revs.length - 1]
          if (lastRev.preflex) {
            exet.setPreflex(lastRev.preflex)
          }
          if (lastRev.unpreflex) {
            exet.unreflex = lastRev.unpreflex
          }
          exet.setMinPop(lastRev.minpop || 0)
          exet.noProperNouns = lastRev.noProperNouns || false
        }
      }
      exetRevManager.throttledSaveRev(
          exetRevManager.REV_LOADED_FROM_FILE,
          exet.exolveFile);
    }
  } 
  let f = document.getElementById('xet-file').files[0]
  exet.exolveFile = f.name
  fr.readAsText(f)
}

let exetRevManager = new ExetRevManager();
let exetModals = new ExetModals();
if (!window.localStorage) {
  throw "localStorage is not available!"
}
if (!exetLexicon) {
  throw "No lexicon has been loaded!"
}
exetLexicon.startLen = exetLexicon.lexicon.length

let exet = new Exet;

let exetState = window.localStorage.getItem(exetRevManager.SPECIAL_KEY)
if (exetState) {
  exetState = JSON.parse(exetState)
} else {
  exetState = {};
}
if (!exetState.hasOwnProperty('showEnums')) {
  exetState.showEnums = true;
}
if (!exetState.hasOwnProperty('exolveUrl')) {
  exetState.exolveUrl = 'https://viresh-ratnakar.github.io/'
}
if (exetState.lastId) {
  let saved = window.localStorage.getItem(exetState.lastId)
  if (saved) {
    saved = JSON.parse(saved)
    if (saved.revs.length > 0) {
      exetFromHistory(saved.revs[saved.revs.length - 1])
    }
  }
}
if (!exet.puz) {
  let url = new URL(location.href)
  let newgrid = url.searchParams.get('newgrid')
  if (newgrid == 'blank') {
    exetBlank(15, 15, '', false, false)
  } else {
    exetBlank(15, 15, '', true, true)
  }
}
exet.initVersionChecking()

</script>

</body>
</html>
