<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!--
MIT License

Copyright (c) 2020 Viresh Ratnakar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

The latest code and documentation for Exet can be found at:
https://github.com/viresh-ratnakar/exet

Current version: v0.22 October 23, 2020
-->

<link rel="stylesheet" type="text/css" href="exolve-m.css?v0.96"/>
<script src="exolve-m.js?v0.96"></script>
<script src="lufz-en-lexicon.js"></script>

<style>
[contenteditable="true"]:active,
[contenteditable="true"]:focus{
  border:none;
  outline:none;
}
.xet-frame {
  width: 940px;
  margin: 0 8px;
  box-sizing: border-box;
  font-family: monospace;
  font-size: 14px;
}
.xet-controls-col {
  padding: 4px;
}
.xet-frame hr {
  margin-left: 0;
  margin-right: 0;
}
.xet-tab {
  height: 50px;
  border: 4px solid #ddd;
  border-bottom: 0;
  background-color: #ddd;
  border-radius: 10px 10px 0 0;
  overflow: auto;
}
.xet-tab button {
  font-size: 14px;
  width: 105px;
  height: 100%;
  background-color: inherit;
  float: left;
  outline: none;
  cursor: pointer;
  padding: 2px 4px;
  transition: 0.3s;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  border: 1px solid silver;
}
.xet-tab button:hover {
  background-color: #f0f0f0;
  border-bottom: 0;
  cursor: pointer;
}
.xet-tab button.active {
  background-color: white;
  border-bottom: 0;
}
.xet-tabcontent {
  display: none;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
}
.xet-td {
  vertical-align: top;
}
.xet-iframe {
  width: 910px;
  border: 0;
  overflow: auto;
}
.xet-panel {
  width: 910px;
  border: 0;
  overflow: auto;
}
.xet-section {
  border: 0;
}
.xet-high-tall-box {
  height: 450px;
}
.xet-mid-tall-box {
  height: 325px;
}
.xet-low-tall-box {
  height: 240px;
}
.xet-anno {
  font-family: monospace;
  font-size: 14px;
  color: darkgreen;
}
.xlv-curr-clue {
  font-family: monospace;
  font-weight: normal;
  font-size: 14px;
  padding: 2px 2px 4px 2px;
}
.xet-red {
  color: red;
}
.xet-blue {
  color: blue;
  text-decoration: none;
}
.xet-small {
  font-family: monospace;
  font-size: 10px;
}
.xet-bold {
  font-weight: bold;
}
.xet-controls-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: left;
}
.xet-controls-col {
  display: flex;
  flex-flow: column wrap;
  align-items: flex-start;
}
.xet-choices-box {  
  overflow-y: auto;
  overflow-x: hidden;
  margin: 4px 0;
  border: 1px solid gray;
  border-collapse: collapse;
  box-sizing: border-box;
}
#xet-light-choices-box {  
  width: 30ch;
  height: 340px;
}
#xet-light-choices {  
  font-size: 16px;
}
.xet-choices {  
  table-layout: auto;
  margin: 0;
  padding: 0;
  width: 100%;
  color: #333;
  border: 1px solid gray;
  border-collapse: collapse;
  border-spacing: 0; 
  font-family: monospace;
  font-size: 12px;
}
.xet-choices td, .xet-choices th {
  border: 0;
  border-right: 1px solid gray;
  border-left: 1px solid gray;
  padding: 8px;
}
.xet-choices th {  
  background: #DFDFDF;
  font-weight: bold;
}
.xet-choices td {  
  background: #FAFAFA;
  text-align: left;
  cursor: pointer;
}
.xet-choices tr:nth-child(even) td { background: #F1F1F1; }   
.xet-choices tr:nth-child(odd) td { background: #FEFEFE; }  
.xet-choices:not(.xet-picked) tr:hover td {
  background: lightgreen;
}  
.xet-menu {
  position: relative;
  width:100%;
}
.xet-menu ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
.xet-menu li {
  float: left;
}
.xet-metadata {
  text-align: center;
  padding: 8px 12px;
  width: 500px;
}
.xet-edit {
  color: darkgreen;
  cursor: auto;
}
.xet-dropbtn {
  display: inline-block;
  text-align: center;
  padding: 8px 12px;
  margin: 0;
  font-size: 14px;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  border: 1px solid transparent;
}
.xet-dropdown:hover .xet-dropbtn {
  background-color: #ddd;
  cursor: pointer;
  border: 1px solid gray;
}
.xet-menu li.xet-dropdown {
  display: inline-block;
}
.xet-dropdown-content,
.xet-dropdown-submenu {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 275px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
  margin: 0;
  border: 1px solid gray;
}
.xet-dropdown-submenu {
  top: 0;
  left: 100%;
}
.xet-dropdown-item,
.xet-dropdown-subitem {
  margin: 0;
  padding: 15px;
  display: block;
  text-align: left;
  position: relative;
}
.xet-dropdown-content .xet-dropdown-item:nth-child(odd) { background: #F1F1F1; }   
.xet-dropdown-content .xet-dropdown-item:nth-child(even) { background: #FEFEFE; }  
.xet-dropdown-content .xet-dropdown-item:hover {
  background-color: lightgreen;
  cursor: pointer;
}
.xet-dropdown-submenu .xet-dropdown-subitem:nth-child(odd) { background: #F1F1F1; }   
.xet-dropdown-submenu .xet-dropdown-subitem:nth-child(even) { background: #FEFEFE; }  
.xet-dropdown-submenu .xet-dropdown-subitem:hover {
  background-color: #a1ffa1;
  cursor: pointer;
}
.xet-dropdown-item:hover .xet-dropdown-submenu {
  display: block;
}
.xet-frame .xlv-clues {
  font-size: 16px;
  font-family: serif;
  font-weight: 400;
  line-height: normal;
  box-sizing: border-box;
}
.xlv-frame .xlv-clues td:not(:first-child) {
  padding: 4px 0 0 0;
}
.xet-frame .xlv-clues,
.xet-frame .xlv-clues-box {
  width: 634px;
}
.xet-clues {
  width: 640px;
}
.xet-rev-chooser {
  position: absolute;
  z-index: 1;
  background-color: white;
  border: 1px solid gray;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  font-size: 12px;
}
.xet-chosen {
  font-weight: bold;
  color: darkgreen;
}
.xet-editable {
  border: 1px solid lightgreen;
  padding: 4px;
  line-height: 1.8;
}
.xet-action {
  color: dodgerblue;
  font-weight: normal;
  font-family: serif;
  font-size: 16px;
  font-style: italic;
  margin: 4px 0;
}
#xet-scratch-pad {
  margin: 0 6px 6px;
}
.xet-icon {
  padding: 0;
  height: 25px;
  width: 25px;
}
.xet-companag {
  padding: 0 0 8px 0;
  overflow: auto;
}
.xet-companag-text {
  color: blue;
  font-family: monospace;
  font-size: 14px;
}
.xet-table-midline td:nth-child(2) {
  border-left: 1px solid gray;
  padding-left: 4px;
}
.xet-table-midline td {
  padding-top: 4px;
}
.xet-preview {
  height: 300px;
  width:800px;
  overflow:auto;
}
.xet-full-width {
  width: 100%;
}
#xet-charade-choices td {
  padding: 3px 0;
}
.xet-sweeping-box {
  display: inline-block;
  position: absolute;
  height: 31px;
  width: 31px;
  right: 0;
  bottom: -22px;
}
@keyframes xet-sweeping {
  from {width: 0; height: 0; border-radius: 0; left: 15.5px; top: 15.5px; background: red;}
  to {width: 10px; height: 10px; border-radius: 5px; left: 10.5px; top: 10.5px; background: red;}
}
.xet-sweeping,
.xet-sweeping-animated {
  position: absolute;
}
.xet-sweeping {
  left: 15.5px;
  top: 15.5px;
  width: 0;
  height: 0;
  border-radius: 0;
}
.xet-sweeping-animated {
  animation-name: xet-sweeping;
  animation-duration: 2s;
  animation-direction: alternate;
  animation-iteration-count: infinite;
}
.xet-preflex-editor {
  position: absolute;
  left: 0;
  top: 0;
  padding: 8px;
  z-index: 1;
  background-color: white;
  border: 1px solid gray;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  font-size: 12px;
}
.xet-autofill-panel {
  padding: 4px;
  min-width: 400px;
}
.xet-autofill-panel .xlv-button {
  margin: 2px 6px 4px;
}
#xet-outdated-message,
#xet-outdated {
  color: red;
  font-weight: bold;
}
#xet-minpop {
  text-align: right;
}
.xet-pink-button {
  background-color: salmon !important;
}
.xet-pink-button:hover {
  background-color: red !important;
}
</style>

<title>Exet: Create a crossword</title>

</head>
<body>

<div id="xet-xlv-frame">
</div>

<script>

function ExetModals() {
  this.modal = null;
  document.addEventListener('click', this.handleClick.bind(this));
};

ExetModals.prototype.handleClick = function(e) {
  if (!this.modal) {
    return
  }
  if (!this.modal.contains(e.target)) {
    this.hide()
  }
}

// If caller calls this in response to a click event e, then caller should also
// call e.stopPropagation().
ExetModals.prototype.showModal = function(elt) {
  this.hide()
  if (!elt) {
    return
  }
  this.modal = elt;
  this.modal.style.display = 'block'
}

ExetModals.prototype.hide = function() {
  if (!this.modal) {
    return
  }
  this.modal.style.display = 'none'
  this.modal = null;
}

function ExetRevManager() {
  this.REV_LOADED_FROM_FILE = 1
  this.REV_CREATED_BLANK = 2
  this.REV_CREATED_AUTOBLOCK = 3
  this.REV_JUMPED_TO_REV = 10
  this.REV_GRID_CHANGE = 20
  this.REV_AUTOFILL_GRIDFILL_CHANGE = 28
  this.REV_GRIDFILL_CHANGE = 30
  this.REV_ENUM_CHANGE = 40
  this.REV_CLUE_CHANGE = 50
  this.REV_METADATA_CHANGE = 60
  this.REV_PREFLEX_CHANGE = 70

  this.revMsgs = {}
  this.revMsgs[this.REV_LOADED_FROM_FILE] = "Loaded from a file"
  this.revMsgs[this.REV_CREATED_BLANK] = "Created a blank grid"
  this.revMsgs[this.REV_CREATED_AUTOBLOCK] = "Created a blank grid with automagic blocks"
  this.revMsgs[this.REV_JUMPED_TO_REV] = "Jumped to a previous revision"
  this.revMsgs[this.REV_GRID_CHANGE] = "Grid change"
  this.revMsgs[this.REV_AUTOFILL_GRIDFILL_CHANGE] = "Autofilled grid-fill change"
  this.revMsgs[this.REV_GRIDFILL_CHANGE] = "Grid-fill change"
  this.revMsgs[this.REV_ENUM_CHANGE] = "Enum change"
  this.revMsgs[this.REV_CLUE_CHANGE] = "Clue or anno change"
  this.revMsgs[this.REV_METADATA_CHANGE] = "Metadata change"
  this.revMsgs[this.REV_PREFLEX_CHANGE] = "Change in the list of preferred words"

  // State for throttled revision-saving
  this.throttleRevTimer = null;
  this.saveLagMS = 5000
  this.throttlingLastRev = 0;

  // Special localStorage key for storing preferences and state
  this.SPECIAL_KEY = '42-exet-42'
  this.spaceUsedAtStart = 0
  for (let idx = 0; idx < window.localStorage.length; idx++) {
    let id = window.localStorage.key(idx)
    this.spaceUsedAtStart += window.localStorage.getItem(id).length
  }
  this.spaceUsed = this.spaceUsedAtStart

  let k500 = '1234567812345678'
  while (k500.length < 500000) {
    k500 = k500 + k500
  }
  let tempKey = '42-exet-cap-42-'
  this.spaceLeftAtStart = 0
  for (let i = 0; i < 20; i++) {
    // Only count up to 10 MB
    try {
      window.localStorage.setItem(tempKey + i, k500)
      this.spaceLeftAtStart += k500.length
    } catch (err) {
      break
    }
  }
  for (let i = 0; i < 20; i++) {
    window.localStorage.removeItem(tempKey + i)
  }

  // Id for previews
  this.previewId = `exet-preview-${Math.random().toString(36).substring(2, 8)}`
};

ExetRevManager.prototype.inMB = function(num) {
  return (num / 1000000).toFixed(2)
}

ExetRevManager.prototype.choosePuzRev = function(manageStorage=false, puz, elt, callback) {
  let choices = []
  if (puz) {
    let stored = window.localStorage.getItem(puz.id)
    let spaceUsed = stored.length
    choices = [{id: puz.id, title: puz.title, space: spaceUsed}]
  } else {
    this.spaceUsed = 0
    for (let idx = 0; idx < window.localStorage.length; idx++) {
      let id = window.localStorage.key(idx)
      let stored = window.localStorage.getItem(id)
      let spaceUsed = stored.length
      this.spaceUsed += spaceUsed
      if (id == this.SPECIAL_KEY) {
        continue
      }
      try {
        stored = JSON.parse(stored)
      } catch (err) {
        continue
      }
      if (!stored || !stored["id"] || !stored["revs"] || !stored["maxRevNum"]) {
        continue
      }
      let title = ''
      if (stored.revs.length > 0) {
        title = stored.revs[stored.revs.length - 1].title
      }
      choices.push({id: stored.id, title: title, space: spaceUsed})
    }
  }
  let html = `
  <table>
    <tr>
      <td><i>Select puzzle ID/Title</i></td>
      <td>
        <i>Select revision</i>
      </td>
    </tr>
    <tr>
      <td>
        <div class="xet-choices-box" id="xet-choose-id">
          <table class="xet-choices" id="xet-id-choices">`
  for (let i = 0; i < choices.length; i++) {
    html = html + `
      <tr id="xet-id-choice-${i}"><td>${choices[i].id}</td><td>${choices[i].title}</td><td>${this.inMB(choices[i].space)} MB</td></tr>`
  }
  html = html + `
          </table>
        </div>
      </td>
      <td>
        <div class="xet-choices-box" id="xet-choose-rev">
          <table class="xet-choices" id="xet-rev-choices">
          </table>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div>
          <span>Space used: ${this.inMB(this.spaceUsed)} MB</span>
          <span>Space available: <span class="xet-red">${this.inMB(this.spaceUsedAtStart + this.spaceLeftAtStart - this.spaceUsed)}</span> MB</span>
          <button id="xset-puz-rev-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete rev</button>
          <button id="xset-puz-prior-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete older revs!</button>
          <button id="xset-puz-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete!</button>
          <button id="xset-puz-rev-selector"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Open</button>
        </div>
        <div id="xet-preview" class="xet-preview">
        </div>
      </td>
    </tr>
  </table>
  `
  elt.innerHTML = html
  this.idChoicesBox = document.getElementById('xet-choose-id')
  this.idChoicesBox.style.width = '270px'
  this.idChoicesBox.style.height = '200px'
  this.idChoices = document.getElementById('xet-id-choices')
  this.revChoicesBox = document.getElementById('xet-choose-rev')
  this.revChoicesBox.style.width = '500px'
  this.revChoicesBox.style.height = '200px'
  this.revChoices = document.getElementById('xet-rev-choices')
  this.preview = document.getElementById('xet-preview')
  this.idChoice = ''
  this.revChoice = -1
  this.puzDeleter = document.getElementById('xset-puz-deleter')
  this.puzPriorDeleter = document.getElementById('xset-puz-prior-deleter')
  this.puzRevDeleter = document.getElementById('xset-puz-rev-deleter')
  this.puzRevSelector = document.getElementById('xset-puz-rev-selector')
  this.manageStorage = manageStorage
  if (manageStorage) {
    this.puzDeleter.style.display = ''
    this.puzPriorDeleter.style.display = ''
    this.puzRevDeleter.style.display = ''
    this.puzDeleter.disabled = true
    this.puzPriorDeleter.disabled = true
    this.puzRevDeleter.disabled = true
    let deleter = (types, e) => {
      if (!confirm('Are you sure you want to delete ' + types + ' revision(s)?')) {
        return
      }
      this.idChoices.className = 'xet-choices'
      this.revChoices.className = 'xet-choices'
      if (types == 'all') {
        window.localStorage.removeItem(this.idChoice)
      } else {
        if (this.revChoice < 0 || !this.storedRevs ||
            this.storedRevs.revs.length == 0 ||
            this.revChoice >= this.storedRevs.revs.length) {
          console.log('Weird, did not find revChoice/storedRevs to delete from')
          return
        }
        let lastToDelete = this.revChoice
        if (types == 'prior') lastToDelete--
        let numToDelete = (types == 'prior' ? lastToDelete + 1 : 1)
        let newRevs = []
        if (lastToDelete - numToDelete >= 0) {
          newRevs = this.storedRevs.revs.slice(0, lastToDelete - numToDelete + 1)
        }
        this.storedRevs.revs = newRevs.concat(this.storedRevs.revs.slice(lastToDelete + 1))
        this.saveLocal(this.idChoice, JSON.stringify(this.storedRevs))
      }
      this.choosePuzRev(true, null, exet.revChooser, null)
      e.stopPropagation()
    }
    this.puzDeleter.addEventListener('click', deleter.bind(this, 'all'))
    this.puzPriorDeleter.addEventListener('click', deleter.bind(this, 'prior'))
    this.puzRevDeleter.addEventListener('click', deleter.bind(this, 'this'))
  } else {
    this.puzRevSelector.style.display = ''
    this.puzRevSelector.disabled = true
    this.puzRevSelector.addEventListener('click', e => {
      if (this.revChoice < 0 || !this.storedRevs ||
          this.storedRevs.revs.length == 0 ||
          this.revChoice >= this.storedRevs.revs.length) {
        console.log('Hmm: bad selection! Check ExetRevManager:')
        console.log(this)
        return
      }
      exetModals.hide()
      this.idSelectors = []
      this.revSelectors = []
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      callback(this.storedRevs.revs[this.revChoice])
    })
  }

  this.idSelectors = []
  this.revSelectors = []
  this.storedRevs = null
  if (puz) {
    this.idChoice = puz.id
    document.getElementById("xet-id-choice-0").className = 'xet-chosen'
    this.chooseRev()
    return
  }
  for (let i = 0; i < choices.length; i++) {
    let selector = document.getElementById(`xet-id-choice-${i}`)
    this.idSelectors.push(selector)
    let id = choices[i].id
    selector.addEventListener('click', e => {
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      this.puzDeleter.disabled = true
      this.puzPriorDeleter.disabled = true
      this.puzRevDeleter.disabled = true
      this.revChoices.innerHTML = ''
      this.revChoices.className = 'xet-choices'
      this.revChoice = -1
      this.revSelectors = []
      this.storedRevs = null
      this.puzRevSelector.disabled = true
      if (id == this.idChoice) {
        this.idChoice = null
        selector.className = ''
        this.idChoices.className = 'xet-choices'
      } else {
        for (let j = 0; j < choices.length; j++) {
          if (j != i) {
            this.idSelectors[j].className = ''
          }
        }
        this.idChoice = id
        this.puzDeleter.disabled = false
        selector.className = 'xet-chosen'
        this.idChoices.className = 'xet-choices xet-picked'
        this.chooseRev()
      }
    })
  }
};

Exet.prototype.renderPreview = function(spec, eltId) {
  let newPuz = new Exolve(spec, eltId, null, false, 0, 400)
  document.getElementById(`${newPuz.prefix}-controls-etc`).style.display = 'none'
  document.getElementById(`${newPuz.prefix}-curr-clue-parent`).style.display = 'none'
  newPuz.revealAll(false)
}

ExetRevManager.prototype.chooseRev = function() {
  let stored = window.localStorage.getItem(this.idChoice)
  if (!stored) {
    return
  }
  this.storedRevs = JSON.parse(stored)
  let html = ''
  for (let idx = this.storedRevs.revs.length - 1; idx >= 0; idx--) {
    let rev = this.storedRevs.revs[idx]
    let revTime = new Date(rev.timestamp)
    html = html + `
      <tr id="xet-rev-choice-${idx}">
        <td>${rev.title}</td>
        <td>#${rev.revNum}</td>
        <td>${revTime.toLocaleString()}</td>
        <td>${exetRevManager.revMsgs[rev.revType]}</td>
        <td>${rev.details}</td>
      </tr>`
  }
  this.revChoices.innerHTML = html
  this.revSelectors = []
  this.revChoice = -1
  for (let i = 0; i < this.storedRevs.revs.length; i++) {
    let selector = document.getElementById(`xet-rev-choice-${i}`)
    this.revSelectors.push(selector)
    selector.addEventListener('click', e => {
      if (!this.storedRevs) {
        return
      }
      this.puzPriorDeleter.disabled = true
      this.puzRevDeleter.disabled = true
      this.puzRevSelector.disabled = true
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      if (i == this.revChoice) {
        this.revChoice = -1
        selector.className = ''
        this.revChoices.className = 'xet-choices'
      } else {
        for (let j = 0; j < this.revSelectors.length; j++) {
          if (j != i) {
            this.revSelectors[j].className = ''
          }
        }
        this.revChoice = i
        selector.className = 'xet-chosen'
        this.revChoices.className = 'xet-choices xet-picked'
        let exolve = this.storedRevs.revs[i].exolve.replace(/exolve-id:[ ]*[a-zA-Z0-9-]*/,
            `exolve-id: ${this.previewId}`)
        exet.renderPreview(exolve, "xet-preview")
        this.puzPriorDeleter.disabled = (i <= 0)
        this.puzRevDeleter.disabled = false
        this.puzRevSelector.disabled = false
      }
    })
  }
};

ExetRevManager.prototype.saveLocal = function(k, v) {
  try {
    window.localStorage.setItem(k, v)
  } catch (err) {
    alert('No available local storage left. Please use the "Manage storage" menu option to free up some space.')
    console.log('Could not save value of length ' + v.length + ' for key: ' + k)
  }
}

ExetRevManager.prototype.saveRev = function(revType, details="") {
  if (!exet || !exet.puz || !exet.puz.id) {
    console.log('Cannot save revision when there is no puzzle!')
    return
  }
  let stored = window.localStorage.getItem(exet.puz.id)
  if (!stored) {
    stored = {
      id: exet.puz.id,
      maxRevNum: 0,
      revs: []
    }
  } else {
    stored = JSON.parse(stored)
  }
  let exolve = exet.getExolve()
  if (stored.revs.length > 0) {
    let lastRev = stored.revs[stored.revs.length - 1]
    if (lastRev.exolve == exolve &&
        lastRev.prefix == exet.prefix && lastRev.suffix == exet.suffix &&
        lastRev.scratchPad == exet.puz.scratchPad.value &&
        lastRev.preflex && JSON.stringify(lastRev.preflex) == JSON.stringify(exet.preflex) &&
        lastRev.unpreflex && JSON.stringify(lastRev.unpreflex) == JSON.stringify(exet.unpreflex) &&
        lastRev.noProperNouns == exet.noProperNouns &&
        lastRev.minpop == exet.minpop) {
      return
    }
  }
  stored.maxRevNum++;
  let exetRev = new ExetRev(exet.puz.id, (exet.puz.title ? exet.puz.title : ''),
                            stored.maxRevNum, revType, Date.now(), details)
  exetRev.maxRevNum = stored.maxRevNum
  exetRev.prefix = exet.prefix
  exetRev.suffix = exet.suffix
  exetRev.exolve = exolve
  exetRev.scratchPad = exet.puz.scratchPad.value
  exetRev.navState = [exet.puz.currDir, exet.puz.currRow, exet.puz.currCol]
  exetRev.preflex = exet.preflex
  exetRev.unpreflex = exet.unpreflex
  exetRev.noProperNouns = exet.noProperNouns
  exetRev.minpop = exet.minpop
  stored.revs.push(exetRev)
  this.saveLocal(exet.puz.id, JSON.stringify(stored))
};

ExetRevManager.prototype.throttledSaveRev = function(revType, details="") {
  let urgent = revType <= 10;
  if (this.throttleRevTimer) {
    clearTimeout(this.throttleRevTimer);
    if (this.throttlingRevType > 0 && revType < this.throttlingRevType) {
      urgent = true
    }
  }
  this.throttleRevTimer = null;
  this.throttlingRevType = 0;
  if (urgent) {
    this.saveRev(revType, details)
    return
  }
  this.throttlingRevType = revType;
  this.throttleRevTimer = setTimeout(() => {
    this.saveRev(revType, details)
    this.throttleRevTimer = null;
    this.throttlingRevType = 0;
  }, this.saveLagMS);
}

function ExetRev(id, title, revNum, revType, timestamp, details="") {
  this.id = id;
  this.title = title
  this.revNum = revNum;
  this.revType = revType;
  this.timestamp = timestamp;
  this.details = details;
  // prefix, suffix, exolve should be set directly.
};

function Exet() {
  this.puz = null
  this.prefix = ''
  this.suffix = ''
  this.otherSections = ''
  this.preflex = []
  this.unpreflex = {}
  this.noProperNouns = false
  this.setMinpop(0)

  // Start in the Exet tab
  this.currTab = "exet"
  this.savedIndsSelect = ""

  // State for throttled handlers
  this.throttledGridTimer = null;
  this.throttledPreflexTimer = null;
  this.throttledUnpreflexTimer = null;
  this.throttledClueTimer = null;
  this.throttledMetadataTimer = null;
  this.throttledCharadeTimer = null;
  this.viabilityUpdateTimer = null;
  this.inputLagMS = 400
  this.sweepMS = 500

  // Params for light choices shown.
  this.sweepMaxChoices = 500
  this.sweepMaxChoicesSmall = 4
  this.shownLightChoices = 200

  // Set of all letters in the lexicon.
  this.allLetters = {}
  for (let c of exetLexicon.letters) {
    this.allLetters[c.toUpperCase()] = true
  }
};

Exet.prototype.setMinpop = function(m) {
  if (m < 0) m = 0
  this.minpop = m
  this.indexMinpop = Math.floor(exetLexicon.startLen * (100 - m) / 100)
}

Exet.prototype.startNav = function(dir='A', row=0, col=0) {
  if (!this.puz) return;
  if (row < 0 || row >= this.puz.gridHeight ||
      col < 0 || col >= this.puz.gridWidth) {
    row = 0
    col = 0
  }
  if (dir != 'A' && dir != 'D') {
    dir = 'A'
    let gridCell = this.puz.grid[row][col]
    if (gridCell.isLight && !gridCell.acrossClueLabel &&
        gridCell.downClueLabel) {
      dir = 'D'
    }
  }
  this.puz.currRow = row
  this.puz.currCol = col
  this.puz.currDir = dir
  if (this.puz.grid[row][col].isLight) {
    this.puz.activateCell(row, col)
  } else {
    this.navDarkness(row, col)
  }
}

Exet.prototype.setPuzzle = function(puz) {
  if (puz.hasDgmlessCells) {
    console.log('Diagramless cells not yet supported')
    return false
  }
  if (puz.hasNodirClues) {
    console.log('Nodir clues not yet supported')
    return false
  }
  if (puz.offNumClueIndices.length > 0) {
    console.log('Non-numeric clues not yet supported')
    return false
  }
  let gridFillChanges = false
  for (let i = 0; i < puz.gridHeight; i++) {
    for (let j = 0; j < puz.gridWidth; j++) {
      let gridCell = puz.grid[i][j]
      if (gridCell.skipNum) {
        console.log('Skipped-number cells not yet supported')
        return false
      }
      if (gridCell.solution == '0') {
        gridCell.solution = '?'
        gridFillChanges = true
      }
    }
  }
  this.puz = puz
  if (gridFillChanges) {
    this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
    return;
  }

  puz.revealAll(false)
  puz.gridInput.addEventListener('keydown', this.handleKeyDown.bind(this));
  puz.gridInput.addEventListener('input', this.throttledGridInput.bind(this));
  if (!this.prefix && !this.suffix) {
    this.prefix = '' +
        '<!DOCTYPE html>\n' +
        '<html lang="en">\n' +
        '<head>\n' +
        '<meta charset="utf-8"/>\n' +
        '<meta name="viewport" content="width=device-width, initial-scale=1"/>\n' +
        '<link rel="stylesheet" type="text/css" href="https://viresh-ratnakar.github.io/exolve-m.css"/>\n' +
        '<script src="https://viresh-ratnakar.github.io/exolve-m.js"><\/script>\n' +
        '<\/head>\n' +
        '<body>\n' +
        '<script>\n' +
        'createExolve(`'
    this.suffix = '' +
        '`);\n' +
        '<\/script>\n' +
        '<\/body>\n' +
        '<\/html>\n'
  }
  this.otherSections = ''
  for (let l = 0; l < puz.numLines; l++) {
    if (puz.specLines[l].trim().startsWith('exolve-end')) {
      break
    }
    if (puz.specLines[l].trim().startsWith('exolve-id')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-title')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-setter')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-copyright')) {
      continue
    }
    if (puz.gridFirstLine && puz.gridLastLine &&
        l >= puz.gridFirstLine - 1 && l <= puz.gridLastLine) {
      continue
    }
    if (puz.acrossFirstLine && puz.acrossLastLine &&
        l >= puz.acrossFirstLine - 1 && l <= puz.acrossLastLine) {
      continue
    }
    if (puz.downFirstLine && puz.downLastLine &&
        l >= puz.downFirstLine - 1 && l <= puz.downLastLine) {
      continue
    }
    this.otherSections = this.otherSections + puz.specLines[l] + '\n'
  }
  let clueChanges = false
  let numA = 0
  let numD = 0
  for (let idx in puz.clues) {
    let clue = puz.clues[idx]
    if (clue.dir == 'A') numA++
    else if (clue.dir == 'D') numD++
    if (clue.parentClueIndex) {
      continue
    }
    if (!clue.clue) {
      clue.clue = 'TO DO: provide clue'
      if (clue.cells.length > 0) {
        clue.clue = clue.clue + ' (' + clue.cells.length + ')'
      }
      clueChanges = true
    }
  }
  if (clueChanges) {
    this.updatePuzzle(exetRevManager.REV_CLUE_CHANGE)
    return;
  }

  this.tabs = {
    "exet": {
      id: "exet",
      display: "Exet",
      hover: "Controls: load, save, grid-fill, edit, etc...",
      sections: [],
      url: "",
    },
    "tfd": {
      id: "tfd",
      display: "TFD",
      hover: "The Free Dictionary: definitions, roots, synonyms, US/UK pronunciations, encycolopedia...",
      sections: [{url: "https://thefreedictionary.com/"}],
    },
    "google": {
      id: "google",
      display: "Google Dict",
      hover: "Google Dictionary: definitions, synonyms, pronunciation...",
      sections: [{url: "https://api.dictionaryapi.dev/api/v1/entries/en/"}],
    },
    "etym": {
      id: "etym",
      display: "Etym",
      hover: "Etymonline: Roots and history...",
      sections: [{url: "https://www.etymonline.com/search?q="}],
    },
    "wordplay0": {
      id: "wordplay0",
      display: "Charades...",
      hover: "Charades, including anagrams, reversals, and containers...",
      sections: [{id: "xet-charades", maker: this.makeCharadeParam, title: "Charades, including anagrams, reversals, and containers"}],
    },
    "wordplay1": {
      id: "wordplay1",
      display: "Anagrams...",
      hover: "Nutrimatic: anagrams, alternations; composite anagrams...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeAnagramParam, title: "Anagrams"},
        {url: "https://nutrimatic.org/?q=", maker: this.makeAlternationParam, title: "Alternations"},
        {id: "xet-companag", maker: this.makeCAParam, title: "Composite and extended anagrams"},
      ],
    },
    "wordplay2": {
      id: "wordplay2",
      display: "Hidden...",
      hover: "Nutrimatic: hidden answers...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeHiddenParam, title: "Hidden answers"},
        {url: "https://nutrimatic.org/?q=", maker: this.makeRevHiddenParam, title: "Reversed hidden answers"},
      ]
    },
    "inds": {
      id: "inds",
      display: "Lists",
      hover: "Crossword Unclued, Wikipedia: cryptic indicators and abbreviations lists...",
      sections: [],
    },
  }

  this.replaceHandlers()
  document.getElementById(`${this.puz.prefix}-controls`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-saving`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-tools-link`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-report-bug`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-exolve-link`).style.display = 'none'

  this.copyright = document.getElementById(`${this.puz.prefix}-copyright`)
  this.copyright.innerHTML = `<span class="xet-action">Edit optional
      copyright notice: Ⓒ &nbsp;</span><span
      class="xet-editable"
      id="xet-copyright" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.copyright}</span>`
  this.copyright.style.display = ''
  this.xetCopyright = document.getElementById('xet-copyright')

  this.title = document.getElementById(`${this.puz.prefix}-title`)
  this.title.innerHTML = `<span class="xet-action">Edit optional
      title:</span><span
      class="xet-editable"
      id="xet-title" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.title}</span>`
  this.title.style.display = ''
  this.xetTitle = document.getElementById('xet-title')

  this.setter = document.getElementById(`${this.puz.prefix}-setter`)
  this.setter.innerHTML = `<span class="xet-action">Edit optional
      setter(s):</span><span
      class="xet-editable"
      id="xet-setter" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.setter}</span>`
  this.setter.style.display = ''
  this.xetSetter = document.getElementById('xet-setter')

  let aLabel = document.getElementById(`${this.puz.prefix}-across-label`)
  aLabel.insertAdjacentHTML('beforeend', ` (${numA} clues)`)
  let dLabel = document.getElementById(`${this.puz.prefix}-down-label`)
  dLabel.insertAdjacentHTML('beforeend', ` (${numD} clues)`)

  this.frame = document.createElement('div')
  this.frame.className = 'xet-frame'
  this.frame.id = 'xet-frame'
  this.puz.gridPanel.after(this.frame)

  delete this.shownChoicesHash
  this.populateFrame()

  // Add darkness and viability indicators ("viablots").
  for (let i = 0; i < puz.gridHeight; i++) {
    for (let j = 0; j < puz.gridWidth; j++) {
      let gridCell = puz.grid[i][j]
      if (gridCell.isLight && gridCell.solution == '?') {
        const viablot =
            document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        viablot.setAttributeNS(
            null, 'cx', puz.cellLeftPos(j, puz.circleR + puz.GRIDLINE));
        viablot.setAttributeNS(
            null, 'cy', puz.cellTopPos(i, puz.circleR + puz.GRIDLINE));
        viablot.setAttributeNS(null, 'class', 'xlv-cell-circle');
        viablot.style.fill = 'transparent'
        viablot.setAttributeNS(null, 'r', puz.circleR * 0.1);
        gridCell.viablot = viablot
        puz.svg.appendChild(viablot)
        viablot.addEventListener('click', puz.cellActivator.bind(puz, i, j));
      } else if (!gridCell.isLight) {
        const border = 4
        let darkness =
          document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        darkness.setAttributeNS(null, 'x', this.puz.cellLeftPos(
            j, this.puz.GRIDLINE + border))
        darkness.setAttributeNS(null, 'y', this.puz.cellTopPos(
            i, this.puz.GRIDLINE + border))
        darkness.setAttributeNS(null, 'width',
                                this.puz.squareDim - (2 * border));
        darkness.setAttributeNS(null, 'height',
                                this.puz.squareDim - (2 * border));
        darkness.style.fill = 'transparent'
        puz.svg.appendChild(darkness)
        gridCell.darkness = darkness
        darkness.addEventListener('click', this.navDarkness.bind(this, i, j))
      }
    }
  }

  // Display lexicon info
  const status = document.getElementById(`${this.puz.prefix}-status`)
  status.insertAdjacentHTML('beforeend', `<span> Lexicon: ${exetLexicon.id} ${exetLexicon.language} ${exetLexicon.script}.</span>`)

  // Display sweeping activity indicator
  const gridParent = document.getElementById(`${this.puz.prefix}-grid-parent`)
  gridParent.insertAdjacentHTML('beforeend',
    `<div class="xet-sweeping-box"
       title="When there is a flashing red circle here, Exet is autofilling and/or pruning away non-viable grid-fill suggestions in the background">
       <div class="xet-sweeping" id="xet-sweeping"></div></div>`)
  this.sweepIndicator = document.getElementById('xet-sweeping')

  this.puz.viable = true
  this.fillState = new ExetFillState(this.puz)

  this.initAutofill()
  this.resetViability();
  this.updateSweepInd()

  return true
}

Exet.prototype.makeExetTab = function() {
  let exetTab = this.tabs["exet"]
  exetTab.content.innerHTML = `
<div class="xet-controls-col">
  <div class="xet-menu">
    <ul>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to open a new or previously saved puzzle">Open</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" id="xet-show-puz-chooser">
            Choose a puzzle previously opened with Exet
          </div>
          <div class="xet-dropdown-item" id="xet-show-rev-chooser">
            Go back to a specific revision of the current puzzle
          </div>
          <div class="xet-dropdown-item">
            Open Exolve file: <input id="xet-file" onchange="exetLoadFile();" type="file"></input>
          </div>
          <div class="xet-dropdown-item">
            New grid:
            <div class="xet-dropdown-submenu">
              <div style="padding:4px;text-align:center">
                <div>
                  <input id="xet-w" name="xet-w" value="15"
                    type="text" size="3" maxlength="3" placeholder="W">
                  </input>
                  &times;
                  <input id="xet-h" name="xet-h" value="15"
                    type="text" size="3" maxlength="3" placeholder="H">
                  </input>
                </div>
                <br>
                <div>
                  Unique ID:
                  <input id="xet-id" name="xet-id"
                    value="xet-${Math.random().toString(36).substring(2, 8)}"
                    title="Please change to a meaningful alphanumeric id (beginning with a letter) to identify easily later"
                    type="text" size="15" maxlength="30" placeholder="alphanumeric unique id">
                  </input>
                </div>
                <br>
                <div title="When this is checked, Exet will automagically add blocked cells to create a valid grid. You can further edit the blocks and add more automagic blocks from the Edit menu">
                  Add automagic blocks:
                  <input id="xet-autoblock" name="xet-autoblock" value="autoblock" checked=true type="checkbox">
                  </input>
                </div>
              </div>
              <hr>
              <div class="xet-controls-row">
                <div class="xet-dropdown-subitem" title="Blocked with no top/left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, false, false);">
                  <img class="xet-icon" src="no-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="Blocked with top but not left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, true, false);">
                  <img class="xet-icon" src="t-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="Blocked with left but not top unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, false, true);">
                  <img class="xet-icon" src="l-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="Blocked with top/left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, true, true);">
                  <img class="xet-icon" src="tl-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="No blocks"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  false);">
                  <img class="xet-icon" src="no-blocks.png"/>
                </div>
              </div>
            </div>
          </div>
          <div class="xet-dropdown-item" id="xet-manage-storage">
            Manage storage (Used:
            ${exetRevManager.inMB(exetRevManager.spaceUsed)} MB
            Available: 
              <span class="xet-red">${exetRevManager.inMB(exetRevManager.spaceUsedAtStart + exetRevManager.spaceLeftAtStart - exetRevManager.spaceUsed)}</span> MB)
          </div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to save, with some formatting options">Save</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" onclick="exet.downloadDotPuz()">Download PUZ file (exet.puz)</div>
          <div class="xet-dropdown-item" onclick="exet.download(true)">Download Exolve file w/ solutions (exet-exolve-solved.html)</div>
          <div class="xet-dropdown-item" onclick="exet.download(false)">Download Exolve file w/o solutions (exet-exolve-unsolved.html)</div>
          <div class="xet-dropdown-item" onclick="exet.toClipboard(true, 'xet-xlv-widget')">Copy Exolve widget code w/ solutions &#128203;
            <div class="xet-dropdown-submenu">
              <textarea rows="100" cols="80" id="xet-xlv-widget">
              </textarea>
            </div>
          </div>
          <div class="xet-dropdown-item" onclick="exet.toClipboard(false, 'xet-xlv-widget-nosol')">Copy Exolve widget code w/o solutions &#128203;
            <div class="xet-dropdown-submenu">
              <textarea rows="100" cols="80" id="xet-xlv-widget-nosol">
              </textarea>
            </div>
          </div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to make grid changes (please also note the listed keyboard shortcuts)">Edit</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('@')">Toggle encircling (@)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('!')">Toggle marking prefilled (!)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('.')">Toggle block (.)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('|')">Toggle bar-after (|)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('_')">Toggle bar-under (_)</div>
          <hr>
          <hr>
          <div title="Try to autofill the remaining grid" class="xet-dropdown-item" id="xet-start-autofill">Autofill:
            <div class="xet-dropdown-submenu xet-autofill-panel">
              <div>
                <button id="xet-autofill-startstop" class="xlv-button">Start</button>
                <button id="xet-autofill-accept" style="float:right" title="Accept autofill suggestions" class="xlv-button">Accept</button>
                <button id="xet-autofill-clear" style="float:right" title="Stop the autofill and clear all its suggestions" class="xlv-button">Clear</button>
              </div>
              <hr>
              <div style="padding:4px">
                Beam search width:
                <input id="xet-autofill-max-beam" name="xet-autofill-max-beam" value="64"
                   type="text" size="4" maxlength="4" style="padding:0;margin:0">
                </input>
              </div>
              <div style="padding:4px">
                Try to get a pangram:
                <input id="xet-autofill-boost-pangram" name="xet-autofill-boost-pangram"
                  value="pangram" type="checkbox">
                </input>
              </div>
              <hr>
              <div style="padding:4px" title="You can edit the list of preferred fills by clicking on the 'Set preferred fills' button">
                Preferred fills used: <span id="xet-autofill-preflex-used">0</span> of <span id="xet-autofill-preflex-total">${this.preflex.length}</span>
              </div>
              <div title="You can edit the list of undesired fills, restrict fills by a popularity cutoff, and allow/disallow proper nouns by clicking on the 'Set fill exclusions' button">
                <div style="padding:4px">
                  Min popularity: <span id="xet-autofill-minpop">${this.minpop}</span> %ile
                  (<span id="xet-autofill-index-minpop">${this.indexMinpop}</span> entries)
                </div>
                <div style="padding:4px" title="You can edit the list of undesired fills, restrict fills by a popularity cutoff, and allow/disallow proper nouns by clicking on the 'Set fill exclusions' button">
                  Proper nouns: <span id="xet-autofill-proper-nouns">${this.noProperNouns ? "disallowed" : "allowed"}</span>&nbsp;
                  Undesired fills: <span id="xet-autofill-unpreflex-total">${Object.keys(this.unpreflex).length}</span>
                </div>
              </div>
              <div style="padding:4px">
                Letters used: <span id="xet-autofill-pangram">0</span> of ${exetLexicon.letters.length}
              </div>
              <hr>
              <div style="padding:4px">
                Step: <span id="xet-autofill-step"></span> &nbsp
                Score: <span id="xet-autofill-score">0.00</span>
                <span style="font-size:12px">
                (<span id="xet-autofill-score-v">0.00</span> viab + 
                <span id="xet-autofill-score-f">0.00</span> full)
                </span>
              </div>
              <div style="padding:4px">
                Last status: <span id="xet-autofill-status"></span> (beam width: <span id="xet-autofill-curr-beam"></span>)
              </div>
            </div>
          </div>
          <div title="Try to autmatically add random blocks while maintaining a valid grid"
            class="xet-dropdown-item" onclick="exet.handleKeyDown('#')">Add automagic blocks (#)
          </div>
          <hr>
          <hr>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('=')">Accept autofilled entries (=)</div>
          <div class="xet-dropdown-item" onclick="exet.clearAll()">Clear all the lights!</div>
        </div>
      </li>
      <li class="xet-dropdown" style="float:right;">
        <div class="xet-dropbtn" id="xet-about" title="Click to see notes, notices, and pointers about Exet...">About <span id='xet-outdated' style='display:none'>&#9888;</span></div>
        <div class="xet-dropdown-content" style="right:0;width:90ch;padding:8px;">
          <div id="xet-outdated-message" style="display:none"></div>
          <iframe id="xet-about-iframe" class="xet-iframe"
              style="height:450px"
              src="about-exet.html">
          </iframe>
        </div>
      </li>
    </ul>
    <div id="xet-rev-chooser" class="xet-rev-chooser" style="display:none">
    </div>
  </div>
  <hr class="xet-full-width"/>
  <div id="xet-temp" style="display:none">
  </div>

  <div class="xet-controls-row xet-panel xet-high-tall-box">
    <div class="xet-controls-col" style="position:relative">
      <div>
        <span style="font-weight:bold" title="Please note that any lexicon in use by this software is inevitably likely to have some errors and omissions.">Choose grid-fill</span>
        <button class="xlv-small-button" style="padding:5px 4px" onclick="exet.clearCurr()">Clear light</button>
      </div>
      <div class="xet-choices-box" id="xet-light-choices-box">
        <table id="xet-light-choices" class="xet-choices">
        </table>
      </div>
      <div title="You can provide up to 100 preferred words/phrases to try and use in the grid-fill">
        <button class="xlv-small-button" style="padding:5px 4px" id="xet-edit-preflex">Set preferred fills</button>
        <span id="xet-preflex-used">0</span>/<span id="xet-preflex-size">${this.preflex.length}</span> used
      </div>
      <div title="You can provide words/phrases to exclude from the grid-fill, set a minimum popularity, and include/exclude proper nouns">
        <button class="xlv-small-button" style="padding:5px 4px;color:chocolate" id="xet-edit-unpreflex">Set fill exclusions</button>
        <span id="xet-unpreflex-size">${Object.keys(this.unpreflex).length}</span> set
      </div>
      <div class="xet-preflex-editor" title="Click anywhere outside this box to dismiss it"
        id="xet-preflex-editor" style="display:none">
        <div>
         List of preferred words/phrases (up to 100):
        </div>
        <div class="xet-choices-box xet-mid-tall-box">
          <textarea rows="100" cols="30" id="xet-preflex-input"
            oninput="exet.throttledUpdatePreflex()"
            class="xlv-answer"></textarea>
        </div>
      </div>
      <div class="xet-preflex-editor" title="Click anywhere outside this box to dismiss it"
        id="xet-unpreflex-editor" style="display:none">
        <div>
          Minimum popularity:
          <input id="xet-minpop" name="xet-minpop" class="xlv-answer" size="4" maxlength="4" type="text"></input> %ile<br>
          (exclude bottom <span id="xet-minpop-excl">${exetLexicon.startLen - this.indexMinpop}</span> of ${exetLexicon.startLen})
          <br>
          <br>
          Disallow proper nouns:
          <input id="xet-no-proper-nouns" name="xet-no-proper-nouns" value="no-proper-nouns" checked=false type="checkbox">
          </input>
          <br>
          <br>
           List of words/phrases that you do not want as fills:
        </div>
        <div class="xet-choices-box xet-low-tall-box">
          <textarea rows="100" cols="30" id="xet-unpreflex-input"
            oninput="exet.throttledUpdateUnpreflex()"
            class="xlv-answer"></textarea>
        </div>
      </div>
    </div>
    <div class="xet-controls-col">
      <div id="xet-scratch-pad" class="xet-controls-col">
      </div>
    </div>
  </div>
</div>
  `;
  // Set up menu click handling
  let menuButtons = exetTab.content.getElementsByClassName('xet-dropbtn')
  for (let i = 0; i < menuButtons.length; i++) {
    let menuPanel = menuButtons[i].nextElementSibling
    menuButtons[i].addEventListener('click', e => {
      exetModals.showModal(menuPanel)
      e.stopPropagation()
    })
    menuButtons[i].addEventListener('mouseenter', e => {
      exetModals.hide()
    })
  }

  this.lChoices = document.getElementById("xet-light-choices")
  this.preflexUsed = document.getElementById("xet-preflex-used")
  this.preflexSize = document.getElementById("xet-preflex-size")
  this.preflexEditor = document.getElementById("xet-preflex-editor")
  this.preflexInput = document.getElementById("xet-preflex-input")
  let preflexText = ''
  for (let p of this.preflex) {
    if (preflexText) preflexText += '\n'
    preflexText += p
  }
  this.preflexInput.value = preflexText
  document.getElementById("xet-edit-preflex").addEventListener('click', e=> {
    exetModals.showModal(exet.preflexEditor)
    e.stopPropagation()
  })
  this.unpreflexSize = document.getElementById("xet-unpreflex-size")
  this.unpreflexEditor = document.getElementById("xet-unpreflex-editor")
  this.unpreflexInput = document.getElementById("xet-unpreflex-input")
  this.renderUnpreflex()
  document.getElementById("xet-edit-unpreflex").addEventListener('click', e=> {
    exetModals.showModal(exet.unpreflexEditor)
    e.stopPropagation()
  })
  this.minpopExclSpan = document.getElementById("xet-minpop-excl")
  this.minpopInput = document.getElementById("xet-minpop")
  this.minpopInput.value = this.minpop
  this.minpopInput.addEventListener('change', e => {
    if (isNaN(this.minpopInput.value) ||
        this.minpopInput.value < 0 || this.minpopInput.value >= 100) {
      this.minpopInput.value = this.minpop
      return
    }
    this.setMinpop(this.minpopInput.value)
    this.minpopExclSpan.innerText = (exetLexicon.startLen - this.indexMinpop)
    this.resetViability()
    exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
  })
  this.noProperNounsInput = document.getElementById("xet-no-proper-nouns")
  this.noProperNounsInput.checked = this.noProperNouns
  this.noProperNounsInput.addEventListener('change', e => {
    this.noProperNouns = this.noProperNounsInput.checked
    this.resetViability()
    exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
  })

  this.revChooser = document.getElementById("xet-rev-chooser")
  let showPuzChooser = document.getElementById("xet-show-puz-chooser")
  showPuzChooser.addEventListener('click', e => {
    exetRevManager.choosePuzRev(false, null, exet.revChooser, exetFromHistory);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })
  let showRevChooser = document.getElementById("xet-show-rev-chooser")
  showRevChooser.addEventListener('click', e => {
    exetRevManager.choosePuzRev(false, this.puz, exet.revChooser, exetFromHistory);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })
  let manageStorage = document.getElementById("xet-manage-storage")
  manageStorage.addEventListener('click', e => {
    exetRevManager.choosePuzRev(true, null, exet.revChooser, null);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })

  // Move the scratch pad over to here.
  const scratchP = document.getElementById("xet-scratch-pad")
  this.puz.scratchPad.rows = "3"
  this.puz.scratchPad.cols = "82"
  const scratchPLabel = document.getElementById(this.puz.prefix + '-shuffle')
  scratchPLabel.style.padding = '8px 0'
  scratchP.appendChild(scratchPLabel)
  scratchP.appendChild(this.puz.scratchPad)

  // Pull in the clues.
  this.cluesPanel = document.createElement('div')
  this.cluesPanel.id = 'xet-clues'
  this.cluesPanel.className = 'xet-panel xet-mid-tall-box xet-clues'
  this.cluesPanel.title = 'You can edit the current clue as shown above the grid by clicking on it.'
  scratchP.after(this.cluesPanel)
  this.cluesPanel.appendChild(document.getElementById(`${this.puz.prefix}-clues`))
}

Exet.prototype.stripInputLF = function(inp) {
  if (!inp) return
  if (inp.innerText.indexOf('\n') < 0) return
  inp.innerText = inp.innerText.replace(/\n/g, ' ')
}

Exet.prototype.updateMetadata = function() {
  if (!this.puz) {
    return
  }
  if (this.throttledMetadataTimer) {
    clearTimeout(this.throttledMetadataTimer);
  }
  this.throttledMetadataTimer = setTimeout(() => {
    if (this.xetTitle) {
      this.stripInputLF(this.xetTitle)
      this.puz.title = this.xetTitle.innerText
    }
    if (this.xetSetter) {
      this.stripInputLF(this.xetSetter)
      this.puz.setter = this.xetSetter.innerText
    }
    if (this.xetCopyright) {
      this.stripInputLF(this.xetCopyright)
      this.puz.copyright = this.xetCopyright.innerText
    }
    this.throttledMetadataTimer = null;
    exetRevManager.throttledSaveRev(exetRevManager.REV_METADATA_CHANGE)
  }, 2000);
}

Exet.prototype.indsTabNav = function() {
  if (this.indsIframe.src == this.indsSelect.value) {
    return
  }
  this.indsIframe.src = this.indsSelect.value;
  this.indsUrl.innerText = this.indsSelect.value;
  this.indsUrl.href = this.indsSelect.value;
}

Exet.prototype.makeIndsTab = function(panelH) {
  let inds = [
    {name: "Please select", url: ""},
    {name: "Crossword Unclued's anagram indicators",
     url: "https://www.crosswordunclued.com/2008/09/anagram-indicators.html"},
    {name: "Crossword Unclued's hidden words indicators",
     url: "https://www.crosswordunclued.com/2009/03/hidden-word-indicators.html"},
    {name: "Crossword Unclued's containment indicators",
     url: "https://www.crosswordunclued.com/2009/02/container-and-content-indicators.html"},
    {name: "Crossword Unclued's reversal indicators",
     url: "https://www.crosswordunclued.com/2009/07/reversal-indicators.html"},
    {name: "Crossword Unclued's homophone indicators",
     url: "https://www.crosswordunclued.com/2009/02/homophone-indicators.html"},
    {name: "Crossword Unclued's deletion indicators",
     url: "https://www.crosswordunclued.com/2009/04/deletion-indicators.html"},
    {name: "Crossword Unclued's letter-picking indicators",
     url: "https://www.crosswordunclued.com/2009/04/letter-sequence-indicators.html"},
    {name: "Crossword Unclued's list of abbreviations",
     url: "https://www.crosswordunclued.com/2008/10/cryptic-abbreviations.html"},
    {name: "Wikipedia's list of abbreviations",
     url: "https://en.wikipedia.org/wiki/Crossword_abbreviations"},
  ]
  let indsTab = this.tabs["inds"]
  let html = `
  <div>
  <select name="xet-inds-select" id="xet-inds-select"
    onchange="exet.indsTabNav()">`
  for (let ind of inds) {
    html = html + `
    <option value="${ind.url}">${ind.name}</option>`
  }
  html = html + '</select></div><br>'
  html = html + `
  <a href="" target="_blank" id="xet-inds-choice-url" class="xet-blue xet-small"></a><br>
  <iframe id="xet-inds-iframe" class="xet-iframe" src=""
    style="height:${panelH}px" height="${panelH}"></iframe>
  `;
  indsTab.content.innerHTML = html;
  this.indsIframe = document.getElementById('xet-inds-iframe')
  this.indsSelect = document.getElementById('xet-inds-select')
  this.indsSelect.value = this.savedIndsSelect
  this.indsUrl = document.getElementById('xet-inds-choice-url')
}

Exet.prototype.getAllSplits = function(fodder, k) {
  let n = fodder.length
  if (n < 1 || k < 1 || k > n ) return []
  if (k == 1) {
    return [[fodder]]
  }
  if (k == n) {
    let pieces = []
    for (let i = 0; i < n; i++) {
      pieces.push(fodder.charAt(i))
    }
    return [pieces]
  }
  let splits = []
  // For long fodders, skip some splits.
  for (let last_span = (fodder.length > 10 ? fodder.length - 9 : 1);
       last_span <= n - k + 1; last_span++) {
    let last_piece = fodder.substr(n - last_span, last_span);
    let prefix = fodder.substr(0, n - last_span);
    let subsplits = this.getAllSplits(prefix, k - 1)
    for (let subsplit of subsplits) {
      subsplit.push(last_piece);
      splits.push(subsplit);
    }
  }
  return splits
}

Exet.prototype.pushCharadeCandidate = function(elements) {
  if (!elements || elements.length == 0) {
    return
  }
  let charade = ''
  let score = 0;
  let i = 0
  let numScores = elements.length
  while (i < elements.length) {
    let x = elements[i]
    if (!x.possible) {
      return
    }
    if (charade) charade = charade + '<span class="xet-blue"> + </span>'
    charade = charade + x.possible
    score += x.score
    i++
    if (x.container) {
      contents = ''
      while (i < x.container) {
        let y = elements[i]
        if (!y.possible) {
          return
        }
        if (contents) contents = contents + ' '
        contents = contents + y.possible
        score += y.score
        i++
      }
      charade = charade + ' <span class="xet-blue">around (</span>' + contents +
        '<span class="xet-blue">)</span>'
      i++
      numScores = elements.length - 1
    }
  }
  score = score / numScores
  if (charade) {
    this.charadeCandidates.push({
      charade: charade,
      score: score
    })
  }
}

Exet.prototype.updateCharades = function(fodder) {
  if (this.throttledCharadeTimer) {
    clearTimeout(this.throttledCharadeTimer);
  }
  this.throttledCharadeTimer = null
  this.charadeCandidates = []
  this.charadeParts = 1;
  this.charadeSplits = null;
  this.charadeSplitIndex = 0;
  this.charadeMax = Math.min(fodder.length, 4)
  this.charadeFodder = fodder
  this.updateCharadesPartial()
}

Exet.prototype.updateCharadesPartial = function(work=100, sleep=50) {
  let startTS = Date.now()
  while (this.charadeParts <= this.charadeMax) {
    if (!this.charadeSplits) {
      this.charadeSplits = this.getAllSplits(this.charadeFodder, this.charadeParts)
      this.charadeSplitIndex = 0
    }
    while (this.charadeSplitIndex < this.charadeSplits.length) {
      let split = this.charadeSplits[this.charadeSplitIndex]
      let viable = []
      for (let part of split) {
        let possible = ''
        let score = 0
        let choices = this.getAnagrams(part)
        if (choices.length > 0) {
          score = part.length
          let rpart = ''
          if (part.length > 1) {
            rpart = part.split('').reverse().join('')
          }
          for (let choice of choices) {
            if (possible) possible = possible + ', '
            let key = this.makeCharadeParam(choice)
            if (key == part) possible = possible + choice
            else if (key == rpart) possible = possible + choice + '<span class="xet-blue"><<</span>'
            else possible = possible + choice + '<span class="xet-blue">*</span>'
          }
          if (choices.length > 1) {
            possible = '<span class="xet-blue">[</span>' + possible + '<span class="xet-blue">]</span>'
          }
        }
        viable.push({possible: possible, score: score})
      }
      if (viable.length < this.charadeParts) {
        continue
      }
      this.pushCharadeCandidate(viable)
      for (let c1 = 0; c1 < this.charadeParts - 2; c1++) {
        for (let c2 = c1 + 2; c2 < this.charadeParts; c2++) {
          // Everything else must be viable
          let ok = true
          for (let i = 0; i < this.charadeParts; i++) {
            if (i != c1 && i != c2 && !viable[i].possible) {
              ok = false
              break
            }
          }
          if (!ok) {
            continue
          }
          let container = split[c1] + split[c2]
          let choices = this.getAnagrams(container)
          if (choices.length > 0) {
            let rcontainer = container.split('').reverse().join('')
            let possible = ''
            for (let choice of choices) {
              if (possible) possible = possible + ', '
              let key = this.makeCharadeParam(choice)
              if (key == container) possible = possible + choice
              else if (key == rcontainer) possible = possible + choice + '<span class="xet-blue"><<</span>'
              else possible = possible + choice + '<span class="xet-blue">*</span>'
            }
            if (choices.length > 1) {
              possible = '<span class="xet-blue">[</span>' + possible + '<span class="xet-blue">]</span>'
            }
            let vcopy = viable.slice(0, viable.length)
            vcopy[c1] = {}
            vcopy[c1].possible = possible
            vcopy[c1].score = container.length
            vcopy[c1].container = c2
            this.pushCharadeCandidate(vcopy)
          }
        }
      }
      this.charadeSplitIndex++
      if (Date.now() - startTS >= work) {
        break
      }
    }
    if (this.charadeSplitIndex == this.charadeSplits.length) {
      this.charadeSplits = null
      this.charadeParts++;
    }
    if (Date.now() - startTS >= work) {
      break
    }
  }
  let candidates = this.charadeCandidates.sort((a, b) => b.score - a.score);
  let html = '<table id="xet-charade-choices">'
  for (let candidate of candidates) {
    html = html + `
      <tr><td><span style="color:gray">[${candidate.score.toFixed(1)}]</span> ${candidate.charade}</td></tr>`
  }
  html = html + '</table>'
  this.charades.innerHTML = html;
  if (this.charadeParts <= this.charadeMax) {
    this.throttledCharadeTimer = setTimeout(() => {
      this.updateCharadesPartial(work, sleep)
    }, sleep);
  }
}

Exet.prototype.updateCA = function() {
  let fodder = this.caFodder.value.toLowerCase().replace(/[^a-z]/g, '').split('').sort()
  let anagram = this.caAnagram.value.toLowerCase().replace(/[^a-z]/g, '').split('').sort()
  let f = 0;
  let a = 0;
  let extra = []
  let unused = []
  while (f < fodder.length && a < anagram.length) {
    if (fodder[f] == anagram[a]) {
      f++;
      a++;
    } else if (fodder[f] < anagram[a]) {
      unused.push(fodder[f++])
    } else {
      extra.push(anagram[a++])
    }
  }
  while (f < fodder.length) {
    unused.push(fodder[f++])
  }
  while (a < anagram.length) {
    extra.push(anagram[a++])
  }
  extraS = extra.join('')
  this.caExtra.innerText = extraS
  let html = ''
  let extraAnags = this.getAnagrams(extraS)
  for (let choice of extraAnags) {
    html = html + `
      <tr><td>${choice}</td></tr>`
  }
  this.caExtraAnags.innerHTML = html
  unusedS = unused.join('')
  this.caUnused.innerText = unusedS
  html = ''
  let unusedAnags = this.getAnagrams(unusedS)
  for (let choice of unusedAnags) {
    html = html + `
      <tr><td>${choice}</td></tr>`
  }
  this.caUnusedAnags.innerHTML = html
}

Exet.prototype.populateCompanag = function() {
  let ca = document.getElementById('xet-companag')
  ca.className = 'xet-companag'
  ca.innerHTML = `
    <table class="xet-table-midline">
      <tr>
        <td class="xet-td">Fodder:</td>
        <td class="xet-td">Anagram:</td>
      </tr>
      <tr>
        <td class="xet-td"><input type="text" class="xlv-answer xet-companag-text" id='xet-ca-fodder'></input></td>
        <td class="xet-td"><input type="text"
          title="Enter a phrase that's only roughly an anagram of some of the letters in the fodder"
          class="xlv-answer xet-companag-text" id='xet-ca-anagram'></input></td>
      </tr>
      <tr>
        <td class="xet-td">Extra in anagram:</td>
        <td class="xet-td"><div>Unused from fodder:</td>
      </tr>
      <tr>
        <td class="xet-td"><div class="xet-companag-text" id='xet-ca-extra'></div></td>
        <td class="xet-td"><div class="xet-companag-text" id='xet-ca-unused'></div></td>
      </tr>
      <tr>
        <td class="xet-td">
          Extra* anagrams:
          <table id="xet-ca-extra-anags">
          </table>
        </td>
        <td class="xet-td">
          Unused* anagrams:
          <table id="xet-ca-unused-anags">
          </table>
        </td>
      </tr>
    </table>`
  this.caFodder = document.getElementById('xet-ca-fodder')
  this.caAnagram = document.getElementById('xet-ca-anagram')
  this.caExtra = document.getElementById('xet-ca-extra')
  this.caUnused = document.getElementById('xet-ca-unused')
  this.caFodder.addEventListener('input', this.updateCA.bind(this))
  this.caAnagram.addEventListener('input', this.updateCA.bind(this))
  this.caExtraAnags = document.getElementById('xet-ca-extra-anags')
  this.caUnusedAnags = document.getElementById('xet-ca-unused-anags')
}

Exet.prototype.populateFrame = function() {
  let frameHTML = ''
  frameHTML = frameHTML + '<div class="xet-tab">'
  for (let id in this.tabs) {
    let tab = this.tabs[id]
    frameHTML = frameHTML +
        `<button id="xet-${id}">${tab.display}</button>`
  }
  frameHTML = frameHTML + '</div>'

  const panelH = 500
  const panelInnerH = 450
  for (let id in this.tabs) {
    let tab = this.tabs[id]
    frameHTML = frameHTML + `<div class="xet-tabcontent" id="xet-${id}-frame">`
    if (tab.sections.length > 0) {
      // We show the first (presumably main) section in the left column,
      // and stack up all the other sections in the right column.
      let numRows = 1
      let panelW = 900
      let secondH = panelInnerH
      if (tab.sections.length > 1) {
        numRows = tab.sections.length - 1
        panelW = 440
      }
      if (numRows > 1) {
        secondH = 200
      }
      frameHTML = frameHTML + '<div class="xet-section"><table>'
      for (let i = 0; i < tab.sections.length; i++) {
        let section = tab.sections[i]
        if (i != 1) {
          frameHTML = frameHTML + '<tr>'
        }
        let h = secondH
        if (i == 0) {
          frameHTML = frameHTML + `<td class="xet-td" rowspan="${numRows}">`
          h = panelInnerH
        } else {
          frameHTML = frameHTML + '<td class="xet-td">'
        }
        if (section.url) {
          frameHTML = frameHTML + `
            <div class="xet-bold">${section.title || ''}</div>
            <a href="" target="_blank" id="xet-${id}-url-${i}" class="xet-blue xet-small"></a><br>
            <iframe class="xet-iframe" style="height:${h}px;width:${panelW}px;"
               height="${h}" width="${panelW}px" id="xet-${id}-content-${i}">
            </iframe>`
        } else {
          frameHTML = frameHTML + `
            <div class="xet-bold">${section.title || ''}</div>
            <div id=${section.id}
              class="xet-panel"
              style="height:${h}px;width:${panelW}px;">
            </div>`
        }
        if (i > 0 && i < tab.sections.length - 1) {
          frameHTML = frameHTML + '<hr/><br>'
        }
        frameHTML = frameHTML + '</td>'
        if (i > 0 || tab.sections.length == 1) {
          frameHTML = frameHTML + '</tr>'
        }
      }
      frameHTML = frameHTML + `
        </table>
        </div>`
    } else {
      frameHTML = frameHTML + `
        <div class="xet-section" id="xet-${id}-content"></div>`
    }
    frameHTML = frameHTML + '</div>'
  }
  this.frame.innerHTML = frameHTML

  for (let id in this.tabs) {
    let tab = this.tabs[id]
    tab.button = document.getElementById(`xet-${id}`)
    tab.button.title = tab.hover
    tab.button.addEventListener(
      'click', this.handleTabClick.bind(this, id));
    tab.frame = document.getElementById(`xet-${id}-frame`)
    if (tab.sections.length > 0) {
      for (let i = 0; i < tab.sections.length; i++) {
        let section = tab.sections[i]
        if (!section.url) {
          continue
        }
        section.content = document.getElementById(`xet-${id}-content-${i}`)
        section.urldisp = document.getElementById(`xet-${id}-url-${i}`)
      }
    } else {
      tab.content = document.getElementById(`xet-${id}-content`)
    }
  }
  let ch = document.getElementById('xet-charades')
  ch.innerHTML = `
    <div id="xet-charades-box" style="margin:16px 0;border:0">
    </div>
  `
  this.charades = document.getElementById('xet-charades-box')
  this.populateCompanag()

  this.makeExetTab()
  this.makeIndsTab(panelInnerH)
}

Exet.prototype.download = function(solved=true) {
  let html = this.getHTML(solved)
  const a = document.createElement("a");
  a.style.display = "none";
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([html], {type: "text/html"})
  );
  a.setAttribute("download", solved ? "exet-exolve-solved.html" :
    "exet-exolve-unsolved.html");
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

Exet.prototype.toClipboard = function(solved=true, inpid) {
  const inp = document.getElementById(inpid);

  let prefix = '' +
      '<link rel="stylesheet" type="text/css" href="https://viresh-ratnakar.github.io/exolve-m.css"/>\n' +
      '<script src="https://viresh-ratnakar.github.io/exolve-m.js">\n' +
      '<\/script>\n' +
      '<div id="exolve">\n' +
      '<\/div>\n' +
      '<script>\n' +
      '  createExolve(`\n';
  let suffix = '' +
      '  `);\n' +
      '<\/script>\n'
  inp.value = prefix + this.getExolve('', false, solved) + suffix

  inp.select();
  inp.setSelectionRange(0, 99999);
  document.execCommand("copy");
  setTimeout(() => {
    inp.value = ''
    exetModals.hide()
  }, 1000);
}

Exet.prototype.dotPuzCksum = function(uint8array, offset, len, cksum) {
  for (let i = 0; i < len; i++) {
    if (cksum & 0x0001) {
      cksum = (cksum >> 1) | 0x8000;
    } else {
      cksum = cksum >> 1;
    }
    cksum += uint8array[offset + i]
    cksum = cksum & 0xffff
  }
  return cksum;
}

Exet.prototype.dotPuzShort = function(buffer, offset, shortval) {
  buffer[offset] = shortval & 0xFF
  buffer[offset + 1] = shortval >> 8
}

Exet.prototype.getDotPuz = function() {
  // Generously estimate length of the buffer needed.
  let exolve = this.getExolve();
  let estDotPuzLen = 2 * (1000 + exolve.length)
  let buffer = new Uint8Array(estDotPuzLen);
  let offset = 0;

  let encoder = new TextEncoder("utf-8")

  offset = 0x02
  let fileMagic = encoder.encode("ACROSS&DOWN")
  for (let x of fileMagic) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  offset = 0x18
  let ver = encoder.encode("1.3")
  for (let x of ver) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  offset = 0x2c
  buffer[offset++] = this.puz.gridWidth
  buffer[offset++] = this.puz.gridHeight

  this.dotPuzShort(buffer, 0x2E, this.puz.allClueIndices.length)
  buffer[0x30] = 1  // Unknown bitmask

  let numCells = this.puz.gridWidth * this.puz.gridHeight;

  let solution = ''
  let playerState = ''
  let orderedClueIndices = []
  let circleLocs = []
  for (let i = 0; i < this.puz.gridHeight; i++) {
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (gridCell.hasBarAfter || gridCell.hasBarUnder) {
        alert('This puzzle has barred cells and cannot be saved .PUZ');
        return null
      }
      if (!gridCell.isLight) {
        solution = solution + '.'
        playerState = playerState + '.'
      } else {
        solution = solution + (gridCell.currLetter != '0' ?
          gridCell.currLetter : '?')
        playerState = playerState + '-'
        if (gridCell.startsAcrossClue) {
          orderedClueIndices.push('A' + gridCell.startsClueLabel)
        }
        if (gridCell.startsDownClue) {
          orderedClueIndices.push('D' + gridCell.startsClueLabel)
        }
        if (gridCell.hasCircle) {
          circleLocs.push((i * this.puz.gridWidth) + j)
        }
      }
    }
  }
  if (this.puz.allClueIndices.length != orderedClueIndices.length) {
    alert('This puzzle has clue types that cannot be saved as .PUZ');
    return null
  }
  solution = encoder.encode(solution)
  playerState = encoder.encode(playerState)

  offset = 0x34
  for (let x of solution) {
    buffer[offset++] = x
  }
  for (let x of playerState) {
    buffer[offset++] = x
  }

  let titleOffset = offset
  let utf8Title = encoder.encode(this.puz.title)
  for (let x of utf8Title) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  let setterOffset = offset
  let utf8Setter = encoder.encode(this.puz.setter)
  for (let x of utf8Setter) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  let copyrightOffset = offset
  let utf8Copyright = encoder.encode(this.puz.copyright)
  for (let x of utf8Copyright) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  let clueOffsets = []
  let clueLens = []
  for (let ci of orderedClueIndices) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) {
      alert('This puzzle has linked clues and cannot be saved as .PUZ');
      return null
    }
    let utf8Clue = encoder.encode(theClue.clueSpan.innerText.replace(/\s+/g,' ').trim())
    clueOffsets.push(offset)
    clueLens.push(utf8Clue.length)
    for (let x of utf8Clue) {
      buffer[offset++] = x
    }
    buffer[offset++] = 0
  }
  // Empty Notes section:
  buffer[offset++] = 0

  let gextOffset = -1
  if (circleLocs.length > 0) {
    gextOffset = offset
    let secName = "GEXT"
    for (let x of secName) {
      buffer[offset++] = x
    }
    this.dotPuzShort(buffer, offset, numCells);
    offset += 4
    for (let loc of circleLocs) {
      buffer[offset + loc] = 0x80
    }
    offset += numCells
    buffer[offset++] = 0
    let c_gext = this.dotPuzCksum(buffer, gextOffset + 8, numCells, 0);
    this.dotPuzShort(buffer, gextOffset + 6, c_gext);
  }

  // Need to fill checksums
  let c_cib = this.dotPuzCksum(buffer, 0x2C, 8, 0);
  this.dotPuzShort(buffer, 0x0E, c_cib);

  let cksum = c_cib;
  cksum = this.dotPuzCksum(buffer, 0x34, numCells, cksum);
  cksum = this.dotPuzCksum(buffer, 0x34 + numCells, numCells, cksum);

  if (utf8Title.length > 0) {
    cksum = this.dotPuzCksum(buffer, titleOffset, utf8Title.length + 1, cksum);
  }
  if (utf8Setter.length > 0) {
    cksum = this.dotPuzCksum(buffer, setterOffset, utf8Setter.length + 1, cksum);
  }
  if (utf8Copyright.length > 0) {
    cksum = this.dotPuzCksum(buffer, copyrightOffset, utf8Copyright.length + 1, cksum);
  }

  for (let i = 0; i < orderedClueIndices.length; i++) {
    cksum = this.dotPuzCksum(buffer, clueOffsets[i], clueLens[i], cksum);
  }
  this.dotPuzShort(buffer, 0x00, cksum);

  let c_sol = this.dotPuzCksum(buffer, 0x34, numCells, 0);
  let c_grid = this.dotPuzCksum(buffer, 0x34 + numCells, numCells, 0);
  let c_part = 0;
  if (utf8Title.length > 0) {
    c_part = this.dotPuzCksum(buffer, titleOffset, utf8Title.length + 1, c_part);
  }
  if (utf8Setter.length > 0) {
    c_part = this.dotPuzCksum(buffer, setterOffset, utf8Setter.length + 1, c_part);
  }
  if (utf8Copyright.length > 0) {
    c_part = this.dotPuzCksum(buffer, copyrightOffset, utf8Copyright.length + 1, c_part);
  }
  for (let i = 0; i < orderedClueIndices.length; i++) {
    c_part = this.dotPuzCksum(buffer, clueOffsets[i], clueLens[i], c_part);
  }

  buffer[0x10] = 0x49 ^ (c_cib & 0xFF);
  buffer[0x11] = 0x43 ^ (c_sol & 0xFF);
  buffer[0x12] = 0x48 ^ (c_grid & 0xFF);
  buffer[0x13] = 0x45 ^ (c_part & 0xFF);

  buffer[0x14] = 0x41 ^ ((c_cib & 0xFF00) >> 8);
  buffer[0x15] = 0x54 ^ ((c_sol & 0xFF00) >> 8);
  buffer[0x16] = 0x45 ^ ((c_grid & 0xFF00) >> 8);
  buffer[0x17] = 0x44 ^ ((c_part & 0xFF00) >> 8); 

  return buffer.slice(0, offset)
}

Exet.prototype.downloadDotPuz = function() {
  let dotPuz = this.getDotPuz()
  if (!dotPuz) {
    exetModals.hide()
    return
  }
  const a = document.createElement("a");
  a.style.display = "none";
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([dotPuz], {type: "application/x-crossword"})
  );
  a.setAttribute("download", "exet.puz");
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

Exet.prototype.makeWordParam = function(s) {
  return s.toLowerCase()
}

Exet.prototype.makeCharadeParam = function(s) {
  return s.toLowerCase().replace(/\?/g, '').replace(/[^a-z]/g, '')
}

Exet.prototype.makeAnagramParam = function(s) {
  s = this.makeCharadeParam(s)
  return "<" + s + ">"
}

Exet.prototype.makeCAParam = function(s) {
  return s.toLowerCase().replace(/\?/g, '')
}

Exet.prototype.makeAlternationParam = function(s) {
  s = this.makeCharadeParam(s)
  let out = 'A%3F'
  for (let c of s) {
    out = out + c + 'A'
  }
  return out + '%3F'
}

Exet.prototype.makeHiddenParam = function(s) {
  s = this.makeCharadeParam(s)
  if (s.length < 2) return s
  return 'A*"A' + s.charAt(0) + '"' + s.substr(1, s.length - 2) + '"' + s.charAt(s.length - 1) + 'A"A*'
}

Exet.prototype.makeRevHiddenParam = function(s) {
  s = this.makeCharadeParam(s)
  if (s.length < 2) return s
  let sr = ''
  for (let i = s.length - 1; i >= 0; i--) {
    sr = sr + s.charAt(i)
  }
  return 'A*"A' + sr.charAt(0) + '"' + sr.substr(1, sr.length - 2) + '"' + sr.charAt(sr.length - 1) + 'A"A*'
}

Exet.prototype.handleTabClick = function(id) {
  let tab = this.tabs[id]
  if (!tab) {
    return
  }
  this.currTab = id
  for (let x in this.tabs) {
    let xtab = this.tabs[x]
    xtab.frame.style.display = "none"
    xtab.button.className = xtab.button.className.replace(" active", "");
  }

  tab.frame.style.display = "block";
  tab.button.className += " active";

  if (id == "exet") {
    return
  }
  if (id == "inds") {
    this.indsTabNav();
    return
  }

  let ci = this.puz.currClueIndex
  if (!ci) {
    return
  }
  let words = this.puz.clues[ci].solution
  if (!words) {
    return
  }
  for (let i = 0; i < tab.sections.length; i++) {
    let section = tab.sections[i]
    let wordParam = section.maker ? section.maker.call(this, words) : this.makeWordParam(words)
    if (section.url && (!section.param || section.param != wordParam)) {
      section.param = wordParam
      let url = section.url + wordParam
      section.content.src = url
      section.urldisp.innerText = url
      section.urldisp.href = url
    } else if (section.id == 'xet-charades' && section.param != wordParam) {
      section.param = wordParam
      this.updateCharades(wordParam)
    } else if (section.id == 'xet-companag' && section.param != wordParam) {
      section.param = wordParam
      this.caFodder.value = wordParam
      this.caAnagram.value = ''
      this.updateCA()
    }
  }
}

Exet.prototype.navDarkness = function(row, col) {
  darkness = this.puz.grid[row][col].darkness
  if (!darkness) {
    return
  }
  this.puz.deactivateCurrCell()
  this.puz.currRow = row
  this.puz.currCol = col

  darkness.style.fill = this.puz.colorScheme['caret']

  let cellLeft = this.puz.cellLeftPos(col, this.puz.GRIDLINE)
  let cellTop = this.puz.cellTopPos(row, this.puz.GRIDLINE)
  this.puz.gridInputWrapper.style.left = '' + cellLeft + 'px'
  this.puz.gridInputWrapper.style.top = '' + cellTop + 'px'
  this.puz.gridInput.value = ''
  this.puz.gridInputRarr.style.display = 'none'
  this.puz.gridInputDarr.style.display = 'none'
  this.puz.gridInputWrapper.style.display = ''
  this.puz.gridInput.focus()
}

Exet.prototype.arrowNav = function(key) {
  let row = this.puz.currRow
  let col = this.puz.currCol
  let useSaved = false
  if (key == 39) {
    // right arrow
    col = col + 1
    if (col >= this.puz.gridWidth) {
      useSaved = true
    }
  } else if (key == 37) {
    // left arrow
    col = col - 1
    if (col < 0) {
      useSaved = true
    }
  } else if (key == 40) {
    // down arrow
    row = row + 1
    if (row >= this.puz.gridHeight) {
      useSaved = true
    }
  } else if (key == 38) {
    // up arrow
    row = row - 1
    if (row < 0) {
      useSaved = true
    }
  }
  if (useSaved || this.puz.grid[row][col].isLight) {
    return this.hkuiSaved.apply(exet.puz, arguments);
  }
  this.navDarkness(row, col)
  return true
}

Exet.prototype.scrollCluesIfNeeded = function() {
  let clue = this.puz.clues[this.puz.currClueIndex]
  if (!clue) return
  let elt = clue.clueTR
  if (!elt) return
  const parPos = this.cluesPanel.getBoundingClientRect();
  if (parPos.bottom < 0) {
    return
  }
  let windowH = this.puz.getViewportHeight()
  if (!windowH || windowH <= 0) {
    return
  }
  if (parPos.top >= windowH) {
    return
  }
  const pos = elt.getBoundingClientRect();
  let ref = this.cluesPanel.firstElementChild
  if (pos.bottom < 0 || pos.bottom < parPos.top || pos.top >= windowH ||
      pos.top < parPos.top || pos.top >= parPos.bottom) {
    this.cluesPanel.scrollTop = pos.top - ref.getBoundingClientRect().top
  }
}

Exet.prototype.replaceHandlers = function() {
  this.puz.cnavToInner = (function() {
    exet.cnavToInnerSaved = exet.puz.cnavToInner;
    return function() {
      let ret = exet.cnavToInnerSaved.apply(exet.puz, arguments);
      exet.scrollCluesIfNeeded()
      exet.makeClueEditable()
      exet.updateFillChoices()
      exet.startDeadendSweep(exet.puz.currClueIndex)
      exet.handleTabClick(exet.currTab)
      return ret
    };
  })();
  this.puz.activateCell = (function() {
    exet.activateCellSaved = exet.puz.activateCell;
    return function() {
      let ret = exet.activateCellSaved.apply(exet.puz, arguments);
      let gridCell = exet.puz.currCell()
      if (gridCell && !gridCell.isLight && gridCell.darkness) {
        exet.navDarkness(exet.puz.currRow, exet.puz.currCol)
      }
      return ret
    };
  })();
  this.puz.deactivateCurrCell = (function() {
    exet.dccSaved = exet.puz.deactivateCurrCell;
    return function() {
      let gridCell = exet.puz.currCell()
      if (gridCell && gridCell.darkness) {
        gridCell.darkness.style.fill = 'transparent'
      }
      exet.dccSaved.apply(exet.puz);
    };
  })();
  this.puz.handleKeyUpInner = (function() {
    exet.hkuiSaved = exet.puz.handleKeyUpInner;
    return function(key, shift=false) {
      if (key >= 37 && key <= 40) {
        return exet.arrowNav(key)
      }
      return exet.hkuiSaved.apply(exet.puz, arguments);
    };
  })();
  this.puz.updateAndSaveState = (function() {
    exet.uassSaved = exet.puz.updateAndSaveState;
    return function() {
      exet.uassSaved.apply(exet.puz);
      exet.throttledGridInput(null);
    };
  })();
}

Exet.prototype.makeClueEditable = function() {
  if (!this.puz.currClueIndex || !this.puz.currClue) {
    return
  }
  let theClue = this.puz.clues[this.puz.currClueIndex]
  if (!theClue) {
    return
  }
  let currClueText = document.getElementById(
     `${exet.puz.prefix}-curr-clue-text`)
  currClueText.innerHTML = `<span class="xet-action">Edit
      clue: </span><span
      contenteditable="true" class="xet-editable"
      id="xet-clue"></span>`
  // We make the raw clue text editable here, including any tags or
  // in-clue-anno markers (~{...}~).
  let xetClue = document.getElementById("xet-clue")
  xetClue.innerText = theClue.clue
  let handler = this.throttledClueChange.bind(this)
  xetClue.addEventListener('input', handler)

  let spacer = document.createElement('span')
  spacer.innerHTML = `<br><span class="xet-action">Edit
      optional anno: </span>`
  this.puz.currClue.appendChild(spacer)

  let inCurrAnno = document.createElement('span')
  inCurrAnno.className = 'xet-anno xet-editable'
  inCurrAnno.id = 'xet-anno'
  inCurrAnno.contentEditable = true
  inCurrAnno.innerText = theClue.anno
  this.puz.currClue.appendChild(inCurrAnno)
  inCurrAnno.addEventListener('input', handler)
  this.puz.makeCurrClueVisible()
}

Exet.prototype.throttledClueChange = function() {
  if (this.throttledClueTimer) {
    clearTimeout(this.throttledClueTimer);
  }
  this.throttledClueTimer = setTimeout(() => {
    this.handleClueChange()
    this.throttledClueTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.handleClueChange = function() {
  if (!this.puz.currClueIndex) {
    return
  }
  let currClueText = document.getElementById('xet-clue')
  if (!currClueText) {
    return
  }
  let ci = this.puz.currClueIndex
  let theClue = this.puz.clues[ci]
  if (!theClue) {
    return
  }
  let clueTR = theClue.clueTR
  if (!clueTR) {
    return
  }
  let clueSpan = theClue.clueSpan
  if (!clueSpan) {
    return
  }

  let currClueAnno = document.getElementById('xet-anno')
  if (!currClueAnno) {
    return
  }
  if (!theClue.annoSpan) {
    return
  }
  let expEnumLen = 0
  if (!theClue.parentClueIndex) {
    let linked = this.puz.getLinkedClues(ci)
    for (let lci of linked) {
      expEnumLen = expEnumLen + this.puz.clues[lci].cells.length
    }
  }
  this.stripInputLF(currClueText)
  let clue = currClueText.innerText
  let clueSansEnum = clue
  let oldEnum = ''
  let enumPos = theClue.clue.lastIndexOf('(')
  if (enumPos >= 0) {
    oldEnum = theClue.clue.substr(enumPos).trim()
  }
  let newEnum = ''
  enumPos = clue.lastIndexOf('(')
  if (enumPos >= 0) {
    newEnum = clue.substr(enumPos).trim()
    clueSansEnum = clue.substr(0, enumPos).trim()
  }
  if (this.puz.parseEnum(newEnum).enumLen != expEnumLen) {
    if (expEnumLen > 0) {
      newEnum = oldEnum || ('(' + expEnumLen + ')')
      clue = clueSansEnum + ' ' + newEnum
    } else {
      newEnum = ''
      clue = clueSansEnum
    }
    currClueText.innerText = clue
  }

  theClue.clue = clue
  this.puz.parseInClueAnnos(theClue)
  this.puz.renderClueSpan(theClue, clueSpan)

  this.stripInputLF(currClueAnno)
  theClue.anno = currClueAnno.innerText
  theClue.annoSpan.lastElementChild.innerText = currClueAnno.innerText
  this.puz.revealClueAnno(ci)

  this.puz.makeCurrClueVisible()
  if (oldEnum != newEnum) {
    if (this.handleGridInput()) {
      // throttledSaveRev() got called already
      return
    }
  }
  exetRevManager.throttledSaveRev(exetRevManager.REV_CLUE_CHANGE)
}

Exet.prototype.gridAcrossSpans = function(grid, w, row) {
  let spans = []
  let start = -1
  let len = 0
  for (let j = 0; j < w; j++) {
    if (grid[row][j].isLight) {
      if (start >= 0 && j > 0 && grid[row][j-1].isLight && !grid[row][j-1].hasBarAfter) {
        len++
      } else {
        if (len > 1) {
          spans.push([start, len])
        }
        start = j
        len = 1
      }
    } else {
      if (len > 1) {
        spans.push([start, len])
      }
      start = -1
      len = 0
    }
  }
  if (len > 1) {
    spans.push([start, len])
  }
  return spans;
}

Exet.prototype.gridDownSpans = function(grid, h, col) {
  let spans = []
  let start = -1
  let len = 0
  for (let i = 0; i < h; i++) {
    if (grid[i][col].isLight) {
      if (start >= 0 && i > 0 && grid[i-1][col].isLight && !grid[i-1][col].hasBarUnder) {
        len++
      } else {
        if (len > 1) {
          spans.push([start, len])
        }
        start = i
        len = 1
      }
    } else {
      if (len > 1) {
        spans.push([start, len])
      }
      start = -1
      len = 0
    }
  }
  if (len > 1) {
    spans.push([start, len])
  }
  return spans;
}

Exet.prototype.gridSymmetric = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      let symi = h - 1 - i
      let symj = w - 1 - j
      if (grid[i][j].isLight != grid[symi][symj].isLight) {
        return false
      }
      if (!grid[i][j].isLight) continue
      if (symj > 0 && grid[i][j].hasBarAfter != grid[symi][symj - 1].hasBarAfter) {
        return false
      }
      if (symi > 0 && grid[i][j].hasBarUnder != grid[symi - 1][symj].hasBarUnder) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridHasBlocks = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
    }
  }
}

Exet.prototype.gridHasBars = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      if (!grid[i][j].isLight) {
        continue
      }
      if (j < w - 1 && grid[i][j].hasBarAfter) {
        return true
      }
      if (i < h - 1 && grid[i][j].hasBarUnder) {
        return true
      }
    }
  }
  return false
}

Exet.prototype.gridChequeredOK = function(grid, w, h) {
  let crossers = new Array(h)
  for (let i = 0; i < h; i++) {
    crossers[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      crossers[i][j] = 0
      if (!grid[i][j].isLight) {
        continue
      }
      if ((j > 0 && grid[i][j-1].isLight && !grid[i][j-1].hasBarAfter) ||
          (j < w - 1 && grid[i][j+1].isLight && !grid[i][j].hasBarAfter)) {
        crossers[i][j]++
      }
      if ((i > 0 && grid[i-1][j].isLight && !grid[i-1][j].hasBarUnder) ||
          (i < h - 1 && grid[i+1][j].isLight && !grid[i][j].hasBarUnder)) {
        crossers[i][j]++
      }
      if (crossers[i][j] == 1 &&
          ((j > 0 && crossers[i][j-1] == 1 && !grid[i][j-1].hasBarAfter) ||
           (i > 0 && crossers[i-1][j] == 1 && !grid[i-1][j].hasBarUnder))) {
        return false
      }
    }
  }
  const minSpan = 4
  for (let i = 0; i < h; i++) {
    let spans = this.gridAcrossSpans(grid, w, i)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
      let numChecked = 0
      let numUnches = 0
      for (let j = span[0]; j < span[0] + span[1]; j++) {
        if (crossers[i][j] < 2) numUnches++
        else numChecked++
      }
      if (numUnches > numChecked + 1) {
        return false
      }
      if (numUnches == numChecked + 1 && numUnches < 5) {
        return false
      }
    }
  }
  for (let j = 0; j < w; j++) {
    let spans = this.gridDownSpans(grid, h, j)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
      let numChecked = 0
      let numUnches = 0
      for (let i = span[0]; i < span[0] + span[1]; i++) {
        if (crossers[i][j] < 2) numUnches++
        else numChecked++
      }
      if (numUnches > numChecked + 1) {
        return false
      }
      if (numUnches == numChecked + 1 && numUnches < 5) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridUnchequeredOK = function(grid, w, h) {
  let crossers = new Array(h)
  for (let i = 0; i < h; i++) {
    crossers[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      crossers[i][j] = 0
      if (!grid[i][j].isLight) {
        continue
      }
      if ((j > 0 && grid[i][j-1].isLight && !grid[i][j-1].hasBarAfter) ||
          (j < w - 1 && grid[i][j+1].isLight && !grid[i][j].hasBarAfter)) {
        crossers[i][j]++
      }
      if ((i > 0 && grid[i-1][j].isLight && !grid[i-1][j].hasBarUnder) ||
          (i < h - 1 && grid[i+1][j].isLight && !grid[i][j].hasBarUnder)) {
        crossers[i][j]++
      }
      if (crossers[i][j] < 2) {
        return false
      }
    }
  }
  const minSpan = 3
  for (let i = 0; i < h; i++) {
    let spans = this.gridAcrossSpans(grid, w, i)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
    }
  }
  for (let j = 0; j < w; j++) {
    let spans = this.gridDownSpans(grid, h, j)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridConnected = function(grid, w, h) {
  let cells = []
  let visited = new Array(h)
  for (let i = 0; i < h; i++) {
    visited[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      visited[i][j] = false
      if (grid[i][j].isLight) {
        cells.push([i,j])
      }
    }
  }
  if (cells.length == 0) return false
  let reachable = [cells[0]]
  visited[cells[0][0]][cells[0][1]] = true
  let x = 0
  while (x < reachable.length) {
    let r = reachable[x][0]
    let c = reachable[x][1]
    x++
    if (c > 0 && grid[r][c-1].isLight && !grid[r][c-1].hasBarAfter && !visited[r][c-1]) {
      visited[r][c-1] = true
      reachable.push([r,c-1])
    }
    if (c < w - 1 && grid[r][c+1].isLight && !grid[r][c].hasBarAfter && !visited[r][c+1]) {
      visited[r][c+1] = true
      reachable.push([r,c+1])
    }
    if (r > 0 && grid[r-1][c].isLight && !grid[r-1][c].hasBarUnder && !visited[r-1][c]) {
      visited[r-1][c] = true
      reachable.push([r-1,c])
    }
    if (r < h - 1 && grid[r+1][c].isLight && !grid[r][c].hasBarUnder && !visited[r+1][c]) {
      visited[r+1][c] = true
      reachable.push([r+1,c])
    }
  }
  return reachable.length == cells.length
}

// Return < 0 if randomness suggests picking nothing.
Exet.prototype.randomIndex = function(candidates) {
  if (candidates.length <= 0 || Math.random() > 0.8) return -1
  if (candidates.length == 1) {
    return 0
  }
  return Math.floor(Math.random() * candidates.length)
}

Exet.prototype.automagicBlocksInner = function(chequered, showAlerts=true) {
  const minSpan = chequered ? 4 : 3
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let wby2 = Math.ceil(w / 2)
  let h = this.puz.gridHeight
  let hby2 = Math.ceil(h / 2)
  let numCandidates = 0
  let numChanges = 0
  let rowcols = []
  let minwhby2 = Math.min(wby2, hby2)
  for (let x = 0; x < minwhby2; x++) {
    rowcols.push(["row", x])
    rowcols.push(["col", x])
  }
  for (let i = minwhby2 + 1; i < hby2; i++) {
    rowcols.push(["row", i])
  }
  for (let j = minwhby2 + 1; j < wby2; j++) {
    rowcols.push(["col", j])
  }
  for (rc of rowcols) {
    let k1 = rc[1]
    let isRow = (rc[0] == "row")
    let symk1 = w - 1 - k1
    if (isRow) {
      symk1 = h - 1 - k1
    }
    let spans = isRow ? this.gridAcrossSpans(grid, w, k1) : this.gridDownSpans(grid, h, k1)
    let candidates = []
    for (let span of spans) {
      for (let x = minSpan; x < span[1] - minSpan; x++) {
        let k2 = span[0] + x
        let symk2 = w - 1 - k2
        if (isRow) {
          symk2 = h - 1 - k2
        }
        let gridCell = isRow ? grid[k1][k2] : grid[k2][k1]
        let gridSymCell = isRow ? grid[symk1][symk2] : grid[symk2][symk1]
        if (gridCell.solution != '?' || gridSymCell.solution != '?') {
          continue
        }
        gridCell.isLight = false
        gridSymCell.isLight = false
        if (this.gridConnected(grid, w, h) &&
            ((chequered && this.gridChequeredOK(grid, w, h)) ||
             (!chequered && this.gridUnchequeredOK(grid, w, h)))) {
          candidates.push(k2)
        }
        gridCell.isLight = true
        gridSymCell.isLight = true
      }
    }
    if (candidates.length == 0) {
      continue
    }
    numCandidates += candidates.length
    let randIndex = this.randomIndex(candidates)
    if (randIndex < 0) {
      // We randomly chose not to make a change
      continue
    }
    let k2 = candidates[randIndex]
    let symk2 = w - 1 - k2
    if (isRow) {
      symk2 = h - 1 - k2
    }
    let gridCell = isRow ? grid[k1][k2] : grid[k2][k1]
    let gridSymCell = isRow ? grid[symk1][symk2] : grid[symk2][symk1]
    gridCell.isLight = false
    gridSymCell.isLight = false
    numChanges += 2
  }
  if (numChanges > 0) {
    this.killInvalidatedClues()
  } else {
    if (showAlerts) {
      if (numCandidates == 0) {
        alert('Add automagic blocks: found no further candidate cells for turning into blocks')
      } else {
        alert('Add automagic blocks: found some candidate cells for turning into blocks, but random numbers favoured no changes')
      }
    }
  }
  return numChanges > 0;
}

Exet.prototype.automagicBlocks = function(showAlerts=true) {
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let h = this.puz.gridHeight
  if (this.gridHasBars(grid, w, h)) {
    if (showAlerts) alert('Cannot add automagic blocks when the grid has barred cells');
    return false
  }
  if (!this.gridConnected(grid, w, h)) {
    if (showAlerts) alert('Cannot add automagic blocks when the grid cells are not fully connected');
    return false
  }
  if (!this.gridSymmetric(grid, w, h)) {
    if (showAlerts) alert('Cannot add automagic blocks when the grid is not fully symmetric');
    return false
  }
  if (this.gridUnchequeredOK(grid, w, h)) {
    return this.automagicBlocksInner(false, showAlerts)
  } else  if (this.gridChequeredOK(grid, w, h)) {
    return this.automagicBlocksInner(true, showAlerts)
  } else {
    if (showAlerts) alert('Cannot add automagic blocks to the current grid');
    return false
  }
  return false
}

Exet.prototype.setScore = function(fillState) {
  fillState.scoreF = 0
  fillState.scoreV = 0
  fillState.score = 0

  // Treat viability/5 = independent probability.
  const log5 = 1.6094379124341003
  fillState.unfilled = []
  fillState.lettersUsed = {}
  let numLights = 0
  for (let i = 0; i < fillState.gridHeight; i++) {
    for (let j = 0; j < fillState.gridWidth; j++) {
      let gridCell = fillState.grid[i][j]
      if (!gridCell.isLight) {
        continue
      }
      numLights++
      if (gridCell.solution != '?' || gridCell.currLetter != '?') {
        let c = gridCell.solution
        if (c == '?') c = gridCell.currLetter
        console.assert(c, i, j, gridCell)
        fillState.lettersUsed[c] = true
        continue
      }
      if (gridCell.viability <= 0) {
        fillState.unfilled.push([i, j, gridCell.viability]);
        fillState.scoreV = - Number.MAX_VALUE
        fillState.score = fillState.scoreV
        fillState.viable = false
        return
      }
      fillState.scoreV += Math.log(gridCell.viability)
      fillState.unfilled.push([i, j, gridCell.viability]);
    }
  }
  fillState.numLettersUsed = Object.keys(fillState.lettersUsed).length
  if (numLights == 0) {
    return
  }
  fillState.unfilled.sort((a, b) => a[2] - b[2]);
  fillState.scoreV /= 100
  fillState.score += fillState.scoreV

  fillState.scoreF = 15 * (numLights - fillState.unfilled.length) / 100
  fillState.score += fillState.scoreF
}

Exet.prototype.getAutofillBase = function() {
  let fillState = new ExetFillState(this.fillState)
  fillState.delta = []
  fillState.preflexUsed = {}
  fillState.numPreflexUsed = 0
  this.setScore(fillState)
  return fillState
}

Exet.prototype.isFull = function(candidate) {
  return candidate.unfilled.length == 0
}

Exet.prototype.addToBeam = function(candidate) {
  // this.autofill.candidates[] is sorted on increasing score (last entry is the best)
  if (this.autofill.candidates.length == 0) {
    this.autofill.candidates.push(candidate)
    return
  }
  if (this.autofill.candidates.length >= this.autofill.beamWidth) {
    if (candidate.score < this.autofill.candidates[0].score) {
      return
    } else if (candidate.score == this.autofill.candidates[0].score) {
      if (Math.random() >= 0.5) {
        this.autofill.candidates[0] = candidate;
      }
      return
    }
  }
  let idx = 0;
  while (idx < this.autofill.candidates.length &&
         candidate.score > this.autofill.candidates[idx].score) {
    idx++
  }
  let start = this.autofill.candidates.length == this.autofill.beamWidth ? 1 : 0
  let newbeam = this.autofill.candidates.slice(start, idx)
  newbeam.push(candidate)
  this.autofill.candidates = newbeam.concat(this.autofill.candidates.slice(idx))
}

Exet.prototype.beamSearchStep = function() {
  if (this.autofill.throttledTimer) {
    clearTimeout(this.autofill.throttledTimer)
  }
  if (this.autofill.candidates.length == 0) {
    return
  }
  this.autofill.throttledTimer = null;
  let candidate = this.autofill.candidates.pop()
  this.autofill.step++
  this.autofill.stepSpan.innerText = this.autofill.step
  this.addAutofillChildren(candidate)
  this.autofill.currBeamSpan.innerText = this.autofill.candidates.length

  if (this.autofill.candidates.length > 0) {
    let index = this.autofill.candidates.length - 1
    let best = this.autofill.candidates[index];
    this.autofill.preflexUsedSpan.innerText = best.numPreflexUsed
    this.autofill.pangramSpan.innerText = best.numLettersUsed
    this.autofill.scoreSpan.innerText = best.score.toFixed(2)
    this.autofill.scoreVSpan.innerText = best.scoreV.toFixed(2)
    this.autofill.scoreFSpan.innerText = best.scoreF.toFixed(2)
    this.updateAutofill(best)

    if (this.isFull(best)) {
      this.autofill.accept.disabled = false
      this.autofill.clear.disabled = false
      this.resetAutofill('Succeeded!')
    } else {
      this.autofill.throttledTimer = setTimeout(() => {
        exet.beamSearchStep();
      }, this.autofill.lag);
    }
  } else {
    this.autofill.accept.disabled = false
    this.autofill.clear.disabled = false
    this.resetAutofill('Failed')
  }
}

Exet.prototype.shuffle = function(arr) {
  // Fisher-Yates shuffle of arr[]
  for (let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

Exet.prototype.letterRarity = function(c) {
  if (c == 'Z' || c == 'J' || c == 'Q') return 0
  if (c == 'B' || c == 'V' || c == 'X') return 1
  if (c == 'K' || c == 'Y') return 2
  return 3
}

Exet.prototype.addAutofillChildren = function(candidate) {
  if (!candidate || !candidate.unfilled || candidate.unfilled.length == 0) {
    return
  }

  let constrainerLimit = 2000

  if (this.autofill.priorityCluesIndex < this.autofill.priorityClues.length) {
    let ciToTry = this.autofill.priorityClues[this.autofill.priorityCluesIndex++]
    if (this.autofill.priorityCluesIndex == this.autofill.priorityClues.length) {
      // Recover, if all preferred fills were bad choices
      this.addToBeam(this.autofill.base)
    }
    let ci = ciToTry[0]
    let toTry = ciToTry[1]
    let theClue = candidate.clues[ci]
    if (!theClue || !theClue.lChoices || theClue.lChoices.length <= 1) {
      // Move to the next priorityClue
      this.addAutofillChildren(candidate)
      return
    }
    let numChoices = theClue.lChoices.length
    let toTryAndViable = []
    let numToTry = Object.keys(toTry).length
    for (let i = 0; i < numChoices && numToTry > toTryAndViable.length; i++) {
      let idx = theClue.lChoices[i]
      if (toTry[idx]) {
        toTryAndViable.push(idx)
      }
    }
    if (toTryAndViable.length == 0) {
      // Move to the next priorityClue
      this.addAutofillChildren(candidate)
      return
    }
    let cells = theClue.cells
    for (let lchoice of toTryAndViable) {
      let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
      let child = new ExetFillState(candidate)
      child.clues[ci].lChoices = [lchoice]
      child.delta = candidate.delta.slice()
      for (let j = 0; j < cells.length; j++) {
        let row = cells[j][0]
        let col = cells[j][1]
        let childCell = child.grid[row][col]
        let c = key.charAt(j).toUpperCase()
        childCell.cChoices = {}
        childCell.cChoices[c] = true
        childCell.currLetter = c
        child.delta.push([row, col, c])
      }
      this.refineLightChoices(child, constrainerLimit)
      if (child.viable) {
        this.setScore(child)
        this.addToBeam(child)
      }
    }
    return
  }

  // Pick a random offset from 0,1,2,3
  let cellIndex = Math.floor(Math.random() * Math.min(candidate.unfilled.length, 4))
  let row = candidate.unfilled[cellIndex][0]
  let col = candidate.unfilled[cellIndex][1]
  let cell = candidate.grid[row][col]

  let choices = Object.keys(cell.cChoices)
  if (this.autofill.boostPangram) {
    // Try unused and rare letters first
    let choices1 = []
    let choices2 = []
    for (let c in cell.cChoices) {
      if (!candidate.lettersUsed[c]) choices1.push(c)
      else choices2.push(c)
    }
    choices1.sort((c1, c2) => this.letterRarity(c1) - this.letterRarity(c2));
    choices = choices1.concat(choices2)
  }
  for (let c of choices) {
    let child = new ExetFillState(candidate)
    let childCell = child.grid[row][col]
    childCell.cChoices = {}
    childCell.cChoices[c] = true
    childCell.currLetter = c
    child.delta = candidate.delta.slice()
    child.delta.push([row, col, c])
    this.refineLightChoices(child, constrainerLimit)
    if (child.viable) {
      this.setScore(child)
      this.addToBeam(child)
    }
  }
}

Exet.prototype.getAutofillPriorityClues = function() {
  let pclues = []
  if (this.preflex.length == 0) {
    return pclues
  }
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (theClue.solution.indexOf('?') < 0) continue
    if (this.preflexByLen[theClue.enumLen]) {
      let toTry = {}
      for (let idx of this.preflexByLen[theClue.enumLen]) {
        toTry[idx] = true
      }
      pclues.push([ci, toTry])
    }
  }
  this.shuffle(pclues)
  return pclues
}

Exet.prototype.updateAutofillPreflex = function() {
  this.autofill.preflexTotalSpan.innerText = this.preflex.length
  this.autofill.unpreflexTotalSpan.innerText = Object.keys(this.unpreflex).length
  this.autofill.minpopSpan.innerText = this.minpop
  this.autofill.indexMinpopSpan.innerText = this.indexMinpop
  this.autofill.properNounsSpan.innerText = this.noProperNouns ? "disallowed" : "allowed"
}

Exet.prototype.startstopAutofill = function() {
  if (!this.autofill.running) {
    if (this.puz.numCellsToFill == this.puz.numCellsFilled) {
      alert('The grid is already full')
      return
    }
    if (this.autofill.candidates.length == 0) {
      let candidate = this.getAutofillBase()
      if (!candidate.viable) {
        alert("Autofill will not work on the current grid. Perhaps retry after clearing some constraining lights?")
        return
      }
      this.autofill.base = candidate
      this.autofill.candidates.push(candidate)
      this.autofill.currBeamSpan.innerText = this.autofill.candidates.length
      this.autofill.priorityClues = this.getAutofillPriorityClues()
      this.autofill.priorityCluesIndex = 0
    }

    if (this.viabilityUpdateTimer) {
      clearTimeout(this.viabilityUpdateTimer);
      this.viabilityUpdateTimer = null;
    }

    this.updateAutofillPreflex()
    this.autofill.running = true
    this.autofill.status = 'Running'
    this.autofill.accept.disabled = true
    this.autofill.clear.disabled = true
    this.autofill.statusSpan.innerText = this.autofill.status
    this.sweepIndicator.className = 'xet-sweeping-animated'
    this.autofill.startstop.innerText = 'Pause'
    this.autofill.startstop.className = 'xlv-button xet-pink-button'
    let beamWidth = parseInt(this.autofill.beamWidthInput.value)
    if (isNaN(beamWidth) || beamWidth <= 0) {
      this.autofill.beamWidthInput.value = this.autofill.beamWidth
    } else {
      this.autofill.beamWidth = beamWidth
    }
    this.autofill.boostPangram = this.autofill.pangramInput.checked
    if (this.autofill.throttledTimer) {
      clearTimeout(this.autofill.throttledTimer)
    }
    this.autofill.throttledTimer = setTimeout(() => {
      this.beamSearchStep();
    }, this.autofill.lag);
  } else {
    this.autofill.running = false
    this.updateSweepInd()
    this.autofill.startstop.innerText = 'Start'
    this.autofill.startstop.className = 'xlv-button'
    this.autofill.status = 'Stopped'
    this.autofill.accept.disabled = false
    this.autofill.clear.disabled = false
    this.autofill.statusSpan.innerText = this.autofill.status
    clearTimeout(this.autofill.throttledTimer)
    this.autofill.throttledTimer = null
  }
}

Exet.prototype.resetAutofill = function(status) {
  this.autofill.candidates = []
  this.autofill.step = 0
  this.updateAutofillPreflex()
  if (!this.autofill.running) {
    return
  }
  if (this.autofill.throttledTimer) {
    clearTimeout(this.autofill.throttledTimer)
    this.autofill.throttledTimer = null
  }
  this.autofill.status = status
  this.autofill.statusSpan.innerText = status
  this.autofill.running = false
  this.updateSweepInd()
  this.autofill.startstop.innerText = 'Start'
  this.autofill.startstop.className = 'xlv-button'
}

Exet.prototype.updateAutofill = function(candidate) {
  console.assert(this.autofill.base, this.autofill)
  this.fillState = new ExetFillState(this.autofill.base)
  // Only use suggestions from full lights
  for (let ci in candidate.clues) {
    let lChoices = candidate.clues[ci].lChoices
    if (lChoices.length != 1) {
      continue
    }
    let theClue = this.fillState.clues[ci]
    console.assert(theClue, ci)
    theClue.lChoices = lChoices
    for (let c of theClue.cells) {
      let row = c[0]
      let col = c[1]
      this.fillState.grid[row][col].cChoices =
          candidate.grid[row][col].cChoices
    }
  }
  this.updateViablots()
}

Exet.prototype.initAutofill = function() {
  if (!this.autofill) {
    this.autofill = {
      candidates: [],
      beamWidth: 64,
      step: 0,
      running: false,
      throttledTimer: null,
      lag: 200,
      status: 'None',
      boostPangram: false,
    }
  }
  this.autofill.clear = document.getElementById("xet-autofill-clear")
  this.autofill.clear.disabled = true
  this.autofill.clear.addEventListener('click', e => {
    this.autofill.accept.disabled = true
    this.autofill.clear.disabled = true
    exet.resetAutofill('Cleared')
    exet.resetViability()
  })
  this.autofill.accept = document.getElementById("xet-autofill-accept")
  this.autofill.accept.disabled = true
  this.autofill.accept.addEventListener('click', e => {
    this.autofill.accept.disabled = true
    this.autofill.clear.disabled = true
    exet.handleKeyDown('=')
  })
  this.autofill.startstop = document.getElementById("xet-autofill-startstop")
  if (this.autofill.running) {
    this.autofill.startstop.innerText = 'Pause'
    this.autofill.startstop.className = 'xlv-button xet-pink-button'
  }
  this.autofill.startstop.addEventListener('click', this.startstopAutofill.bind(this))

  this.autofill.beamWidthInput = document.getElementById('xet-autofill-max-beam')
  this.autofill.beamWidthInput.value = this.autofill.beamWidth

  this.autofill.pangramInput = document.getElementById('xet-autofill-boost-pangram')
  this.autofill.pangramInput.checked = this.autofill.boostPangram

  this.autofill.stepSpan = document.getElementById('xet-autofill-step')
  this.autofill.stepSpan.innerText = this.autofill.step

  this.autofill.statusSpan = document.getElementById('xet-autofill-status')
  this.autofill.statusSpan.innerText = this.autofill.status

  this.autofill.currBeamSpan = document.getElementById('xet-autofill-curr-beam')
  this.autofill.currBeamSpan.innerText = this.autofill.candidates.length

  this.autofill.scoreSpan = document.getElementById('xet-autofill-score')
  this.autofill.scoreVSpan = document.getElementById('xet-autofill-score-v')
  this.autofill.scoreFSpan = document.getElementById('xet-autofill-score-f')

  this.autofill.preflexTotalSpan = document.getElementById('xet-autofill-preflex-total')
  this.autofill.preflexUsedSpan = document.getElementById('xet-autofill-preflex-used')
  this.autofill.unpreflexTotalSpan = document.getElementById('xet-autofill-unpreflex-total')
  this.autofill.minpopSpan = document.getElementById('xet-autofill-minpop')
  this.autofill.indexMinpopSpan = document.getElementById('xet-autofill-index-minpop')
  this.autofill.properNounsSpan = document.getElementById('xet-autofill-proper-nouns')
  this.autofill.pangramSpan = document.getElementById('xet-autofill-pangram')
  if (this.autofill.candidates.length > 0) {
    let candidate = this.autofill.candidates[this.autofill.candidates.length - 1]
    this.autofill.preflexUsedSpan.innerText = candidate.numPreflexUsed
    this.autofill.pangramSpan.innerText = candidate.numLettersUsed
    this.autofill.scoreSpan.innerText = candidate.score.toFixed(2)
    this.autofill.scoreVSpan.innerText = candidate.scoreV.toFixed(2)
    this.autofill.scoreFSpan.innerText = candidate.scoreF.toFixed(2)
  }
}

// Can be called with e as an event or as a key directly
Exet.prototype.handleKeyDown = function(e) {
  let key = e.key || e
  if (key == '=') {
    if (this.acceptAll()) {
      this.handleGridInput(exetRevManager.REV_AUTOFILL_GRIDFILL_CHANGE)
    }
    return
  }
  let gridCell = this.puz.currCell()
  if (!gridCell) {
    return
  }
  let revType = exetRevManager.REV_GRID_CHANGE
  let row = this.puz.currRow
  let col = this.puz.currCol
  if (key == '.') {
    gridCell.isLight = !gridCell.isLight
    let symRow = this.puz.gridHeight - 1 - row
    let symCol = this.puz.gridWidth - 1 - col
    let symCell = this.puz.grid[symRow][symCol]
    symCell.isLight = gridCell.isLight
    this.killInvalidatedClues()
  } else if (key == '|') {
    if (col >= this.gridWidth - 1) {
      return
    }
    gridCell.hasBarAfter = !gridCell.hasBarAfter
    let symRow = this.puz.gridHeight - 1 - row
    let symCol = this.puz.gridWidth - 2 - col
    let symCell = this.puz.grid[symRow][symCol]
    symCell.hasBarAfter = gridCell.hasBarAfter
    this.killInvalidatedClues()
  } else if (key == '_') {
    if (row >= this.gridHeight - 1) {
      return
    }
    gridCell.hasBarUnder = !gridCell.hasBarUnder
    let symRow = this.puz.gridHeight - 2 - row
    let symCol = this.puz.gridWidth - 1 - col
    let symCell = this.puz.grid[symRow][symCol]
    symCell.hasBarUnder = gridCell.hasBarUnder
    this.killInvalidatedClues()
  } else if (key == '#') {
    if (!this.automagicBlocks()) {
      return
    }
  } else if (key == '!') {
    gridCell.prefill = !gridCell.prefill
    revType = exetRevManager.REV_METADATA_CHANGE
  } else if (key == '@') {
    gridCell.hasCircle = !gridCell.hasCircle
    revType = exetRevManager.REV_METADATA_CHANGE
  } else {
    return
  }
  this.updatePuzzle(revType)
}

Exet.prototype.throttledGridInput = function(e) {
  if (this.throttledGridTimer) {
    clearTimeout(this.throttledGridTimer);
  }
  this.throttledGridTimer = setTimeout(() => {
    this.handleGridInput()
    this.throttledGridTimer = null;
  }, this.inputLagMS);
}

// Thie will be called after Exolve's handleGridInput has done its thing.
Exet.prototype.handleGridInput = function(revType=null) {
  let needsUpdate = false
  for (let row = 0; row < this.puz.gridHeight; row++) {
    for (let col = 0; col < this.puz.gridWidth; col++) {
      let gridCell = this.puz.grid[row][col]
        if (!gridCell.isLight) {
          continue
        }
        let newSol = (gridCell.currLetter != '0' ?  gridCell.currLetter : '?')
        if (gridCell.solution != newSol) {
          gridCell.solution = newSol
          needsUpdate = true
        }
        if (gridCell.currLetter != '0' && gridCell.currLetter != '?' &&
            gridCell.viablot) {
          gridCell.viablot.style.fill = 'transparent'
        }
     }
  }
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    let oldPH = theClue.placeholder
    let oldSol = theClue.solution
    theClue.placeholder = ''
    theClue.solution = ''
    let enumPos = theClue.clue.lastIndexOf('(')
    if (enumPos >= 0) {
      theClue.placeholder = this.puz.parseEnum(
          theClue.clue.substr(enumPos)).placeholder
    }
    this.puz.setClueSolution(ci)
    if (theClue.placeholder != oldPH || theClue.solution != oldSol) {
      needsUpdate = true
    }
  }
  if (needsUpdate) {
    if (!revType) revType = exetRevManager.REV_GRIDFILL_CHANGE
    this.updatePuzzle(revType)
  }
  return needsUpdate
}

Exet.prototype.killInvalidatedClues = function(row, col) {
  let tempId = this.puz.id + '-temp'
  let specs = this.getExolve(tempId, true)
  document.getElementById("xet-temp").innerHTML = ''
  let newPuz = new Exolve(specs, "xet-temp", null, false)
  for (let ci in this.puz.clues) {
    if (!newPuz.clues[ci] ||
        !newPuz.sameCells(newPuz.clues[ci].cells, this.puz.clues[ci].cells)) {
      delete this.puz.clues[ci]
    }
  }
  document.getElementById("xet-temp").innerHTML = ''
  delete exolvePuzzles[tempId]
}

Exet.prototype.makeExolve = function(specs) {
  let xlvFrame = document.getElementById('xet-xlv-frame')
  xlvFrame.innerHTML = ''
  if (this.puz) {
    delete exolvePuzzles[this.puz.id]
  }
  try {
    let ptemp = new Exolve(specs, 'xet-xlv-frame', this.setPuzzle.bind(this), false)
  } catch (err) {
    this.puz = null
    alert('Could not create/parse Exolve puzzle. Please reload and retry. The JavaScript console might show some diagnostic messages.')
    console.log('Could not parse Exolve specs:')
    console.log(specs)
    console.log('Error thrown was:')
    console.log(err)
  }

  if (!this.puz) {
    return
  }

  this.handleTabClick(this.currTab);
  let exetState = window.localStorage.getItem(exetRevManager.SPECIAL_KEY)
  if (!exetState) {
    exetState = {}
  } else {
    exetState = JSON.parse(exetState)
  }
  exetState.lastId = this.puz.id
  exetRevManager.saveLocal(exetRevManager.SPECIAL_KEY, JSON.stringify(exetState))
}

Exet.prototype.clearCurr = function() {
  if (!this.puz) return
  exet.puz.clearCurr()
  ci = this.puz.currClueIndex
  this.puz.clues[ci].clue = ''
  this.puz.clues[ci].solution = ''
  this.puz.clues[ci].anno = ''
  let lChoices = this.fillState.clues[ci].lChoices
  this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
}

Exet.prototype.clearAll = function() {
  if (!this.puz) return
  if (exet.puz.clearAll()) {
    for (let ci in this.puz.clues) {
      this.puz.clues[ci].clue = ''
      this.puz.clues[ci].solution = ''
      this.puz.clues[ci].anno = ''
    }
    this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
  }
}

Exet.prototype.updatePuzzle = function(revType=0) {
  if (revType <= exetRevManager.REV_GRIDFILL_CHANGE &&
      revType != exetRevManager.REV_AUTOFILL_GRIDFILL_CHANGE) {
    this.resetAutofill('Aborted')
  }
  let row = this.puz.currRow
  let col = this.puz.currCol
  let dir = this.puz.currDir
  let scratch = this.puz.scratchPad.value
  this.savedIndsSelect = this.indsSelect ? this.indsSelect.value : ''

  let exolve = this.getExolve()
  this.makeExolve(exolve)

  this.puz.currDir = dir
  this.puz.currRow = row
  this.puz.currCol = col
  this.puz.scratchPad.value = scratch
  if (this.puz.currCellIsValid()) {
    if (this.puz.grid[row][col].isLight) {
      this.puz.activateCell(row, col)
    } else {
      this.navDarkness(row, col)
    }
  }
  if (revType > 0) {
    exetRevManager.throttledSaveRev(revType)
  }
}

Exet.prototype.getGrid = function(solved=true) {
  if (!this.puz) {
    return ''
  }
  let grid = ''
  for (let i = 0; i < this.puz.gridHeight; i++) {
    let gridRow = '    '
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight) {
        gridRow = gridRow + '.   '
      } else {
        gridRow = gridRow + (gridCell.currLetter != '0' ?
                             (solved ? gridCell.currLetter : '0') : '?')
        gridRow  = gridRow + (gridCell.hasCircle ? '@' : ' ')
        gridRow  = gridRow + (gridCell.prefill ? '!' : ' ')
        gridRow  = gridRow + (gridCell.hasBarAfter && gridCell.hasBarUnder ?
                              '+' : (gridCell.hasBarAfter ?
                              '|' : (gridCell.hasBarUnder ? '_' : ' ')))
      }
    }
    grid = grid + '\n' + gridRow
  }
  return grid
}

Exet.prototype.getClues = function(dir, solved=true) {
  if (!this.puz) {
    return ''
  }
  let clues = ''
  for (let ci in this.puz.clues) {
    let clue = this.puz.clues[ci]
    if (clue.dir != dir) {
      continue
    }
    clues = clues + '\n  ' + (clue.displayLabel || clue.label) + ' ' + clue.clue
    if (solved && clue.solution) {
      clues = clues + ' [' + clue.solution + ']'
    }
    if (solved && clue.anno) {
      clues = clues + ' ' + clue.anno
    }
  }
  return clues
}

Exet.prototype.getExolve = function(id='', skipClues=false, solved=true) {
  return `  ${this.otherSections}
  exolve-id: ${(id ? id : this.puz.id)}` +
  (this.puz.title ? `
  exolve-title: ${this.puz.title}` : '') +
  (this.puz.setter ? `
  exolve-setter: ${this.puz.setter}` : '') +
  (this.puz.copyright ? `
  exolve-copyright: ${this.puz.copyright}` : '') + `
  exolve-grid: ${this.getGrid(solved)}` +
  (!skipClues ? `
  exolve-across: ${this.getClues('A', solved)}
  exolve-down: ${this.getClues('D', solved)}` : '') + `
  exolve-end
  `
}

Exet.prototype.getHTML = function(solved=true) {
  return this.prefix + '\n' + this.getExolve('', false, solved) + '\n' + this.suffix
}

Exet.prototype.makeLexKey = function(partialSol) {
  let key = ''
  if (!partialSol) return key;
  let lowerSol = partialSol.toLowerCase()
  for (let i = 0; i < partialSol.length; ++i) {
    let c = lowerSol.charAt(i);
    if ((c >= 'a' && c <= 'z') || c == '?') {
      key = key + c;
    }
  }
  return key;
}

Exet.prototype.generalizeKey = function(key) {
  for (let i = key.length - 1; i >= 0; --i) {
    if (key.charAt(i) != '?') {
      return key.substr(0, i) + '?' + key.substr(i + 1);
    }
  }
  return key;
}

Exet.prototype.keyMatchesPhrase = function(key, phrase) {
  let phraseKey = this.makeLexKey(phrase)
  if (phraseKey.length != key.length) {
    return false;
  }
  for (let i = 0; i < key.length; i++) {
    if (key.charAt(i) != '?' &&
        key.charAt(i) != phraseKey.charAt(i)) {
      return false;
    }
  }
  return true
}

Exet.prototype.isProperNoun = function(s) {
  let first = s.charAt(0)
  return first.toUpperCase() == first
}

Exet.prototype.getLexChoices = function(partialSol, limit=0, dontReuse={}) {
  let choices = []
  let key = this.makeLexKey(partialSol);
  if (!key) return choices
  // First look at preferred choices (these may have idx >= this.indexMinpop)
  let seen = {}
  if (this.preflexByLen[key.length]) {
    for (idx of this.preflexByLen[key.length]) {
      if (dontReuse[idx]) continue
      let phrase = exetLexicon.lexicon[idx]
      if (this.keyMatchesPhrase(key, phrase)) {
        choices.push(idx)
        seen[idx] = true
      }
    }
  }
  let gkey = key;
  while (!exetLexicon.index[gkey]) {
    let ngkey = this.generalizeKey(gkey)
    if (ngkey == gkey) return choices
    gkey = ngkey;
  }
  let indices = exetLexicon.index[gkey];
  for (let idx of indices) {
    if (idx >= this.indexMinpop) break
    if (dontReuse[idx]) continue
    if (this.unpreflex[idx]) continue
    let phrase = exetLexicon.lexicon[idx]
    if (this.noProperNouns && this.isProperNoun(phrase)) {
      continue
    }
    if (this.keyMatchesPhrase(key, phrase) && !seen[idx]) {
      choices.push(idx)
      if (limit > 0 && choices.length >= limit) break
    }
  }
  return choices;
}

Exet.prototype.makeAnagramKey = function(phrase) {
  return phrase.toLowerCase().replace(/ /g, '').split('').sort().join('')
}

Exet.prototype.javaHash = function(key) {
  let hash = 0;
  for (let i = 0; i < key.length; i++) {
    let c = key.charCodeAt(i);
    hash = ((hash << 5) - hash) + c;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

Exet.prototype.getAnagrams = function(phrase) {
  const key = this.makeAnagramKey(phrase);
  const NUM_SHARDS = exetLexicon.anagrams.length
  let shard = this.javaHash(key) % NUM_SHARDS
  if (shard < 0) shard += NUM_SHARDS
  let anagrams = []
  for (let idx of exetLexicon.anagrams[shard]) {
    let candidate = exetLexicon.lexicon[idx]
    if (this.makeAnagramKey(candidate) == key) {
      anagrams.push(candidate)
    }
  }
  return anagrams
}

Exet.prototype.cellsOfClue = function(theClue) {
  if (theClue.parentClueIndex) {
    return []
  } else if (!theClue.childrenClueIndices || theClue.childrenClueIndices.length == 0) {
    return theClue.cells
  }
  let cells = []
  let linked = this.puz.getLinkedClues(theClue.index)
  for (let lci of linked) {
    cells = cells.concat(this.puz.clues[lci].cells)
  }
  return cells
}

Exet.prototype.IntersectChoices = function(set1, set2) {
  let result = {}
  for (let x in set2) {
    if (set1[x]) result[x] = true
  }
  return result
}

Exet.prototype.Set2Trims = function(set1, set2) {
  for (let x in set1) {
    if (!set2[x]) return true
  }
  return false
}

// A data structure encapsulating clues and a grid, along with available fill
// choices. Used for figuring out viability, weeding out non-viable choices,
// and doing autofill. Note that you can initialize this from exet.puz as well
// as from another ExetFillState.
function ExetFillState(obj) {
  this.gridWidth = obj.gridWidth
  this.gridHeight = obj.gridHeight
  this.grid = new Array(this.gridHeight)
  this.viable = obj.viable
  for (let i = 0; i < this.gridHeight; i++) {
    this.grid[i] = new Array(this.gridWidth)
    for (let j = 0; j < this.gridWidth; j++) {
      let gridCell = obj.grid[i][j]
      this.grid[i][j] = {}
      let thisCell = this.grid[i][j]
      thisCell.isLight = gridCell.isLight
      if (!thisCell.isLight) continue
      thisCell.solution = gridCell.solution
      thisCell.currLetter = gridCell.currLetter
      thisCell.cChoices = gridCell.cChoices || {}
      thisCell.viability = gridCell.viability
    }
  }
  this.clues = {}
  for (let ci in obj.clues) {
    let theClue = obj.clues[ci]
    this.clues[ci] = {}
    let thisClue = this.clues[ci]
    thisClue.solution = theClue.solution
    if (theClue.parentIndex) thisClue.parentIndex = theClue.parentIndex
    thisClue.childrenClueIndices = theClue.childrenClueIndices
    thisClue.dir = theClue.dir
    thisClue.cells = theClue.cells
    thisClue.lChoices = theClue.lChoices || []
  }
}

Exet.prototype.refineLightChoices = function(fillState, limit=0) {
  fillState.preflexUsed = {}
  let dontReuse = {}
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (theClue.solution.indexOf('?') >= 0) {
      continue
    }
    let key = this.makeLexKey(theClue.solution)
    let choices = this.getLexChoices(key, 1, dontReuse)
    if (choices.length > 0) {
      let p = choices[0]
      dontReuse[p] = true
      if (this.preflexSet[p]) fillState.preflexUsed[p] = true
    }
  }
  let changes = 0;
  for (let ci in fillState.clues) {
    let theClue = fillState.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let cells = theClue.cells
    let toConsider = (limit <= 0) ? theClue.lChoices.length :
        Math.min(limit, theClue.lChoices.length)
    let choices = theClue.lChoices.slice(0, toConsider)
    let remChoices = theClue.lChoices.slice(toConsider)
    theClue.lChoices = []
    let cellChoiceSets = []
    for (let cell of cells) {
      cellChoiceSets.push({})
    }
    for (let lchoice of choices) {
      if (dontReuse[lchoice]) {
        changes++;
        continue
      }
      let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
      let viable = true
      for (let i = 0; i < key.length; i++) {
        let cell = cells[i]
        let gridCell = fillState.grid[cell[0]][cell[1]]
        let letter = key.charAt(i).toUpperCase()
        if (gridCell.solution == '?' && !gridCell.cChoices[letter]) {
          viable = false
          break
        }
      }
      if (viable) {
        theClue.lChoices.push(lchoice)
        for (let i = 0; i < key.length; i++) {
          let letter = key.charAt(i).toUpperCase()
          cellChoiceSets[i][letter] = true
        }
      } else {
        changes++;
      }
    }
    let isForced = true
    for (let i = 0; i < cells.length; i++) {
      let cell = cells[i]
      let gridCell = fillState.grid[cell[0]][cell[1]]
      if (gridCell.solution != '?') {
        continue
      }
      gridCell.cChoices = this.IntersectChoices(gridCell.cChoices, cellChoiceSets[i])
      let choices = Object.keys(gridCell.cChoices)
      if (choices.length > 1) {
        isForced = false
      }
    }
    if (isForced && theClue.lChoices.length == 1) {
      let p = theClue.lChoices[0]
      dontReuse[p] = true
      if (this.preflexSet[p]) fillState.preflexUsed[p] = true
    }
    if (!isForced && remChoices.length > 0) {
      theClue.lChoices = theClue.lChoices.concat(remChoices)
    }
  }
  fillState.numPreflexUsed = Object.keys(fillState.preflexUsed).length
  for (let i = 0; i < fillState.gridHeight; i++) {
    for (let j = 0; j < fillState.gridWidth; j++) {
      let gridCell = fillState.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let choices = Object.keys(gridCell.cChoices)
      if (choices.length == 0) {
        fillState.viable = false
      }
      gridCell.viability = this.viability(choices.length)
    }
  }
  return changes
}

Exet.prototype.findDeadendsByCell = function(fillState) {
  return this.refineLightChoices(fillState, this.sweepMaxChoices)
}

Exet.prototype.updateViablots = function() {
  let fillState = this.fillState
  let dead = 0
  for (let i = 0; i < fillState.gridHeight; i++) {
    for (let j = 0; j < fillState.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let fillStateCell = fillState.grid[i][j]
      let choices = Object.keys(fillStateCell.cChoices)
      let viablot = gridCell.viablot
      let opacity = dead > 3 ? 0.1 : (dead == 0 ? 0.6 : 0.3)
      viablot.style.fill = (fillStateCell.viability >= 5) ?
        'transparent' :
        (fillStateCell.viability == 0 ? `rgba(255,0,255,${opacity})` : `rgba(255,0,0,${opacity})`)
      viablot.setAttributeNS(
          null, 'r', this.puz.circleR * 0.1 * (5 - fillStateCell.viability));
      if (fillStateCell.viability == 0) {
        dead++
      }
      if (choices.length == 1) {
        if (!gridCell.forcedLetter) {
          let cellText =
            document.createElementNS('http://www.w3.org/2000/svg', 'text');
          cellText.setAttributeNS(
            null, 'x', this.puz.cellLeftPos(j, this.puz.lightStartX));
          cellText.setAttributeNS(
            null, 'y', this.puz.cellTopPos(i, this.puz.lightStartY));
          cellText.setAttributeNS(null, 'text-anchor', 'middle');
          cellText.setAttributeNS(null, 'editable', 'simple');
          let cellClass = 'xlv-cell-text'
          cellText.style.fill = 'gray'
          cellText.style.fontSize = this.puz.letterSize + 'px'
          cellText.setAttributeNS(null, 'class', cellClass)
          cellText.addEventListener('click', this.puz.cellActivator.bind(this.puz, i, j));

          const text = document.createTextNode(choices[0]);
          cellText.appendChild(text);
          this.puz.svg.appendChild(cellText)
          gridCell.forcedLetter = text
        }
        gridCell.forcedLetter.nodeValue = choices[0]
        viablot.style.fill = 'transparent'
      } else {
        if (gridCell.forcedLetter) {
          gridCell.forcedLetter.nodeValue = ''
        }
      }
    }
  }
  if (!fillState.viable) {
    if (this.viabilityUpdateTimer) {
      clearTimeout(this.viabilityUpdateTimer);
    }
    this.viabilityUpdateTimer = null;
    this.updateSweepInd()
  }
}

Exet.prototype.acceptAll = function() {
  if (this.autofill.running) {
    alert('Wait while autofill is running, as partial solutions may turn out to be non-viable')
    return false
  }
  let changed = false;
  // First do it by clue, to get hyphens/word-breaks.
  for (let ci in this.fillState.clues) {
    let theClue = this.fillState.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let choices = theClue.lChoices
    if (choices.length != 1) {
      continue
    }
    this.fillLight(choices[0], ci, exetRevManager.REV_AUTOFILL_GRIDFILL_CHANGE)
    changed = true
  }
  for (let i = 0; i < this.fillState.gridHeight; i++) {
    for (let j = 0; j < this.fillState.gridWidth; j++) {
      let gridCell = this.fillState.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let choices = Object.keys(gridCell.cChoices)
      if (choices.length == 1) {
        this.puz.grid[i][j].currLetter = choices[0]
        changed = true
      }
    }
  }
  return changed
}

// Finds a clue that becomes non-viable when it previously was viable.
// Return true if such a clue can be found.
Exet.prototype.someClueTurnsNonViable = function(tempFillState) {
  let changes = 1
  let tempClues = {}
  for (let ci in tempFillState.clues) {
    tempClues[ci] = {}
    let theClue = tempFillState.clues[ci]
    if (theClue.lChoices) {
      tempClues[ci].lChoices = theClue.lChoices.slice()
    }
  }
  let count = 0
  while (changes > 0 && count < 1) {
    count++
    changes = 0
    for (let ci in tempFillState.clues) {
      let theClue = tempFillState.clues[ci]
      if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
        continue
      }
      let cells = theClue.cells
      let cellChoiceSets = []
      for (let cell of cells) {
        cellChoiceSets.push({})
      }
      let tempClue = tempClues[ci]
      let limit = Math.min(this.shownLightChoices, tempClue.lChoices.length)
      for (let i = 0; i < limit; i++) {
        let lchoice = tempClue.lChoices[i]
        let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
        console.assert(key.length = cells.length, key.length, cells.length)
        for (let k = 0; k < key.length; k++) {
          let letter = key.charAt(k).toUpperCase()
          cellChoiceSets[k][letter] = true
        }
      }
      for (let i = 0; i < cells.length; i++) {
        let cell = cells[i]
        let gridCell = tempFillState.grid[cell[0]][cell[1]]
        if (gridCell.solution != '?') {
          continue
        }
        gridCell.cChoices = this.IntersectChoices(gridCell.cChoices, cellChoiceSets[i])
      }
    }
    for (let ci in tempFillState.clues) {
      let theClue = tempFillState.clues[ci]
      if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
        continue
      }
      let cells = theClue.cells
      let tempClue = tempClues[ci]
      if (tempClue.lChoices.length > this.sweepMaxChoicesSmall) {
        continue
      }
      let choices = tempClue.lChoices.slice()
      tempClue.lChoices = []
      for (let i = 0; i < choices.length; i++) {
        let lchoice = choices[i]
        let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
        let viable = true
        for (let i = 0; i < key.length; i++) {
          let cell = cells[i]
          let gridCell = tempFillState.grid[cell[0]][cell[1]]
          if (gridCell.solution != '?') {
            continue
          }
          let letter = key.charAt(i).toUpperCase()
          if (!gridCell.cChoices[letter]) {
            viable = false
            break
          }
        }
        if (viable) {
          tempClue.lChoices.push(lchoice)
        } else {
          changes++;
        }
      }
      if (choices.length > 0 && tempClue.lChoices.length == 0) {
        return true
      }
    }
  }
  return false
}

// Returns true if should be called again
Exet.prototype.findDeadendsByClue = function() {
  let ci = this.deadendClueCheck
  if (!ci) {
    return false
  }
  let theClue = this.fillState.clues[ci]
  if (!theClue) {
    return false
  }
  if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
    return false
  }
  let cells = theClue.cells
  if (this.deadendClueLightCheck >= theClue.lChoices.length ||
      cells.length == 0) {
    return false
  }
  if (this.deadendClueLightCheck >= this.shownLightChoices) {
    return false
  }
  const CHOICES_TO_CHECK = 3
  let prefix = theClue.lChoices.slice(0, this.deadendClueLightCheck)
  let choices = theClue.lChoices.slice(this.deadendClueLightCheck, this.deadendClueLightCheck + CHOICES_TO_CHECK)
  let viableChoices = []
  let suffix = theClue.lChoices.slice(this.deadendClueLightCheck + CHOICES_TO_CHECK)
  let oldLen = theClue.lChoices.length
  for (let lchoice of choices) {
    let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
    console.assert(key.length = cells.length, key.length, cells.length)
    let tempFillState = new ExetFillState(this.fillState)
    for (let i = 0; i < cells.length; i++) {
      let cell = cells[i]
      let tempGridCell = tempFillState.grid[cell[0]][cell[1]]
      tempGridCell.cChoices = {}
      let letter = key.charAt(i).toUpperCase()
      tempGridCell.cChoices[letter] = true
    }
    if (!this.someClueTurnsNonViable(tempFillState)) {
      viableChoices.push(lchoice)
    }
  }
  theClue.lChoices = prefix.concat(viableChoices, suffix)
  this.deadendClueCheckChanges += (oldLen - theClue.lChoices.length)
  this.deadendClueLightCheck +=  viableChoices.length
  return this.deadendClueLightCheck < theClue.lChoices.length
}

Exet.prototype.startDeadendSweep = function(ci='') {
  if (this.viabilityUpdateTimer) {
    clearTimeout(this.viabilityUpdateTimer);
  }
  this.viabilityUpdateTimer = null;
  if (!this.puz || this.puz.numCellsFilled >= this.puz.numCellsToFill) {
    return
  }
  if (this.autofill.running) {
    return
  }
  this.deadendsGridSweep = true
  this.sweepIndicator.className = 'xet-sweeping-animated'
  this.viabilityUpdateTimer = setTimeout(() => {
    this.findAllDeadendFills(ci)
  }, this.sweepMS);
}

Exet.prototype.getClueToCheckDeadends = function(ci) {
  if (ci) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) {
      ci = theClue.parentClueIndex
      theClue = this.puz.clues[ci]
    }
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      return ''
    }
    return ci
  }
  // Find most constrained unsolved and still-viable clue
  let res = ''
  let resChoices = exetLexicon.lexicon.length
  for (ci in this.fillState.clues) {
    let theClue = this.fillState.clues[ci]
    if (theClue.parentClueIndex) continue
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) continue
    if (theClue.lChoices.length > 0 && theClue.lChoices.length < resChoices) {
      resChoices = theClue.lChoices.length
      res = ci
    }
  }
  return res
}

Exet.prototype.updateSweepInd = function() {
  this.sweepIndicator.className =
      (this.viabilityUpdateTimer || this.autofill.running) ?
      'xet-sweeping-animated' : 'xet-sweeping';
}

Exet.prototype.findAllDeadendFills = function(ci) {
  if (this.viabilityUpdateTimer) {
    clearTimeout(this.viabilityUpdateTimer);
  }
  this.viabilityUpdateTimer = null;
  if (this.deadendsGridSweep) {
    let changes = this.findDeadendsByCell(this.fillState)
    this.updateViablots()
    if (changes > 0 && this.fillState.viable) {
      this.updateFillChoices()
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills(ci)
      }, this.sweepMS);
    } else {
      // Start the clue-sweep
      this.deadendsGridSweep = false
      this.deadendClueLightCheck = 0;
      this.deadendClueCheckChanges = 0;
      this.deadendClueCheck = this.getClueToCheckDeadends(ci);
      if (!this.deadendClueCheck) {
        this.updateSweepInd()
        return
      }
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills()
      }, this.sweepMS);
    }
  } else {
    let doMore = this.findDeadendsByClue()
    if (this.deadendClueCheckChanges > 0) {
      this.updateFillChoices()
    }
    if (!doMore) {
      this.deadendsGridSweep = true
      if (this.deadendClueCheckChanges > 0) {
        // Repeat the grid-sweep
        this.viabilityUpdateTimer = setTimeout(() => {
          this.findAllDeadendFills()
        }, this.sweepMS);
      } else {
        this.updateSweepInd()
      }
    } else {
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills()
      }, this.sweepMS);
    }
  }
}

Exet.prototype.viability = function(len) {
  const log2 = 0.6931471805599453;
  return len == 0 ? 0 : (len >= 16 ? 5 : (1 + (Math.log(len) / log2)));
}

Exet.prototype.initViability = function() {
  for (let i = 0; i < this.fillState.gridHeight; i++) {
    for (let j = 0; j < this.fillState.gridWidth; j++) {
      let gridCell = this.fillState.grid[i][j]
      if (!gridCell.isLight) {
        continue
      }
      if (gridCell.solution != '?') {
        gridCell.cChoices = {}
        gridCell.cChoices[gridCell.solution] = true
        gridCell.viability = 1.0;
      } else {
        gridCell.cChoices = this.allLetters
        gridCell.viability = 5.0;
      }
    }
  }
  this.fillState.viable = true
}

Exet.prototype.resetViability = function() {
  this.resetAutofill('Aborted')
  this.initViability()
  let numPreflexUsed = 0
  let dontReuse = {}
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (theClue.solution.indexOf('?') >= 0) {
      continue
    }
    let key = this.makeLexKey(theClue.solution)
    let choices = this.getLexChoices(key, 1, dontReuse)
    this.fillState.clues[ci].lChoices = choices
    if (choices.length > 0) {
      let p = choices[0]
      dontReuse[p] = true
      if (this.preflexSet[p]) numPreflexUsed++
    }
  }
  if (this.preflexUsed) {
    this.preflexUsed.innerText = numPreflexUsed
  }
  for (let ci in this.fillState.clues) {
    let theClue = this.fillState.clues[ci]
    let key = this.makeLexKey(theClue.solution)
    if (theClue.solution.indexOf('?') < 0) {
      continue
    }
    theClue.lChoices = this.getLexChoices(key, 0, dontReuse)
  }
  this.updateFillChoices()
  this.updateViablots()
  this.startDeadendSweep()
}

Exet.prototype.fillLight = function(idx, ci='', revType=null) {
  let updateIfChanged = false
  if (!ci && this.puz) {
    ci = this.puz.currClueIndex
    updateIfChanged = true
  }
  if (!ci) {
    return
  }
  let solution = exetLexicon.lexicon[idx]
  let theClue = this.puz.clues[ci]
  if (!theClue || !solution ||
      this.makeLexKey(solution).length != theClue.cells.length) {
    return
  }
  solution = solution.toUpperCase()
  let changed = false;
  if (theClue.solution != solution) {
    theClue.solution = solution
    changed = true
  }
  let enumStr = ''
  let enumPart = 0
  let solIndex = 0
  for (let i = 0; i < solution.length; i++) {
    let c = solution.charAt(i);
    if (enumPart > 0 && (c == ' ' || c == '-' || c == '\'')) {
      enumStr = enumStr + enumPart + (c == ' ' ? ',' : c)
      enumPart = 0
    }
    if (c >= 'A' && c <= 'Z') {
      enumPart++
      let cell = theClue.cells[solIndex++]
      let gridCell = this.puz.grid[cell[0]][cell[1]]
      if (gridCell.currLetter != c || gridCell.solution != c) {
        gridCell.currLetter = c
        changed = true
      }
    }
  }
  if (enumPart > 0) {
    enumStr = enumStr + enumPart
  }
  let clueEnumStart = theClue.clue.lastIndexOf('(')
  let clueEnumEnd = theClue.clue.lastIndexOf(')')
  if (clueEnumStart > 0 && clueEnumEnd > clueEnumStart + 1) {
    let clueEnum = theClue.clue.substring(clueEnumStart + 1, clueEnumEnd)
    if (clueEnum != enumStr) {
      theClue.clue = theClue.clue.substr(0, clueEnumStart).trim() +
        ' (' + enumStr + ')'
      changed = true
    }
  } else {
    theClue.clue = theClue.clue.trim() + ' (' + enumStr + ')'
    changed = true
  }
  if (changed && updateIfChanged) {
    this.handleGridInput(revType)
  }
}

Exet.prototype.setPreflex = function(preflex) {
  this.preflex = preflex
  this.preflexSet = {}
  if (this.preflexSize) {
    this.preflexSize.innerText = preflex.length
  }
  while (exetLexicon.lexicon.length > exetLexicon.startLen) exetLexicon.lexicon.pop()
  this.preflexByLen = {}
  for (let p of this.preflex) {
    let len = this.makeLexKey(p).length
    let inLexicon = this.getLexChoices(p, 1)
    if (inLexicon.length > 0) {
      p = inLexicon[0]
    } else  {
      exetLexicon.lexicon.push(p)
      p = exetLexicon.lexicon.length - 1
    }
    if (!this.preflexByLen[len]) this.preflexByLen[len] = []
    this.preflexByLen[len].push(p)
    this.preflexSet[p] = true
  }
}

Exet.prototype.throttledUpdatePreflex = function() {
  if (this.throttledPreflexTimer) {
    clearTimeout(this.throttledPreflexTimer);
  }
  this.throttledPreflexTimer = setTimeout(() => {
    this.updatePreflex()
    this.throttledPreflexTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.updatePreflex = function() {
  let preflexes = this.preflexInput.value.trim().split('\n')
  let cleaned = ''
  preflex = []
  let seen = {}
  for (let p of preflexes) {
    p = p.trim().replace(/[^a-zA-Z' -]/g, '').replace(/[ ][ ]*/g, ' ')
    if (!p) continue
    let hash = this.javaHash(p.toLowerCase())
    if (seen[hash]) continue
    seen[hash] = true

    if (cleaned) cleaned = cleaned + '\n'
    cleaned = cleaned + p
    preflex.push(p)
    if (preflex.length >= 100) break
  }
  if (cleaned != this.preflexInput.value.trim()) {
    let cursor = this.preflexInput.selectionStart
    this.preflexInput.value = cleaned
    this.preflexInput.selectionEnd = cursor
  }
  if (JSON.stringify(preflex) == JSON.stringify(this.preflex)) {
    return
  }
  if (this.autofill && this.autofill.preflexTotalSpan) {
    this.autofill.preflexTotalSpan.innerText = preflex.length
  }
  this.setPreflex(preflex)
  this.resetViability()
  exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
}

Exet.prototype.throttledUpdateUnpreflex = function() {
  if (this.throttledUnpreflexTimer) {
    clearTimeout(this.throttledUnpreflexTimer);
  }
  this.throttledUnpreflexTimer = setTimeout(() => {
    this.updateUnpreflex()
    this.throttledUnpreflexTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.renderUnpreflex = function() {
  let unpreflexText = ''
  for (let p in this.unpreflex) {
    if (unpreflexText) unpreflexText += '\n'
    unpreflexText += exetLexicon.lexicon[p]
  }
  if (this.unpreflexInput.value != unpreflexText) {
    let cursor = this.unpreflexInput.selectionStart
    this.unpreflexInput.value = unpreflexText
    this.unpreflexInput.selectionEnd = cursor
  }
  this.unpreflexSize.innerText = Object.keys(this.unpreflex).length
}

Exet.prototype.updateUnpreflex = function() {
  let unpreflexes = this.unpreflexInput.value.trim().split('\n')
  let saved = this.unpreflex
  this.unpreflex = {}
  for (let p of unpreflexes) {
    p = p.trim().replace(/[^a-zA-Z' -]/g, '').replace(/[ ][ ]*/g, ' ')
    if (!p) continue

    let len = this.makeLexKey(p).length
    let inLexicon = this.getLexChoices(p, 1)
    if (inLexicon.length != 1) {
      continue
    }
    if (this.unpreflex[p]) {
      continue
    }
    p = inLexicon[0]
    this.unpreflex[p] = true
  }
  this.unpreflexSize.innerText = Object.keys(this.unpreflex).length
  if (JSON.stringify(this.unpreflex) == JSON.stringify(saved)) {
    return
  }
  this.resetViability()
  exetRevManager.throttledSaveRev(exetRevManager.REV_PREFLEX_CHANGE)
}

Exet.prototype.updateFillChoices = function() {
  if (!this.puz.currClueIndex) {
    return
  }
  let theClue = this.fillState.clues[this.puz.currClueIndex]
  console.assert(theClue && theClue.lChoices, this.puz.currClueIndex)

  let html = ''
  if (theClue.lChoices.length == 0) {
    // Maybe the light was filled from outside the lexicon
    let gridClue = this.puz.clues[this.puz.currClueIndex]
    if (gridClue.solution.indexOf('?') < 0) {
      html = `<tr><td>${gridClue.solution}</td></tr>`
    }
  }

  if (!html) {
    let numShown = 0
    for (let choice of theClue.lChoices) {
      html = html + `
        <tr><td>${exetLexicon.lexicon[choice]}</td></tr>
      `
      numShown++
      if (numShown >= this.shownLightChoices) break;
    }
  }
  let htmlHash = this.javaHash(html + this.puz.currClueIndex)
  if (this.shownChoicesHash && this.shownChoicesHash == htmlHash) {
    return
  }
  this.shownChoicesHash = htmlHash
  this.lChoices.innerHTML = html
  let trs = this.lChoices.getElementsByTagName('tr')
  let lim = Math.min(theClue.lChoices.length, trs.length)
  for (let i = 0; i < lim; i++) {
    trs[i].addEventListener('click', this.fillLight.bind(this, theClue.lChoices[i], ''))
  }
}

Exet.prototype.warnVersion = function(ver) {
  let about = document.getElementById("xet-about")
  about.style.color = "red"
  about.title = 'Please reload to update to ' + ver
  let warnMsg = document.getElementById("xet-outdated-message")
  warnMsg.innerHTML = 'Please <a href="javascript:window.location.reload(true)">reload</a> to update to ' + ver
  warnMsg.style.display = ''
  let warnIcon = document.getElementById("xet-outdated")
  warnIcon.style.display = ''
}

Exet.prototype.checkVersion = function() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4) {
      let now = (new Date()).toLocaleString()
      if (this.status < 200 || this.status > 299) {
        console.log(now + ": Version check request failed")
        return
      }
      let ver = this.responseText.trim()
      if (!exet.versionText) {
        exet.versionText = ver
        console.log(now + ": Initialized Exet version to " + ver)
      } else if (ver != exet.versionText) {
        exet.warnVersion(ver)
        console.log(now + ": Exet version: " + exet.versionText + " needs update to: " + ver)
      } else {
        console.log(now + ": Exet version verified to be current: " + ver)
      }
    }
  };
  xhttp.open("GET", "exet-version.txt", true);
  xhttp.send();
}

Exet.prototype.initVersionChecking = function() {
  this.versionText = ''
  if (window.location.protocol == "file:") {
    return
  }
  // Check every 10 minutes
  setInterval(this.checkVersion.bind(this), 10 * 60 * 1000)
}

function exetFromHistory(exetRev) {
  exet.prefix = exetRev.prefix
  exet.suffix = exetRev.suffix
  let preflex = exetRev.preflex || []
  exet.setPreflex(preflex)
  exet.unpreflex = exetRev.unpreflex || {}
  exet.setMinpop(exetRev.minpop || 0)
  exet.noProperNouns = exetRev.noProperNouns || false
  exet.makeExolve(exetRev.exolve)
  if (exetRev.navState) {
    exet.startNav(exetRev.navState[0], exetRev.navState[1], exetRev.navState[2])
  } else {
    exet.startNav()
  }
  if (exetRev.scratchPad && exet.puz && exet.puz.scratchPad) {
    exet.puz.scratchPad.value = exetRev.scratchPad
  }
  if (exet.puz && exet.puz.id && exetRev.revNum < exetRev.maxRevNum) {
    exetRevManager.throttledSaveRev(exetRevManager.REV_JUMPED_TO_REV,
                                    '' + exetRev.revNum);
  }
}

function exetBlank(w=15, h=15, id='', automagic=false, checkered=true,
                   topUnches=false, leftUnches=false) {
  if (!w || !h || w <= 0 || h <= 0 || w > 100 || h > 100) {
    alert('Width and height must be specified in the range, 1-100')
    return
  }
  if (!id) {
    id = `puz-${Math.random().toString(36).substring(2, 8)}`
  }

  let gridRow = ['', '']
  for (let j = 0; j < w; j++) {
    if (checkered) {
      if (!topUnches && !leftUnches) {
        gridRow[0] = gridRow[0] + '?'
        gridRow[1] = gridRow[1] + (j % 2 == 0 ? '?' : '.')
      } else if (!topUnches && leftUnches) {
        gridRow[0] = gridRow[0] + '?'
        gridRow[1] = gridRow[1] + (j % 2 == 0 ? '.' : '?')
      } else if (topUnches && !leftUnches) {
        gridRow[0] = gridRow[0] + (j % 2 == 0 ? '?' : '.')
        gridRow[1] = gridRow[1] + '?'
      } else if (topUnches && leftUnches) {
        gridRow[0] = gridRow[0] + (j % 2 == 0 ? '.' : '?')
        gridRow[1] = gridRow[1] + '?'
      }
    } else {
      gridRow[0] = gridRow[0] + '?'
      gridRow[1] = gridRow[1] + '?'
    }
  }
  let grid = ''
  for (let i = 0; i < h; i++) {
    grid = grid + '\n  ' + gridRow[i % 2]
  }

  let specs = `exolve-begin
    exolve-id: ${id}
    exolve-title: Exet Crossword
    exolve-setter: Exetter
    exolve-width: ${w}
    exolve-height: ${h}
    exolve-grid: ${grid}
    exolve-across:
    exolve-down:
  exolve-end
  `
  exet.setPreflex([])
  exet.unpreflex = {}
  exet.setMinpop(0)
  exet.noProperNouns = false
  exet.makeExolve(specs)
  exet.startNav()
  if (!exet.puz || !exet.puz.id) {
    alert('Failed to create/load crossword, unfortunately. Perhaps the JavaScript console may have logged some error messages.')
    return
  }

  if (automagic && exet.automagicBlocks(false)) {
    exet.updatePuzzle(exetRevManager.REV_CREATED_AUTOBLOCK)
    return
  }
  exetRevManager.throttledSaveRev(exetRevManager.REV_CREATED_BLANK)
}

function exetLoadFile() {
  let fr = new FileReader(); 
  fr.onload = function(){ 
    let start = fr.result.indexOf('exolve-begin')
    let end = fr.result.indexOf('exolve-end')
    if (start < 0 || end < 0 || start >= end) {
      alert('Invalid Exolve specifications')
      return
    }
    end += 'exolve-end'.length
    exet.prefix = fr.result.substring(0, start).trim()
    exet.suffix = fr.result.substring(end).trim()
    let specs = fr.result.substring(start, end)
    exet.setPreflex([])
    exet.unpreflex = {}
    exet.setMinpop(0)
    exet.noProperNouns = false
    exet.makeExolve(specs)
    exet.startNav()
    if (exet.puz && exet.puz.id) {
      // See if this has a preflex/unpreflex, recover if so.
      let stored = window.localStorage.getItem(exet.puz.id)
      if (stored) {
        stored = JSON.parse(stored)
        if (stored.revs.length > 0) {
          let lastRev = stored.revs[stored.revs.length - 1]
          if (lastRev.preflex) {
            exet.setPreflex(lastRev.preflex)
          }
          if (lastRev.unpreflex) {
            exet.unreflex = lastRev.unpreflex
          }
          exet.setMinpop(lastRev.minpop || 0)
          exet.noProperNouns = lastRev.noProperNouns || false
        }
      }
      exetRevManager.throttledSaveRev(
          exetRevManager.REV_LOADED_FROM_FILE,
          exetFileName);
    }
  } 
  let f = document.getElementById('xet-file').files[0]
  exetFileName = f.name
  fr.readAsText(f)
}

let exetFileName = ''
let exetRevManager = new ExetRevManager();
let exetModals = new ExetModals();
if (!window.localStorage) {
  throw "localStorage is not available!"
}
if (!exetLexicon) {
  throw "No lexicon has been loaded!"
}
exetLexicon.startLen = exetLexicon.lexicon.length

let exet = new Exet;

let exetState = window.localStorage.getItem(exetRevManager.SPECIAL_KEY)
if (exetState) {
  exetState = JSON.parse(exetState)
  let id = exetState.lastId
  let saved = window.localStorage.getItem(id)
  if (saved) {
    saved = JSON.parse(saved)
    if (saved.revs.length > 0) {
      exetFromHistory(saved.revs[saved.revs.length - 1])
    }
  }
}
if (!exet.puz) {
  let url = new URL(location.href)
  let newgrid = url.searchParams.get('newgrid')
  if (newgrid == 'blank') {
    exetBlank(15, 15, '', false, false)
  } else {
    exetBlank()
  }
}
exet.initVersionChecking()

</script>

</body>
</html>
