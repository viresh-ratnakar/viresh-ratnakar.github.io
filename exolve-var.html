<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<!--
MIT License

Copyright (c) 2019 Viresh Ratnakar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

The latest code and documentation for exolve can be found at:
https://github.com/viresh-ratnakar/exolve
-->

<title>Exolve: An Easily Configurable Interactive Crossword Solver</title>

<script>

var puzzleText = `
======REPLACE WITH YOUR PUZZLE BELOW======
exolve-begin
  exolve-id: gussalufz-16
  exolve-title: THCC July 2019
  exolve-setter: Gussalufz
  exolve-copyright: 2019 Viresh Ratnakar
  exolve-width: 15
  exolve-height: 15
  exolve-grid:
        ONLY.PAPAL.EDIT
        B.E...T.T...E.R
        OUTDOOR.OBSCURE
        I.T.V.I.M.H.C.F
        SKELETAL.HERETO
        T.R.R...I.N...I
        SUBSIDIES.ANNUL
        ..O.N.L.I.N.E..
        SEXED.LASTINGLY
        Y...U.S...G.L.A
        NICELY.SATANISM
        A.H.G.J.B.N.G.M
        PLACEBO.OBSCENE
        S.O...L.V...E.R
        ELSE.STEEP.ASKS
  exolve-prelude:
    This puzzle was published in the
    <a href='https://thehinducrosswordcorner.blogspot.com'>THCC blog</a>
    in July 2019.

  exolve-nina: a14 c14 g14 i14 m14 o14
  exolve-nina: c8 e8 g8 i8 k8 m8
  exolve-nina: a2 c2 g2 i2 m2 o2
  exolve-nina: h15 h11 h9 h7 h5 h1

  exolve-question: What is the hidden message? (6,6,6,6) BETTER ONLINE SOLVER PLEASE
  exolve-question: Test question (8)*

  exolve-explanations:
    The text in this section, along with annos and answers to questions and
    ninas, gets shown upon clicking "Reveal all."

  exolve-across:
    1 Just running leisurely on vacation (4) Def: Just. ON L(-eisurel)Y.
    3 Quietly a friend of the Catholic church (5) Def: of the Catholic church. P A PAL.
    6 Reverse course and make changes (4) Def: make changes. TIDE<<.
    9 Best alternative to open-air (7) Def: open-air. OUTDO OR.
    11 Specialist doctors heal minor (7) Def: minor. OBS CURE.
    13 Basic, small kale-lettuce salad!? Not cute! (8) Def: Basic. S KALELETTUCE* -CUTE.
    14 About this matter of the star-eating alien (6) Def: About this matter. HERO around ET.
    16 Awkwardly issue bids for financial rewards (9) Def: financial rewards. ISSUEBIDS*.
    18 Cancel yearly leave, Ana (5) Def: Cancel. ANNUAL -A ("leave an a").
    20 Chromosome in sperm determined whether male or female (5) Def: determined whether male or female. X in SEED.
    21 Ally’s break-up carries pain forever (9) Def: forever. ALLY* around STING.
    23 Finally obtain Saudi seismic license; drill exploratory well (6) Def: well. Tail acrostic.
    25 Perhaps Santa is married to devil-worship? (8) Def: devil-worship. SANTA* IS M.
    28 Replace bottles containing questionable medicine (7) Def: questionable medicine. Hidden word.
    29 Immodest one flaunting CBSE preparation? (7) Def: Immodest. ONE around CBSE*.
    30 More dress sizes announced (4) Def: More. Homophone of "Ls."
    31 Sudden drench (5) Def: Sudden. Def: drench.
    32 Questions assignments to take the head off (4) Def: Questions. (-t)ASKS.
  exolve-down:
    1 Musicians keeping time amidst rowdy boos (7) Def: Musicians. IST ("time") in BOOS*.
    2 Mail carrier read pugilist girl’s supporter’s request for permission for her to perform (9) Def: Mail carrier. Homophone of "Let 'er box!"
    4 Courts top actresses to raise inadequate amour-propre (5) Def: Courts. Acrostic.
    5 Trace the first 13 letters! (4) Def: Trace. A TO M.
    7 Dickens suppressed by rabid EU censors (5) Def: Dickens. Hidden word.
    8 Decorative structure for tile arrangement (7) Def: Decorative structure. FORTILE*.
    10 Doctor urged, "In love, allow all kinds of liberties." (11)  Def: allow all kinds of liberties. URGEDINLOVE*.
    12 Son, husband catch silly, boomeranging tricks (11) Def: tricks. S H (SNAG INANE)<<.
    15 Goddess happens to be one top sitarist (4) Def: Goddess. IS I S(-itarist).
    17 Misfortunes of one with fifty-fifty chances, ultimately (4) def: Misfortunes. I LL (-chance)S.
    19 Sheer cover-ups! (9) Cryptic def.
    20 Clairvoyance somewhat on the rise after small connection in the brain (7) Def: connection in the brain. S (ESP ANY)<<.
    22 Whines or goes off: “Sorry, am me!” (7) Def; Whines. CA: (YAMMERS OR)* = SORRY AM ME.
    24 Also, ah—, cannabis limits rising lawlessness! (5) Def: lawlessness. Reverse hidden word.
    26 Can be on view regularly from a height (5) Def: from a height. (-c)A(-n) B(-e) O(-n) V(-i)E(-w).
    27 Start to write about first love (4) Def: Start. JOT about L(-ove)
exolve-end
======REPLACE WITH YOUR PUZZLE ABOVE======
`;

var VERSION = 'exolve v0.15 August 05 2019'

// ------ Begin globals.

var puzzleId = 'exolve-grid'

var gridWidth = 0
var gridHeight = 0
var boxWidth = 0
var boxHeight = 0

var gridFirstLine = -1
var gridLastLine = -1
var preludeFirstLine = -1
var preludeLastLine = -1
var acrossFirstLine = -1
var acrossLastLine = -1
var downFirstLine = -1
var downLastLine = -1
var nodirFirstLine = -1
var nodirLastLine = -1
var explanationsFirstLine = -1
var explanationsLastLine = -1

// Each nina will be an array containing location [i,j] pairs and/or span
// class names.
var ninas = []
// For span-class-specified ninas, ninaClassElements[] stores the elements
// along with the colours to apply to them when showing the ninas.
var ninaClassElements = []
var showingNinas = false

var grid = []
var clues = {}
var submitURL = null
var submitKeys = []
var hasDiagramlessCells = false
var hasUnsolvedCells = false
var hasAcrossClues = false
var hasDownClues = false
var hasNodirClues = false
// Clues labeled non-numerically (like [A] a clue...) use this to create a
// unique clueIndex.
var nextNonNumId = 1
var nonNumClueIndices = {}

var SQUARE_DIM = 31
var SQUARE_DIM_BY2 = 16
var GRIDLINE = 1
var BAR_WIDTH = 4
var BAR_WIDTH_BY2 = 2.5
var SEP_WIDTH = 2
var SEP_WIDTH_BY2 = 1.5
var HYPHEN_WIDTH = 9
var HYPHEN_WIDTH_BY2 = 5
var CIRCLE_RADIUS = 0.0 + SQUARE_DIM / 2.0

var NUMBER_START_X = 3
var NUMBER_START_Y = 11
var LIGHT_START_X = 16.5
var LIGHT_START_Y = 21.925

var answersList = []
var revelationList = []

var currentRow = -1
var currentCol = -1
var currentDirectionIsAcross = true
var activeCells = [];
var activeClues = [];
var numCellsToFill = 0

var allClueIndices = []
// For the all-clues widget.
var posInAllClueIndices = 0

var BLOCK_CHAR = '⬛';
var ACTIVE_COLOUR = 'mistyrose'
var ALL_CLUES_COLOUR = 'white'
var TRANSPARENT_WHITE = 'rgba(255,255,255,0.0)'

var nextPuzzleTextLine = 0

var STATE_SEP = 'eexxoollvvee'

// Variables set by exolve-option
var hideInferredNumbers = false
var cluesPanelLines = -1

// Variables set in init().
var puzzleTextLines;
var numPuzzleTextLines;
var svg;
var gridInputWrapper;
var gridInput;
var questions;
var background;
var acrossClues;
var downClues;
var nodirClues;
var acrossPanel;
var downPanel;
var nodirPanel;
var currentClue;
var currentClueParent;
var ninaGroup;
var statusNumFilled;
var statusNumTotal;
var savingURL;
var clearButton;
var clearAllButton;
var checkButton;
var checkAllButton;
var ninasButton;
var revealButton;
var revealAllButton;
var submitButton;

// ------ End globals.

// ------ Begin functions.

// Set up globals, version number and user agent in bug link.
function init() {
  puzzleTextLines = puzzleText.trim().split('\n');
  numPuzzleTextLines = puzzleTextLines.length

  svg = document.getElementById('grid');
  gridInputWrapper = document.getElementById('grid-input-wrapper');
  gridInput = document.getElementById('grid-input');
  questions = document.getElementById('questions');

  background =
    document.createElementNS('http://www.w3.org/2000/svg', 'rect');

  acrossPanel = document.getElementById('across-clues-panel')
  downPanel = document.getElementById('down-clues-panel')
  nodirPanel = document.getElementById('nodir-clues-panel')
  acrossClues = document.getElementById('across')
  downClues = document.getElementById('down')
  nodirClues = document.getElementById('nodir')

  currentClue = document.getElementById('current-clue')
  currentClueParent = document.getElementById('current-clue-parent')
  ninaGroup = document.getElementById('nina-group')

  statusNumFilled = document.getElementById('status-num-filled')
  statusNumTotal = document.getElementById('status-num-total')
  savingURL = document.getElementById('saving-url')

  clearButton = document.getElementById('clear')
  clearAllButton = document.getElementById('clear-all')
  checkButton = document.getElementById('check')
  checkAllButton = document.getElementById('check-all')
  ninasButton = document.getElementById('ninas')
  revealButton = document.getElementById('reveal')
  revealAllButton = document.getElementById('reveal-all')
  submitButton = document.getElementById('submit')

  var info = 'Version: ' + VERSION + ', User Agent: ' + navigator.userAgent
  document.getElementById('report-bug').href =
      'https://github.com/viresh-ratnakar/exolve/issues/new?body=' +
      encodeURIComponent(info);
}

// puzzleTextLines[] has been parsed till line # nextPuzzleTextLine. Fine the
// next line beginning with 'exolve-<section>' and return <section> as well
// as the 'value' of the section (the part after ':').
function parseToNextSection() {
  var MARKER = 'exolve-'
  while (nextPuzzleTextLine < numPuzzleTextLines &&
         puzzleTextLines[nextPuzzleTextLine].trim().indexOf(MARKER) != 0) {
    nextPuzzleTextLine++;
  }
  if (nextPuzzleTextLine >= numPuzzleTextLines) {
    return null
  }
  // Skip past MARKER
  var line = puzzleTextLines[nextPuzzleTextLine].trim().substr(MARKER.length)
  var index = line.indexOf(':')
  if (index < 0) {
    index = line.length
  }
  nextPuzzleTextLine++
  return {'section': line.substr(0, index).trim().toLowerCase(),
          'value': line.substr(index + 1).trim()}
}

// Parse a nina line, which consists of cell locations of the nina specified
// using "chess notation" (a1 = bottom-left, etc.). Convert the cell locations
// to [row col] and push an array of these locations to the global ninas array.
function parseNina(s) {
  var nina = []
  var cellsOrClasses = s.split(' ')
  for (var cellOrClass of cellsOrClasses) {
    var cellLocation = parseCellLocation(cellOrClass)
    if (!cellLocation) {
      // Must be a class name, for a span-class-specified nina
      nina.push(cellOrClass)
    } else {
      nina.push(cellLocation)
    }
  }
  if (nina.length > 0) {
    ninas.push(nina)
  }
}

// Parse a question line and create the question element for it (which includes
// an input box for the answer). The solution answer may be provided after the
// last ')'.
function parseQuestion(s) {
  var enumParse = parseEnum(s)
  var inputLen = enumParse.len + enumParse.hyphenAfter.length +
                 enumParse.wordEndAfter.length

  var afterEnum = enumParse.afterEnum
  var rawQ = s.substr(0, afterEnum)

  var hideEnum = false
  if (inputLen > 0) {
    if (s.substr(afterEnum, 1) == '*') {
      beforeEnum = s.lastIndexOf('(', afterEnum - 1)
      if (beforeEnum < 0) {
        addError('Could not find open-paren strangely')
	return
      }
      rawQ = s.substr(0, beforeEnum)
      afterEnum++
      hideEnum = true
    }
  }

  var correctAnswer = s.substr(afterEnum).trim()
  var question = document.createElement('div')
  question.setAttributeNS(null, 'class', 'question');
  var questionText = document.createElement('span')
  questionText.innerHTML = rawQ
  question.appendChild(questionText)
  question.appendChild(document.createElement('br'))
  var answer = document.createElement('input')
  answer.setAttributeNS(null, 'class', 'answer');
  answersList.push({
    'ans': correctAnswer,
    'input': answer,
    'hasEnum': (inputLen > 0),
  });
  if (inputLen == 0) {
    inputLen = '30'
  } else if (!hideEnum) {
    var answerValue = ''
    var wordEndIndex = 0
    var hyphenIndex = 0
    for (var i = 0; i < enumParse.len; i++) {
      answerValue = answerValue + '?'
      if (wordEndIndex < enumParse.wordEndAfter.length &&
              i == enumParse.wordEndAfter[wordEndIndex]) {
        answerValue = answerValue + ' '
        wordEndIndex++
      }
      if (hyphenIndex < enumParse.hyphenAfter.length &&
              i == enumParse.hyphenAfter[hyphenIndex]) {
        answerValue = answerValue + '-'
        hyphenIndex++
      }
    }
    answer.setAttributeNS(null, 'placeholder', '' + answerValue);
    answer.setAttributeNS(null, 'minlength', '' + inputLen);
  }
  answer.setAttributeNS(null, 'class', 'answer');
  answer.setAttributeNS(null, 'type', 'text');
  answer.setAttributeNS(null, 'maxlength', '' + inputLen);
  answer.setAttributeNS(null, 'size', '' + inputLen);
  answer.setAttributeNS(null, 'autocomplete', 'off');
  answer.setAttributeNS(null, 'spellcheck', 'false');
  question.appendChild(answer)
  questions.appendChild(question)
  answer.addEventListener('input', updateAndSaveState);
}

function parseSubmit(s) {
  var parts = s.split(' ')
  if (s.length < 2) {
    addError('Submit section must have a URL and a param name for the solution')
    return
  }
  submitURL = parts[0]
  submitKeys = []
  for (var i = 1; i < parts.length; i++) {
    submitKeys.push(parts[i])
  }
}

function parseOption(s) {
  var sparts = s.split(' ')
  for (var spart of sparts) {
    spart = spart.trim().toLowerCase()
    if (spart == "hide-inferred-numbers") {
      hideInferredNumbers = true
      continue
    }
    var kv = spart.split(':')
    if (kv.length != 2) {
      addError('Expected exolve-option: key:value, got: ' + spart)
      return
    }
    if (kv[0] == 'clues-panel-lines') {
      cluesPanelLines = parseInt(kv[1])
      if (isNaN(cluesPanelLines)) {
        addError('Unexpected value in exolve-option: clue-panel-lines: ' + kv[1])
      }
      continue
    }
    addError('Unexpected exolve-option: ' + spart)
    return
  }
}

// The overall parser for the puzzle text. Also takes care of parsing and
// displaying all exolve-* sections except prelude, grid, across, down (for
// these, it just captures where the start and end lines are).
function parseOverallDisplayMost() {
  var sectionAndValue = parseToNextSection()

  while (sectionAndValue && sectionAndValue.section != 'end') {
    var firstLine = nextPuzzleTextLine
    var nextSectionAndValue = parseToNextSection()
    var lastLine = nextPuzzleTextLine - 2
    if (sectionAndValue.section == 'begin') {
    } else if (sectionAndValue.section == 'id') {
      puzzleId = sectionAndValue.value
    } else if (sectionAndValue.section == 'title') {
      document.getElementById('title').innerHTML = sectionAndValue.value
    } else if (sectionAndValue.section == 'setter') {
      if (sectionAndValue.value.trim() != '') {
        document.getElementById('setter').innerHTML =
            'By ' + sectionAndValue.value
      }
    } else if (sectionAndValue.section == 'copyright') {
      document.getElementById('copyright').innerHTML =
          'Ⓒ ' + sectionAndValue.value
    } else if (sectionAndValue.section == 'width') {
      gridWidth = parseInt(sectionAndValue.value)
      boxWidth = (SQUARE_DIM * gridWidth) + gridWidth + 1
    } else if (sectionAndValue.section == 'height') {
      gridHeight = parseInt(sectionAndValue.value)
      boxHeight = (SQUARE_DIM * gridHeight) + gridHeight + 1
    } else if (sectionAndValue.section == 'prelude') {
      preludeFirstLine = firstLine
      preludeLastLine = lastLine
    } else if (sectionAndValue.section == 'grid') {
      gridFirstLine = firstLine
      gridLastLine = lastLine
    } else if (sectionAndValue.section == 'nina') {
      parseNina(sectionAndValue.value)
    } else if (sectionAndValue.section == 'question') {
      parseQuestion(sectionAndValue.value)
    } else if (sectionAndValue.section == 'submit') {
      parseSubmit(sectionAndValue.value)
    } else if (sectionAndValue.section == 'across') {
      acrossFirstLine = firstLine
      acrossLastLine = lastLine
    } else if (sectionAndValue.section == 'down') {
      downFirstLine = firstLine
      downLastLine = lastLine
    } else if (sectionAndValue.section == 'nodir') {
      nodirFirstLine = firstLine
      nodirLastLine = lastLine
    } else if (sectionAndValue.section == 'option') {
      parseOption(sectionAndValue.value)
    } else if (sectionAndValue.section == 'explanations') {
      explanationsFirstLine = firstLine
      explanationsLastLine = lastLine
    }
    sectionAndValue = nextSectionAndValue
  }
}

// Extracts the prelude from its previously identified lines and sets up
// its display.
function parseAndDisplayPrelude() {
  if (preludeFirstLine >= 0 && preludeFirstLine <= preludeLastLine) {
    var preludeText = puzzleTextLines[preludeFirstLine]
    var l = preludeFirstLine + 1
    while (l <= preludeLastLine) {
      preludeText = preludeText + '\n' + puzzleTextLines[l]
      l++;
    }
    document.getElementById('prelude').innerHTML = preludeText
  }
}

// Extracts the explanations section from its previously identified lines,
// populates its element, and adds it to revelationList.
function parseAndDisplayExplanations() {
  if (explanationsFirstLine >= 0 &&
      explanationsFirstLine <= explanationsLastLine) {
    var explanationsText = puzzleTextLines[explanationsFirstLine]
    var l = explanationsFirstLine + 1
    while (l <= explanationsLastLine) {
      explanationsText = explanationsText + '\n' + puzzleTextLines[l]
      l++;
    }
    var explanations = document.getElementById('explanations')
    explanations.innerHTML = explanationsText
    revelationList.push(explanations)
  }
}

// Append an error message to the errors div. Scuttle everything by seting
// gridWidth to 0.
function addError(error) {
  document.getElementById('errors').innerHTML =
      document.getElementById('errors').innerHTML + '<br/>' +
      error;
  gridWidth = 0
}

// Run some checks for serious problems with grid id, dimensions, etc. If found,
// abort with error.
function checkIdAndConsistency() {
  if (puzzleId.match(/[^a-zA-Z\d-]/)) {
    addError('Puzzle id should only have alphanumeric characters or -: ' +
             puzzleId)
    return
  }
  if (gridWidth < 1 || gridWidth > 25 || gridHeight < 1 || gridHeight > 25) {
    addError('Bad/missing width/height');
    return
  } else if (gridFirstLine < 0 || gridLastLine < gridFirstLine ||
             gridHeight != gridLastLine - gridFirstLine + 1) {
    addError('Mismatched width/height');
    return
  }
  for (var i = 0; i < gridHeight; i++) {
    var lineW = puzzleTextLines[i + gridFirstLine].toUpperCase().
                    replace(/[^A-Z.0]/g, '').length
    if (gridWidth != lineW) {
      addError('Width in row ' + i + ' is ' + lineW + ', not ' + gridWidth);
      return
    }
  }
  if (submitURL && submitKeys.length != answersList.length + 1) {
    addError('Have ' + submitKeys.length + ' submit paramater keys, need ' +
             (answersList.length + 1));
    return
  }
}

// Parse grid lines into a gridWidth x gridHeight array of objects that have
// the following properties:
//   isLight
//   hasBarAfter
//   hasBarUnder
//   hasCircle
//   isDiagramless
//   startsClueLabel
//   startsAcrossClue
//   startsDownClue
//   acrossClueLabel: #
//   downClueLabel: #
// Also set the following globals:
//   hasDiagramlessCells
//   hasUnsolvedCells
function parseGrid() {
  var hasSolvedCells = false
  for (var i = 0; i < gridHeight; i++) {
    grid[i] = new Array(gridWidth)
    var gridLine = puzzleTextLines[i + gridFirstLine].
                       replace(/\s/g, '').toUpperCase()
    var gridLineIndex = 0
    for (var j = 0; j < gridWidth; j++) {
      grid[i][j] = {};
      var letter = gridLine.charAt(gridLineIndex);
      if (letter != '.') {
        grid[i][j].isLight = true
        if (letter != '0') {
          letter = letter.toUpperCase()
          if (letter < 'A' || letter > 'Z') {
            addError('Bad grid entry: ' + letter);
            gridWidth = 0
            return
          }
          grid[i][j].solution = letter
          hasSolvedCells = true
        }
      } else {
        grid[i][j].isLight = false
      }
      grid[i][j].hasBarAfter = false
      grid[i][j].hasBarUnder = false
      grid[i][j].hasCircle = false
      grid[i][j].isDiagramless = false
      gridLineIndex++
      var thisChar = ''
      while (gridLineIndex < gridLine.length &&
             (thisChar = gridLine.charAt(gridLineIndex)) &&
             (thisChar == '|' ||
              thisChar == '_' ||
              thisChar == '+' ||
              thisChar == '@' ||
              thisChar == '*' ||
              thisChar == ' ')) {
        if (thisChar == '|') {
          grid[i][j].hasBarAfter = true
        } else if (thisChar == '_') {
          grid[i][j].hasBarUnder = true
        } else if (thisChar == '+') {
          grid[i][j].hasBarAfter = true
          grid[i][j].hasBarUnder = true
        } else if (thisChar == '@') {
          grid[i][j].hasCircle = true
        } else if (thisChar == '*') {
          grid[i][j].isDiagramless = true
        } else if (thisChar == ' ') {
        } else {
          addError('Should not happen! thisChar = ' + thisChar);
          return
        }
        gridLineIndex++
      }
      if (grid[i][j].isDiagramless && letter == '.') {
        grid[i][j].solution = '1'
      }
      if (grid[i][j].isDiagramless) {
        hasDiagramlessCells = true
      }
      if (letter == '0') {
        hasUnsolvedCells = true
      }
    }
  }
  if (hasUnsolvedCells && hasSolvedCells) {
    addError('Either all or no solutions should be provided')
  }
}

function startsAcrossClue(i, j) {
  if (!grid[i][j].isLight) {
    return false;
  }
  if (j > 0 && grid[i][j - 1].isLight && !grid[i][j - 1].hasBarAfter) {
    return false;
  }
  if (grid[i][j].hasBarAfter) {
    return false;
  }
  if (j == gridWidth - 1) {
    return false;
  }
  if (!grid[i][j + 1].isLight) {
    return false;
  }
  return true;
}

function startsDownClue(i, j) {
  if (!grid[i][j].isLight) {
    return false;
  }
  if (i > 0 && grid[i - 1][j].isLight && !grid[i - 1][j].hasBarUnder) {
    return false;
  }
  if (grid[i][j].hasBarUnder) {
    return false;
  }
  if (i == gridHeight - 1) {
    return false;
  }
  if (!grid[i + 1][j].isLight) {
    return false;
  }
  return true;
}

// Sets starts{Across,Down}Clue (boolean) and startsClueLabel (#) in
// grid[i][j]s where clues start.
function markClueStartsUsingGrid() {
  if (hasDiagramlessCells && hasUnsolvedCells) {
    // Cannot rely on grid. Clue starts should be provided in clues using
    // prefixes like #a8, #d2, etc.
    return
  }
  var nextClueNumber = 1
  for (var i = 0; i < gridHeight; i++) {
    for (var j = 0; j < gridWidth; j++) {
      if (startsAcrossClue(i, j)) {
        grid[i][j].startsAcrossClue = true
        grid[i][j].startsClueLabel = '' + nextClueNumber
        clues['A' + nextClueNumber] =  {'cells': []}
      }
      if (startsDownClue(i, j)) {
        grid[i][j].startsDownClue = true
        grid[i][j].startsClueLabel = '' + nextClueNumber
        clues['D' + nextClueNumber] =  {'cells': []}
      }
      if (grid[i][j].startsClueLabel) {
        nextClueNumber++
      }
    }
  }
}

// Parse a cell location in "chess notation" (a1 = bottom-left, etc.) and
// return a two-element array [row, col].
function parseCellLocation(s) {
  s = s.trim()
  var col = s.charCodeAt(0) - 'a'.charCodeAt(0)
  var row = gridHeight - parseInt(s.substr(1))
  if (isNaN(row) || isNaN(col) ||
      row < 0 || row >= gridHeight || col < 0 || col >= gridWidth) {
    return null
  }
  return [row, col];
}

// Parse an enum like (4) or (4,5), or (5-2,4).
// Return an object with the following properties:
// len
// hyphenAfter[] (0-based indices)
// wordEndAfter[] (0-based indices)
// afterEnum index after enum
function parseEnum(clueLine) {
  var parse = {
    'len': 0,
    'wordEndAfter': [],
    'hyphenAfter': [],
    'afterEnum': clueLine.length,
  };
  var enumLocation = clueLine.search(/\([1-9]+[0-9\-,'’\s]*\)/)
  if (enumLocation < 0) {
    // Look for the the string 'word'/'letter'/? in parens.
    enumLocation = clueLine.search(/\([^)]*(word|letter|\?)[^)]*\)/i)
    if (enumLocation >= 0) {
      var enumEndLocation =
          enumLocation + clueLine.substr(enumLocation).indexOf(')')
      if (enumEndLocation <= enumLocation) {
        return parse
      }
      parse.afterEnum = enumEndLocation + 1
    }
    return parse
  }
  var enumEndLocation =
      enumLocation + clueLine.substr(enumLocation).indexOf(')')
  if (enumEndLocation <= enumLocation) {
    return parse
  }
  parse.afterEnum = enumEndLocation + 1
  var enumLeft = clueLine.substring(enumLocation + 1, enumEndLocation)
  var nextPart
  while (enumLeft && (nextPart = parseInt(enumLeft)) && !isNaN(nextPart) &&
         nextPart > 0) {
    parse.len = parse.len + nextPart
    enumLeft = enumLeft.replace(/\s*\d+\s*/, '')
    var nextSymbol = enumLeft.substr(0, 1)
    if (nextSymbol == '-') {
      parse.hyphenAfter.push(parse.len - 1)
      enumLeft = enumLeft.substr(1)
    } else if (nextSymbol == ',') {
      parse.wordEndAfter.push(parse.len - 1)
      enumLeft = enumLeft.substr(1)
    } else if (nextSymbol == '\'') {
      enumLeft = enumLeft.substr(1)
    } else if (enumLeft.indexOf('’') == 0) {
      // Fancy apostrophe
      enumLeft = enumLeft.substr('’'.length)
    } else {
      break;
    }
  }
  return parse
}

// Parse a clue label from the start of clueLine.
// Return an object with the following properties:
// error
// clueLabel
// isNonNum
// dir
// hasChildren
// skip
function parseClueLabel(clueLine) {
  var parse = {};
  parse.dir = ''
  parse.hasChilden = false
  parse.skip = 0
  numberParts = clueLine.match(/^\s*[1-9]\d*/)
  if (numberParts && numberParts.length == 1) {
    var clueNum = parseInt(numberParts[0])
    parse.clueLabel = '' + clueNum
    parse.isNonNum = false
    parse.skip = numberParts[0].length
  } else {
    var bracOpenParts = clueLine.match(/^\s*\[/)
    if (!bracOpenParts || bracOpenParts.length != 1) {
      parse.error = 'Missing leading [ in non-numeric clue label in ' + clueLine
      return
    }
    var pastBracOpen = bracOpenParts[0].length
    var bracEnd = clueLine.indexOf(']')
    if (bracEnd < 0) {
      parse.error = 'Missing matching ] in clue label in ' + clueLine
      return
    }
    parse.clueLabel = clueLine.substring(pastBracOpen, bracEnd).trim()
    var temp = parseInt(parse.clueLabel)
    if (!isNaN(temp)) {
      parse.error = 'Numeric label not allowed in []: ' + clueLabel
      return
    }
    parse.isNonNum = true
    parse.skip = bracEnd + 1
  }
  clueLine = clueLine.substr(parse.skip)
  dirParts = clueLine.match(/^[aAdD]/)  // no leading space
  if (dirParts && dirParts.length == 1) {
    parse.dir = dirParts[0].trim().toUpperCase()
    parse.skip += dirParts[0].length
    clueLine = clueLine.substr(dirParts[0].length)
  }
  commaParts = clueLine.match(/^\s*,/)
  if (commaParts && commaParts.length == 1) {
    parse.hasChildren = true
    parse.skip += commaParts[0].length
    clueLine = clueLine.substr(commaParts[0].length)
  }
  return parse
}

// Parse a single clue.
// Return an object with the following properties:
// clueIndex
// clueLabel
// isNonNum
// children[]  (raw parseClueLabel() resutls, not yet clueIndices)
// clue
// len
// hyphenAfter[] (0-based indices)
// wordEndAfter[] (0-based indices)
// startCell[] optional, used in diagramless+unsolved and nonth -numeric labels
// anno (the part after the enum, if present)
function parseClue(dir, clueLine) {
  var parse = {};
  clueLine = clueLine.trim()
  if (clueLine.indexOf('#') == 0) {
    var startCell = parseCellLocation(clueLine.substr(1));
    if (startCell) {
      parse.startCell = startCell
    }  
    clueLine = clueLine.replace(/^#[a-z][0-9]*\s*/, '')
  }

  var clueLabelParse = parseClueLabel(clueLine)
  if (clueLabelParse.error) {
    addError(clueLabelParse.error)
    return
  }
  if (clueLabelParse.dir && clueLabelParse.dir != dir) {
    addError('Explicit dir ' + clueLabelParse.dir + ' does not match ' + dir + ' in clue: ' + clueLine)
    return
  }
  parse.clueLabel = clueLabelParse.clueLabel
  parse.isNonNum = clueLabelParse.isNonNum
  var clueIndex = dir + parse.clueLabel
  if (parse.isNonNum) {
    var nonNumIndex = dir + '#' + (nextNonNumId++)
    if (!nonNumClueIndices[parse.clueLabel]) {
      nonNumClueIndices[parse.clueLabel] = []
    }
    nonNumClueIndices[parse.clueLabel].push(nonNumIndex)
    clueIndex = nonNumIndex
  }
  parse.clueIndex = clueIndex

  clueLine = clueLine.substr(clueLabelParse.skip)
  parse.children = []
  while (clueLabelParse.hasChildren) {
    clueLabelParse = parseClueLabel(clueLine)
    if (clueLabelParse.error) {
      addError('Error in linked clue number/label: ' + clueLabelParse.error)
      return
    }
    parse.children.push(clueLabelParse)
    clueLine = clueLine.substr(clueLabelParse.skip)
  }

  var enumParse = parseEnum(clueLine)
  parse.len = enumParse.len
  parse.hyphenAfter = enumParse.hyphenAfter
  parse.wordEndAfter = enumParse.wordEndAfter
  parse.clue = clueLine.substr(0, enumParse.afterEnum)
  parse.anno = clueLine.substr(enumParse.afterEnum).trim()

  return parse
}

// Parse across and down clues from their exolve sections previously
// identified by parseOverallDisplayMost().
function parseClueLists() {
  // Parse across, down, nodir clues
  for (var clueDirection of ['A', 'D', 'X']) {
    var first, last
    if (clueDirection == 'A') {
      first = acrossFirstLine
      last = acrossLastLine
    } else if (clueDirection == 'D') {
      first = downFirstLine
      last = downLastLine
    } else {
      first = nodirFirstLine
      last = nodirLastLine
    }
    if (first < 0 || last < first) {
      continue
    }
    for (var l = first; l <= last; l++) {
      var clueLine = puzzleTextLines[l].trim();
      if (clueLine == '') {
        continue;
      }
      var clueParse = parseClue(clueDirection, clueLine)
      if (!clueParse.clueIndex) {
        addError('Could not parse clue: ' + clueLine);
        return
      }
      if (clues[clueParse.clueIndex] && clues[clueParse.clueIndex].clue) {
        addError('Clue entry already exists for clue: ' + clueLine);
        return
      }
      if (!clues[clueParse.clueIndex]) {
        clues[clueParse.clueIndex] =  {'cells': []}
      }
      clues[clueParse.clueIndex].clue = clueParse.clue
      clues[clueParse.clueIndex].clueLabel = clueParse.clueLabel
      clues[clueParse.clueIndex].isNonNum = clueParse.isNonNum
      clues[clueParse.clueIndex].displayLabel = clueParse.clueLabel
      clues[clueParse.clueIndex].clueDirection = clueDirection
      clues[clueParse.clueIndex].fullDisplayLabel = clueParse.clueLabel
      if (clueDirection != 'X' && clueParse.clueLabel) {
        clues[clueParse.clueIndex].fullDisplayLabel =
           clues[clueParse.clueIndex].fullDisplayLabel + clueDirection.toLowerCase()
      }
      clues[clueParse.clueIndex].children = clueParse.children
      clues[clueParse.clueIndex].childrenClueIndices = []
      clues[clueParse.clueIndex].len = clueParse.len
      clues[clueParse.clueIndex].hyphenAfter = clueParse.hyphenAfter
      clues[clueParse.clueIndex].wordEndAfter = clueParse.wordEndAfter
      clues[clueParse.clueIndex].anno = clueParse.anno
      if (clueParse.startCell) {
        var row = clueParse.startCell[0]
        var col = clueParse.startCell[1]
        grid[row][col].startsClueLabel = clueParse.clueLabel
        grid[row][col].forcedClueLabel = true
        if (clueDirection == 'A') {
          grid[row][col].startsAcrossClue = true
        } else if (clueDirection == 'D') {
          grid[row][col].startsDownClue = true
        }
      }
    }
  }
  for (var clueIndex in clues) {
    if (!clues.hasOwnProperty(clueIndex)) {
      continue
    }
    if (!clues[clueIndex].clue) {
      // A clue whose existence was inferred from the grid, but no actual
      // clue was provided, hopefull deliberately.
      continue
    }
    allClueIndices.push(clueIndex) 
  }
}

// For each cell grid[i][j], set in{Across,Down}Clue using previously
// marked clue starts.
function setClueMemberships() {
  // Set across clue memberships
  for (var i = 0; i < gridHeight; i++) {
    var clueLabel = ''
    for (var j = 0; j < gridWidth; j++) {
      if (grid[i][j].startsAcrossClue) {
        clueLabel = grid[i][j].startsClueLabel
      }
      if (!clueLabel) {
        continue
      }
      if (!grid[i][j].isLight || grid[i][j].isDiagramless) {
        clueLabel = '';
        continue
      }
      grid[i][j].acrossClueLabel = clueLabel
      var clueIndex = 'A' + clueLabel
      if (!clues[clueIndex]) {
        clueIndex = 'X' + clueLabel
      }
      if (!clues[clueIndex]) {
        if (!nonNumClueIndices[clueLabel]) {
          clueLabel = ''
          continue
        }
        clueIndex = ''
        for (ci of nonNumClueIndices[clueLabel]) {
          if (ci.charAt(0) == 'A' || ci.charAt(0) == 'X') {
            clueIndex = ci
            break
          }
        }
        if (!clueIndex) {
          clueLabel = ''
          continue
        }
      }
      clues[clueIndex].cells.push([i, j])
    }
  }
  // Set down clue memberships
  for (var j = 0; j < gridWidth; j++) {
    var clueLabel = ''
    for (var i = 0; i < gridHeight; i++) {
      if (grid[i][j].startsDownClue) {
        clueLabel = grid[i][j].startsClueLabel
      }
      if (!clueLabel) {
        continue
      }
      if (!grid[i][j].isLight || grid[i][j].isDiagramless) {
        clueLabel = '';
        continue
      }
      grid[i][j].downClueLabel = clueLabel
      var clueIndex = 'D' + clueLabel
      if (!clues[clueIndex]) {
        clueIndex = 'X' + clueLabel
      }
      if (!clues[clueIndex]) {
        if (!nonNumClueIndices[clueLabel]) {
          clueLabel = ''
          continue
        }
        clueIndex = ''
        for (ci of nonNumClueIndices[clueLabel]) {
          if (ci.charAt(0) == 'D' || ci.charAt(0) == 'X') {
            clueIndex = ci
            break
          }
        }
        if (!clueIndex) {
          clueLabel = ''
          continue
        }
      }
      clues[clueIndex].cells.push([i, j])
    }
  }
}

// For clues that have "child" clues (indicated like, '2, 13, 14' for parent 2,
// child 13, child 14), save the parent-child relationships, and successor grid
// cells for last cells in component clues, and spilled-over hyphenAfter and
// wordEndAfter locations.
function processClueChildren() {
  for (var clueIndex of allClueIndices) {
    var clue = clues[clueIndex]
    if (!clue.children) {
      continue
    }
    // Process children
    // We also need to note the successor of he last cell from the parent
    // to the first child, and then from the first child to the next, etc.
    var lastRowCol = null
    if (clue.cells.length > 0) {
      lastRowCol = clue.cells[clue.cells.length - 1]
      // If we do not know the enum of this clue (likely a diagramless puzzle),
      // do not set successors.
      if (!clue.len || clue.len <= 0) {
        lastRowCol = null
      }
    }
    var lastRowColDir = clue.clueDirection
    dupes = {}
    var allDirections = ['A', 'D', 'X']
    for (var child of clue.children) {
      if (child.error) {
        addError('Bad child ' + child + ' in ' +
                 clue.cluelabel + clue.clueDirection);
        return
      }
      // Direction could be the same as the direction of the parent. Or,
      // if there is no such clue, then direction could be the other direction.
      // The direction could also be explicitly specified with a 'd' or 'a'
      // suffix.
      var childIndex = clue.clueDirection + child.clueLabel
      if (!child.isNonNum) {
        if (!clues[childIndex]) {
          for (var otherDir of allDirections) {
            if (otherDir == clue.clueDirection) {
              continue;
            }
            childIndex = otherDir + child.clueLabel
            if (clues[childIndex]) {
              break
            }
          }
        }
        if (child.dir) {
          childIndex = child.dir + child.clueLabel
        }
      } else {
        if (!nonNumClueIndices[child.clueLabel] ||
            nonNumClueIndices[child.clueLabel].length < 1) {
          addError('non-num child label ' + child.clueLabel + ' was not seen')
          return
        }
        childIndex = nonNumClueIndices[child.clueLabel][0]
      }
      if (!clues[childIndex] || childIndex == clueIndex) {
        addError('Invalid child ' + childIndex + ' in ' +
                 clue.cluelabel + clue.clueDirection);
        return
      }
      if (dupes[childIndex]) {
        addError('Duplicate child ' + childIndex + ' in ' +
                 clue.cluelabel + clue.clueDirection);
        return
      }
      dupes[childIndex] = true
      if (child.clueLabel) {
        clue.displayLabel = clue.displayLabel + ', ' + child.clueLabel
        if (child.dir && child.dir != clue.clueDirection) {
          clue.displayLabel = clue.displayLabel + child.dir.toLowerCase()
        }
        clue.fullDisplayLabel = clue.fullDisplayLabel + ', ' + child.clueLabel
        if (childIndex.charAt(0) != 'X') {
          clue.fullDisplayLabel = clue.fullDisplayLabel + childIndex.charAt(0).toLowerCase()
        }
      }
      clue.childrenClueIndices.push(childIndex)
      var childClue = clues[childIndex]
      childClue.parentClueIndex = clueIndex

      if (lastRowCol && childClue.cells.length > 0) {
        var cell = childClue.cells[0]
        if (lastRowCol[0] == cell[0] && lastRowCol[1] == cell[1]) {
          addError('loop in successor for ' + lastRowCol)
          return
        } else {
          grid[lastRowCol[0]][lastRowCol[1]]['successor' + lastRowColDir] = {
            'cell': cell,
            'direction': childClue.clueDirection
          };
        }
      }

      lastRowCol = null
      if (childClue.cells.length > 0) {
        lastRowCol = childClue.cells[childClue.cells.length - 1]
        if (!childClue.len || childClue.len <= 0) {
          lastRowCol = null
        }
      }
      lastRowColDir = childClue.clueDirection
    }
    if (hasDiagramlessCells) {
      continue
    }
    // If clue.wordEndAfter[] or clue.hyphenAfter() spill into children,
    // then copy the appropriate parts there.
    var prevLen = clue.cells.length
    var wordEndIndex = 0
    while (wordEndIndex < clue.wordEndAfter.length &&
           clue.wordEndAfter[wordEndIndex] < prevLen) {
      wordEndIndex++;
    }
    var hyphenIndex = 0
    while (hyphenIndex < clue.hyphenAfter.length &&
           clue.hyphenAfter[hyphenIndex] < prevLen) {
      hyphenIndex++;
    }
    for (var childIndex of clue.childrenClueIndices) {
      var childLen = clues[childIndex].cells.length
      while (wordEndIndex < clue.wordEndAfter.length &&
             clue.wordEndAfter[wordEndIndex] < prevLen + childLen) {
        var pos = clue.wordEndAfter[wordEndIndex] - prevLen
        clues[childIndex].wordEndAfter.push(pos)
        wordEndIndex++
      }
      while (hyphenIndex < clue.hyphenAfter.length &&
             clue.hyphenAfter[hyphenIndex] < prevLen + childLen) {
        var pos = clue.hyphenAfter[hyphenIndex] - prevLen
        clues[childIndex].hyphenAfter.push(pos)
        hyphenIndex++
      }
      prevLen = prevLen + childLen
    }
  }
}

// Place a trailing period and space at the end of clue full display labels that
// are not empty.
function fixFullDisplayLabels() {
  for (var clueIndex of allClueIndices) {
    if (clues[clueIndex].fullDisplayLabel) {
      clues[clueIndex].fullDisplayLabel = clues[clueIndex].fullDisplayLabel + '. '
    }
  }
}

// Using hyphenAfter[] and wordEndAfter[] in clues, set
// {hyphen,wordEnd}{ToRight,Below} in grid[i][j]s.
function setGridWordEndsAndHyphens() {
  if (hasDiagramlessCells) {
    // Give up on this
    return
  }
  // Going across
  for (var i = 0; i < gridHeight; i++) {
    var clueLabel = ''
    var clueIndex = ''
    var positionInClue = -1
    for (var j = 0; j < gridWidth; j++) {
      if (!grid[i][j].acrossClueLabel) {
        clueLabel = ''
        clueIndex = ''
        positionInClue = -1
        continue
      }
      if (clueLabel == grid[i][j].acrossClueLabel) {
        positionInClue++
      } else {
        clueLabel = grid[i][j].acrossClueLabel
        positionInClue = 0
        clueIndex = 'A' + clueLabel
        if (!clues[clueIndex]) {
          if (!nonNumClueIndices[clueLabel]) {
            clueLabel = ''
            clueIndex = ''
            positionInClue = -1
            continue
          }
          for (ci of nonNumClueIndices[clueLabel]) {
            if (ci.charAt(0) == 'A' || ci.charAt(0) == 'X') {
              clueIndex = ci
              break
            }
          }
        }
        if (!clues[clueIndex] || !clues[clueIndex].clue) {
          clueLabel = ''
          clueIndex = ''
          positionInClue = -1
          continue
        }
      }
      for (var wordEndPos of clues[clueIndex].wordEndAfter) {
        if (positionInClue == wordEndPos && j < gridWidth - 1) {
          grid[i][j].wordEndToRight = true
          break
        }
      }
      for (var hyphenPos of clues[clueIndex].hyphenAfter) {
        if (positionInClue == hyphenPos && j < gridWidth - 1) {
          grid[i][j].hyphenToRight = true
          break
        }
      }
    }
  }
  // Going down
  for (var j = 0; j < gridWidth; j++) {
    var clueLabel = ''
    var clueIndex = ''
    var positionInClue = -1
    for (var i = 0; i < gridHeight; i++) {
      if (!grid[i][j].downClueLabel) {
        clueLabel = ''
        clueIndex = ''
        positionInClue = -1
        continue
      }
      if (clueLabel == grid[i][j].downClueLabel) {
        positionInClue++
      } else {
        clueLabel = grid[i][j].downClueLabel
        positionInClue = 0
        clueIndex = 'D' + clueLabel
        if (!clues[clueIndex]) {
          if (!nonNumClueIndices[clueLabel]) {
            clueLabel = ''
            clueIndex = ''
            positionInClue = -1
            continue
          }
          for (ci of nonNumClueIndices[clueLabel]) {
            if (ci.charAt(0) == 'D' || ci.charAt(0) == 'X') {
              clueIndex = ci
              break
            }
          }
        }
        if (!clues[clueIndex] || !clues[clueIndex].clue) {
          clueLabel = ''
          clueIndex = ''
          positionInClue = -1
          continue
        }
      }
      for (var wordEndPos of clues[clueIndex].wordEndAfter) {
        if (positionInClue == wordEndPos && i < gridHeight - 1) {
          grid[i][j].wordEndBelow = true
          break
        }
      }
      for (var hyphenPos of clues[clueIndex].hyphenAfter) {
        if (positionInClue == hyphenPos && i < gridHeight - 1) {
          grid[i][j].hyphenBelow = true
          break
        }
      }
    }
  }
}

function displayClues() {
  // Populate clues tables. Check that we have all clues
  for (var clueIndex of allClueIndices) {
    if (!clues[clueIndex].clue && !clues[clueIndex].parentClueIndex) {
      addError('Found no clue text nor a parent clue for ' + clueIndex)
      return
    }
    var table = null
    if (clues[clueIndex].clueDirection == 'A') {
      table = acrossClues
      hasAcrossClues = true
    } else if (clues[clueIndex].clueDirection == 'D') {
      table = downClues
      hasDownClues = true
    } else if (clues[clueIndex].clueDirection == 'X') {
      table = nodirClues
      hasNodirClues = true
    } else {
      addError('Unexpected clue direction ' + clues[clueIndex].clueDirection + ' in ' + clueIndex)
      return
    }
    var tr = document.createElement('tr')
    var col1 = document.createElement('td')
    col1.innerHTML = clues[clueIndex].displayLabel
    var col2 = document.createElement('td')
    col2.innerHTML = clues[clueIndex].clue
    if (clues[clueIndex].anno) {
      var anno = document.createElement('span')
      anno.setAttributeNS(null, 'class', 'anno-text');
      anno.innerHTML = ' ' + clues[clueIndex].anno
      anno.style.display = 'none'
      revelationList.push(anno)
      col2.appendChild(anno)
    }
    tr.appendChild(col1)
    tr.appendChild(col2)
    if (clues[clueIndex].cells.length > 0) {
      var i = clues[clueIndex].cells[0][0]
      var j = clues[clueIndex].cells[0][1]
      tr.addEventListener('click', getRowColDirActivator(
          i, j, clues[clueIndex].clueDirection));
    } else {
      // Fully diagramless. Just select clue.
      tr.addEventListener('click', getClueSelector(clueIndex));
    }
    clues[clueIndex].clueTR = tr
    table.appendChild(tr)
  }
  if (cluesPanelLines > 0) {
    var ems = 1.40 * cluesPanelLines
    var emsStyle = '' + ems + 'em'
    acrossPanel.style.height = emsStyle
    downPanel.style.height = emsStyle
    if (nodirPanel) {
      nodirPanel.style.height = emsStyle
    }
  }
  if (hasAcrossClues) {
    acrossPanel.style.display = ''
  }
  if (hasDownClues) {
    downPanel.style.display = ''
  }
  if (hasNodirClues) {
    nodirPanel.style.display = ''
  }
}

function displayGridBackground() {
  svg.setAttributeNS(null, 'viewBox', '0 0 ' + boxWidth + ' ' + boxHeight)
  svg.setAttributeNS(null, 'width', boxWidth);
  svg.setAttributeNS(null, 'height', boxHeight);

  background.setAttributeNS(null, 'x', 0);
  background.setAttributeNS(null, 'y', 0);
  background.setAttributeNS(null, 'width', boxWidth);
  background.setAttributeNS(null, 'height', boxHeight);
  background.setAttributeNS(null, 'class', 'background');
  svg.appendChild(background);
}

// Return a string encoding the current entries in the whole grid and
// also the number of squares that have been filled.
function getGridStateAndNumFilled() {
  var state = '';
  var numFilled = 0
  for (var i = 0; i < gridHeight; i++) {
    for (var j = 0; j < gridWidth; j++) {
      if (grid[i][j].isLight || grid[i][j].isDiagramless) {
        var letter = grid[i][j].currentLetter.trim()
        if (letter == '') {
           state = state + '0'
        } else {
           state = state + letter
           numFilled++
        }
      } else {
        state = state + '.'
      }
    }
  }
  return [state, numFilled];
}

// Update status, ensure answer fields are upper-case (when they have
// an enum), disable buttons as needed, and return the state.
function updateDisplayAndGetState() {
  var stateAndFilled = getGridStateAndNumFilled();
  var state = stateAndFilled[0]
  var numFilled = stateAndFilled[1]
  statusNumFilled.innerHTML = numFilled
  for (var a of answersList) {
    if (a.hasEnum) {
      a.input.value = a.input.value.toUpperCase()
    }
  }
  clearButton.disabled = (activeCells.length == 0)
  checkButton.disabled = (activeCells.length == 0)
  revealButton.disabled = (activeCells.length == 0)
  submitButton.disabled = (numFilled != numCellsToFill)
  return state
}

// Call updateDisplayAndGetState() and save state in cookie/location.hash.
function updateAndSaveState() {
  var state = updateDisplayAndGetState()
  for (var a of answersList) {
    state = state + STATE_SEP + a.input.value
  }

  // Keep cookie for these many days
  var KEEP_FOR_DAYS = 90

  var d = new Date();
  d.setTime(d.getTime() + (KEEP_FOR_DAYS * 24 * 60 * 60 * 1000));
  var expires = 'expires=' + d.toUTCString();
  document.cookie = puzzleId + '=' + state + ';' + expires + ';path=/';
  if (location.protocol.substr(0, 4) != 'http' || location.hash) {
    // Also save in location.hash as Chrome does not support cookies on file:
    location.hash = '#' + state
  }
  if (savingURL) {
    savingURL.href = location.href
    if (!location.hash) {
      savingURL.href = location.href + '#' + state
    }
  }
}

// Restore state from cookie (or location.hash).
function restoreState() {
  var state = decodeURIComponent(location.hash.substr(1))
  if (!state) {
    var name = puzzleId + '=';
    var decodedCookie = decodeURIComponent(document.cookie);
    var ca = decodedCookie.split(';');
    for(var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) == ' ') {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        state = c.substring(name.length, c.length);
      }
    }
  }
  state = state.trim()
  var error = false
  if (state == '') { 
    console.log('No saved state available')
    error = true
  } else if (state.length < (gridWidth * gridHeight)) {
    console.log('Not enough characters in state')
    error = true
  }
  var index = 0
  for (var i = 0; i < gridHeight && !error; i++) {
    for (var j = 0; j < gridWidth && !error; j++) {
      letter = state.charAt(index++);
      if (grid[i][j].isLight || grid[i][j].isDiagramless) {
        if (letter == '0') {
           grid[i][j].currentLetter = ''
        } else if (letter == '1') {
           if (!grid[i][j].isDiagramless) {
             console.log('Unexpected ⬛ in non-diagramless location');
             error = true
             break
           }
           grid[i][j].currentLetter = '1'
        } else {
           if (letter < 'A' || letter > 'Z') {
             console.log('Unexpected letter ' + letter + ' in state');
             error = true
             break
           }
           grid[i][j].currentLetter = letter
        }
      } else {
        if (letter != '.') {
          console.log('Unexpected letter ' + letter + ' in state, expected .');
          error = true
          break
        }
      }
    }
  }
  if (error) {
    for (var i = 0; i < gridHeight; i++) {
      for (var j = 0; j < gridWidth; j++) {
        if (grid[i][j].isLight || grid[i][j].isDiagramless) {
          grid[i][j].currentLetter = ''
        }
      }
    }
  } else {
    // Also try to recover answers to questions
    if (state.substr(index, STATE_SEP.length) == STATE_SEP) {
      var parts = state.substr(index + STATE_SEP.length).split(STATE_SEP)
      if (parts.length == answersList.length) {
        for (var i = 0; i < parts.length; i++) {
          answersList[i].input.value = parts[i]
        }
      }
    }
  }
  var numFilled = 0
  for (var i = 0; i < gridHeight; i++) {
    for (var j = 0; j < gridWidth; j++) {
      if (grid[i][j].isLight || grid[i][j].isDiagramless) {
        if (grid[i][j].currentLetter == '1') {
          grid[i][j].textNode.nodeValue = BLOCK_CHAR
        } else {
          grid[i][j].textNode.nodeValue = grid[i][j].currentLetter
        }
        if (grid[i][j].currentLetter != '') {
          numFilled++
        }
      }
    }
  }
  updateAndSaveState()
}

function deactivateCurrentCell() {
  gridInputWrapper.style.display = 'none'
  for (var x of activeCells) {
    var cellRect = grid[x[0]][x[1]].cellRect
    cellRect.style.fill = 'white'
  }
  for (var x of activeClues) {
    x.style.background = 'white'
  }
  activeCells = [];
  activeClues = [];
  currentClue.innerHTML = ''
  currentClue.style.background = 'transparent'
  currentClue.style.top = '0'
  clearButton.disabled = true
  checkButton.disabled = true
  revealButton.disabled = true
}

function makeCurrentClueVisible() {
  // Check if grid input is visible.
  var inputPos = gridInput.getBoundingClientRect();
  if (inputPos.top < 0) {
    return
  }
  var windowH = getViewportHeight()
  if (!windowH || windowH <= 0) {
    return
  }
  if (inputPos.bottom >= windowH) {
    currentClue.style.top = '0'
    return
  }
  // gridInput is visible
  var cluePos = currentClue.getBoundingClientRect();
  var top = cluePos.top
  var clueParentPos = currentClueParent.getBoundingClientRect();
  var parentTop = clueParentPos.top
  // Reposition
  var newTop = 0
  // If parent is below viewport top, go back to standard position.
  if (parentTop >= 0) {
    currentClue.style.top = '0'
    return
  }
  currentClue.style.top = '' + (0 - parentTop) + 'px';
}

function activateCell(row, col) {
  deactivateCurrentCell();

  currentRow = row
  currentCol = col
  if (row < 0 || row >= gridHeight || col < 0 || col >= gridWidth) {
    return
  }
  if (!grid[row][col].isLight &&
      !grid[row][col].isDiagramless) {
    return;
  }

  gridInputWrapper.style.width = '' + SQUARE_DIM + 'px'
  gridInputWrapper.style.height = '' + SQUARE_DIM + 'px'
  gridInputWrapper.style.left = '' + grid[row][col].cellLeft + 'px'
  gridInputWrapper.style.top = '' + grid[row][col].cellTop + 'px'
  gridInput.value = grid[row][col].currentLetter
  gridInputWrapper.style.display = ''
  gridInput.focus()
  // Try to place the cursor at the end
  if (gridInput.setSelectionRange) {
    var len = gridInput.value.length
    gridInput.setSelectionRange(len, len);
  }
  clearButton.disabled = false
  checkButton.disabled = false
  revealButton.disabled = false

  var activeClueIndex = ''
  var activeClueLabel = ''
  // If the current direction does not have an active clue, toggle direction
  if (currentDirectionIsAcross && !grid[row][col].isDiagramless &&
      !grid[row][col].acrossClueLabel &&
      grid[row][col].downClueLabel) {
    currentDirectionIsAcross = false;
  }
  if (!currentDirectionIsAcross && !grid[row][col].isDiagramless &&
      !grid[row][col].downClueLabel &&
      grid[row][col].acrossClueLabel) {
    currentDirectionIsAcross = true;
  }
  if (currentDirectionIsAcross) {
    if (grid[row][col].acrossClueLabel) {
      activeClueLabel = grid[row][col].acrossClueLabel
      activeClueIndex = 'A' + activeClueLabel
    }
  } else {
    if (grid[row][col].downClueLabel) {
      activeClueLabel = grid[row][col].downClueLabel
      activeClueIndex = 'D' + activeClueLabel
    }
  }
  if (activeClueIndex != '') {
    if (!clues[activeClueIndex]) {
      activeCluwIndex = ''
      if (nonNumClueIndices[activeClueLabel]) {
        for (var ci of nonNumClueIndices[activeClueLabel]) {
          if (ci.charAt(0) == 'X' || ci.charAt(0) == activeClueIndex.charAt(0)) {
            activeClueIndex = ci
            break
          }
        }
      }
      if (!clues[activeClueIndex]) {
        activeClueIndex = ''
      }
    }
  }
  if (activeClueIndex && clues[activeClueIndex]) {
    selectClue(activeClueIndex)
  } else {
    // No active clue, activate just the cell and show all potential clues.
    showAllCluesAsActive()
    grid[row][col].cellRect.style.fill = ACTIVE_COLOUR
    activeCells.push([row, col])
  }
}

// For freezing row/col to deal with JS closure.
function getRowColActivator(row, col) {
  return function() { activateCell(row, col); };
}
function getRowColDirActivator(row, col, dir) {
  return function() {
    if (dir == 'A') {
      currentDirectionIsAcross = true
    } else {
      currentDirectionIsAcross = false
    } 
    activateCell(row, col);
  };
}

function getViewportHeight() {
  return window.innerHeight && document.documentElement.clientHeight ? 
    Math.min(window.innerHeight, document.documentElement.clientHeight) : 
    window.innerHeight || 
    document.documentElement.clientHeight || 
    document.getElementsByTagName('body')[0].clientHeight;
}

// Check if an element is visible, vertically.
function isVisible(elt) {
  var pos = elt.getBoundingClientRect();
  if (pos.bottom < 0) {
    return false
  }
  var windowH = getViewportHeight()
  if (!windowH || windowH <= 0) {
    return false
  }
  if (pos.top >= windowH) {
    return false
  }
  return true
}

// For freezing clueIndex to deal with JS closure.
function getClueSelector(clueIndex) {
  return function() {
    deactivateCurrentCell();
    selectClue(clueIndex);
  };
}
// Select a clicked clue.
function selectClue(activeClueIndex) {
  indexForCurr = activeClueIndex
  var clueIndices = [activeClueIndex]
  if (clues[activeClueIndex].parentClueIndex) {
    var parent = clues[activeClueIndex].parentClueIndex
    indexForCurr = parent
    clueIndices = [parent].concat(clues[parent].childrenClueIndices)
  } else if (clues[activeClueIndex].childrenClueIndices) {
    clueIndices =
        clueIndices.concat(clues[activeClueIndex].childrenClueIndices)
  }
  for (var clueIndex of clueIndices) {
    for (var rowcol of clues[clueIndex].cells) {
      grid[rowcol[0]][rowcol[1]].cellRect.style.fill = ACTIVE_COLOUR
      activeCells.push(rowcol)
    }
    if (!clues[clueIndex].clueTR) {
      continue
    }
    clues[clueIndex].clueTR.style.background = ACTIVE_COLOUR
    if (cluesPanelLines > 0 &&
        isVisible(clues[clueIndex].clueTR.parentElement)) {
      clues[clueIndex].clueTR.scrollIntoView()
    }
    activeClues.push(clues[clueIndex].clueTR)
  }
  curr = clues[indexForCurr]
  if (!curr || !curr.clue) {
    showAllCluesAsActive()
    return
  }
  currentClue.innerHTML = curr.fullDisplayLabel + curr.clue
  currentClue.style.background = ACTIVE_COLOUR;
  makeCurrentClueVisible();
}

function allCluesBrowse(incr) {
  if (allClueIndices.length <= 0) {
    return
  }
  posInAllClueIndices = (posInAllClueIndices + incr) % allClueIndices.length
  if (posInAllClueIndices < 0) {
    posInAllClueIndices += allClueIndices.length
  }
  showAllCluesAsActive()
}

// From a click in a  diagramless cell or a cell without a known clue
// association, show "current-clue" as a browsable widget with all clues.
function showAllCluesAsActive() {
  if (posInAllClueIndices >= allClueIndices.length) {
    return
  }
  var clueIndex = allClueIndices[posInAllClueIndices]
  var displayedClue = clues[clueIndex].fullDisplayLabel + clues[clueIndex].clue
  if (clues[clueIndex].parentClueIndex) {
    var parent = clues[clueIndex].parentClueIndex
    displayedClue = clues[parent].fullDisplayLabel + clues[parent].clue
  }
  currentClue.innerHTML =
    '<span>' +
    '<button class="small-button" onclick="allCluesBrowse(-1)">&lsaquo;</button>' +
    '<span title="You have to figure out which clue to use"> CLUES </span>' +
    '<button class="small-button" onclick="allCluesBrowse(1)">&rsaquo;</button>' +
    '</span> ' +
    displayedClue
  currentClue.style.background = ALL_CLUES_COLOUR;
  makeCurrentClueVisible();
}

function toggleCurrentDirection() {
  // toggle direction
  if (currentRow < 0 || currentRow >= gridHeight ||
      currentCol < 0 || currentCol >= gridWidth) {
    return
  }
  if ((!grid[currentRow][currentCol].acrossClueLabel ||
       !grid[currentRow][currentCol].downClueLabel) &&
      !grid[currentRow][currentCol].isDiagramless) {
    return
  }
  currentDirectionIsAcross = !currentDirectionIsAcross
  activateCell(currentRow, currentCol)
}

// Handle navigation keys. Used by a listener, and also used to auto-advance
// after a cell is filled.
function handleKeyUpInner(key) {
  if (currentRow < 0 || currentRow >= gridHeight ||
      currentCol < 0 || currentCol >= gridWidth) {
    return
  }
  if (key == 8) {
    if (grid[currentRow][currentCol].currentLetter != '') {
      return
    }
    // backspace in an empty cell
    if (currentDirectionIsAcross) {
      key = 37  // left
    } else {
      key = 38  // up
    }
  }
  if (key == 39) {
    // right arrow
    var col = currentCol + 1
    while (col < gridWidth &&
           !grid[currentRow][col].isLight &&
           !grid[currentRow][col].isDiagramless) {
      col++;
    }
    if (col < gridWidth) {
      activateCell(currentRow, col);
    }
  } else if (key == 37) {
    // left arrow
    var col = currentCol - 1
    while (col >= 0 &&
           !grid[currentRow][col].isLight &&
           !grid[currentRow][col].isDiagramless) {
      col--;
    }
    if (col >= 0) {
      activateCell(currentRow, col);
    }
  } else if (key == 40) {
    // down arrow
    var row = currentRow + 1
    while (row < gridHeight &&
           !grid[row][currentCol].isLight &&
           !grid[row][currentCol].isDiagramless) {
      row++;
    }
    if (row < gridHeight) {
      activateCell(row, currentCol);
    }
  } else if (key == 38) {
    // up arrow
    var row = currentRow - 1
    while (row >= 0 &&
           !grid[row][currentCol].isLight &&
           !grid[row][currentCol].isDiagramless) {
      row--;
    }
    if (row >= 0) {
      activateCell(row, currentCol);
    }
  }
}

function handleKeyUp(e) {
  var key = e.which || e.keyCode
  handleKeyUpInner(key)
}

function handleGridInput() {
  if (currentRow < 0 || currentRow >= gridHeight ||
      currentCol < 0 || currentCol >= gridWidth) {
    return
  }
  if (!grid[currentRow][currentCol].isLight &&
      !grid[currentRow][currentCol].isDiagramless) {
    return;
  }
  var newInput = gridInput.value
  if (grid[currentRow][currentCol].currentLetter != '' &&
      newInput != grid[currentRow][currentCol].currentLetter) {
    // The "new" input may be before or after the old input.
    var index = newInput.indexOf(grid[currentRow][currentCol].currentLetter)
    if (index == 0) {
      newInput = newInput.substr(1)
    }
  }
  var keyChar = newInput.substr(0, 1)
  if (keyChar == ' ' && grid[currentRow][currentCol].isDiagramless) {
    // spacebar creates a blocked cell in a diagramless puzzle cell
    keyChar = BLOCK_CHAR
  } else {
    keyChar = keyChar.toUpperCase()
    if (keyChar < 'A' || keyChar > 'Z') {
      // Clear away any random input other than A-Z.
      keyChar = ''
    }
  }
  var letter = keyChar
  if (letter == BLOCK_CHAR) {
    letter = '1'
  }
  var oldLetter = grid[currentRow][currentCol].currentLetter
  grid[currentRow][currentCol].currentLetter = letter
  grid[currentRow][currentCol].textNode.nodeValue = keyChar
  gridInput.value = keyChar
  if (oldLetter == '1' || letter == '1') {
    var symRow = gridHeight - 1 - currentRow
    var symCol = gridWidth - 1 - currentCol
    if (grid[symRow][symCol].isDiagramless) {
      var symLetter = (letter == '1') ? '1' : ''
      var symChar = (letter == '1') ? BLOCK_CHAR : ''
      grid[symRow][symCol].currentLetter = symLetter
      grid[symRow][symCol].textNode.nodeValue = symChar
    }
  }
  updateAndSaveState()

  if (((letter >= 'A' && letter <= 'Z') || letter == '1') &&
      !grid[currentRow][currentCol].isDiagramless) {
    // auto-advance
    // First check if there is successor
    var successorProperty = 'successor' + (currentDirectionIsAcross ? 'A' : 'D')
    if (grid[currentRow][currentCol][successorProperty]) {
      var successor = grid[currentRow][currentCol][successorProperty]
      currentDirectionIsAcross = (successor.direction == 'A')
      activateCell(successor.cell[0], successor.cell[1]);
      return
    }
    if (currentDirectionIsAcross) {
      handleKeyUpInner(39);
    } else {
      handleKeyUpInner(40);
    }
  }
}

function createListeners() {
  gridInput.addEventListener('keyup', function(e) {handleKeyUp(e);});
  gridInput.addEventListener('input', handleGridInput);
  gridInput.addEventListener('click', toggleCurrentDirection);
  background.addEventListener('click', getRowColActivator(-1, -1));
  window.addEventListener('scroll', makeCurrentClueVisible);
}

function displayGrid() {
  numCellsToFill = 0
  for (var i = 0; i < gridHeight; i++) {
    for (var j = 0; j < gridWidth; j++) {
      var cellGroup =
          document.createElementNS('http://www.w3.org/2000/svg', 'g');
      if (grid[i][j].isLight || grid[i][j].isDiagramless) {
        numCellsToFill++
        var cellRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        var cellLeft = GRIDLINE + j * (SQUARE_DIM + GRIDLINE);
        var cellTop = GRIDLINE + i * (SQUARE_DIM + GRIDLINE);
        cellRect.setAttributeNS(
            null, 'x', GRIDLINE + j * (SQUARE_DIM + GRIDLINE));
        cellRect.setAttributeNS(
            null, 'y', GRIDLINE + i * (SQUARE_DIM + GRIDLINE));
        cellRect.setAttributeNS(null, 'width', SQUARE_DIM);
        cellRect.setAttributeNS(null, 'height', SQUARE_DIM);
        cellRect.setAttributeNS(null, 'class', 'cell');
        cellGroup.appendChild(cellRect)

        var cellText =
            document.createElementNS('http://www.w3.org/2000/svg', 'text');
        cellText.setAttributeNS(
            null, 'x', LIGHT_START_X + j * (SQUARE_DIM + GRIDLINE));
        cellText.setAttributeNS(
            null, 'y', LIGHT_START_Y + i * (SQUARE_DIM + GRIDLINE));
        cellText.setAttributeNS(null, 'text-anchor', 'middle');
        cellText.setAttributeNS(null, 'editable', 'simple');
        cellText.setAttributeNS(null, 'class', 'cell-text');
        var text = document.createTextNode('');
        cellText.appendChild(text);
        cellGroup.appendChild(cellText)

        grid[i][j].currentLetter = '';
        grid[i][j].textNode = text;
        grid[i][j].cellText = cellText;
        grid[i][j].cellRect = cellRect;
        grid[i][j].cellLeft = cellLeft;
        grid[i][j].cellTop = cellTop;

        cellText.addEventListener('click', getRowColActivator(i, j));
        cellRect.addEventListener('click', getRowColActivator(i, j));
      }
      if (grid[i][j].hasCircle) {
        var cellCircle =
            document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        cellCircle.setAttributeNS(
            null, 'cx', CIRCLE_RADIUS + GRIDLINE + j * (SQUARE_DIM + GRIDLINE));
        cellCircle.setAttributeNS(
            null, 'cy', CIRCLE_RADIUS + GRIDLINE + i * (SQUARE_DIM + GRIDLINE));
        cellCircle.setAttributeNS(null, 'r', CIRCLE_RADIUS);
        cellCircle.setAttributeNS(null, 'stroke', 'gray');
        cellCircle.setAttributeNS(null, 'fill', TRANSPARENT_WHITE);
        cellGroup.appendChild(cellCircle)
      }
      if (grid[i][j].startsClueLabel && !grid[i][j].isDiagramless &&
          (!hideInferredNumbers || grid[i][j].forcedClueLabel)) {
        var cellNum =
            document.createElementNS('http://www.w3.org/2000/svg', 'text');
        cellNum.setAttributeNS(
            null, 'x', NUMBER_START_X + j * (SQUARE_DIM + GRIDLINE));
        cellNum.setAttributeNS(
            null, 'y', NUMBER_START_Y + i * (SQUARE_DIM + GRIDLINE));
        cellNum.setAttributeNS(null, 'class', 'cell-num');
        var num = document.createTextNode(grid[i][j].startsClueLabel)
        cellNum.appendChild(num);
        cellGroup.appendChild(cellNum)
      }
      svg.appendChild(cellGroup);
    }
  }

  // Bars/word-ends to the right and under; hyphens.
  for (var i = 0; i < gridHeight; i++) {
    for (var j = 0; j < gridWidth; j++) {
      var cellGroup =
          document.createElementNS('http://www.w3.org/2000/svg', 'g');
      var emptyGroup = true
      if (grid[i][j].wordEndToRight) {
        var wordEndRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        wordEndRect.setAttributeNS(
            null, 'x',
            GRIDLINE + (j + 1) * (SQUARE_DIM + GRIDLINE) - SEP_WIDTH_BY2);
        wordEndRect.setAttributeNS(
            null, 'y', GRIDLINE + i * (SQUARE_DIM + GRIDLINE));
        wordEndRect.setAttributeNS(null, 'width', SEP_WIDTH);
        wordEndRect.setAttributeNS(null, 'height', SQUARE_DIM);
        wordEndRect.setAttributeNS(null, 'class', 'wordend');
        cellGroup.appendChild(wordEndRect)
        emptyGroup = false
      }
      if (grid[i][j].wordEndBelow) {
        var wordEndRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        wordEndRect.setAttributeNS(
            null, 'x', GRIDLINE + j * (SQUARE_DIM + GRIDLINE));
        wordEndRect.setAttributeNS(
            null, 'y',
            GRIDLINE + (i + 1) * (SQUARE_DIM + GRIDLINE) - SEP_WIDTH_BY2);
        wordEndRect.setAttributeNS(null, 'width', SQUARE_DIM);
        wordEndRect.setAttributeNS(null, 'height', SEP_WIDTH);
        wordEndRect.setAttributeNS(null, 'class', 'wordend');
        cellGroup.appendChild(wordEndRect)
        emptyGroup = false
      }
      if (grid[i][j].hyphenToRight) {
        var hyphenRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hyphenRect.setAttributeNS(
            null, 'x',
            GRIDLINE + (j + 1) * (SQUARE_DIM + GRIDLINE) - HYPHEN_WIDTH_BY2);
        hyphenRect.setAttributeNS(
            null, 'y', GRIDLINE + i * (SQUARE_DIM + GRIDLINE) +
            SQUARE_DIM_BY2 - SEP_WIDTH_BY2);
        hyphenRect.setAttributeNS(null, 'width', HYPHEN_WIDTH);
        hyphenRect.setAttributeNS(null, 'height', SEP_WIDTH);
        hyphenRect.setAttributeNS(null, 'class', 'wordend');
        cellGroup.appendChild(hyphenRect)
        emptyGroup = false
      }
      if (grid[i][j].hyphenBelow) {
        var hyphenRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hyphenRect.setAttributeNS(
            null, 'x', GRIDLINE + j * (SQUARE_DIM + GRIDLINE) +
            SQUARE_DIM_BY2 - SEP_WIDTH_BY2);
        hyphenRect.setAttributeNS(
            null, 'y',
            GRIDLINE + (i + 1) * (SQUARE_DIM + GRIDLINE) - HYPHEN_WIDTH_BY2);
        hyphenRect.setAttributeNS(null, 'width', SEP_WIDTH);
        hyphenRect.setAttributeNS(null, 'height', HYPHEN_WIDTH);
        hyphenRect.setAttributeNS(null, 'class', 'wordend');
        cellGroup.appendChild(hyphenRect)
        emptyGroup = false
      }
      if (grid[i][j].hasBarAfter) {
        var barRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        barRect.setAttributeNS(
            null, 'x',
            GRIDLINE + (j + 1) * (SQUARE_DIM + GRIDLINE) - BAR_WIDTH_BY2);
        barRect.setAttributeNS(
            null, 'y', GRIDLINE + i * (SQUARE_DIM + GRIDLINE));
        barRect.setAttributeNS(null, 'width', BAR_WIDTH);
        barRect.setAttributeNS(null, 'height', SQUARE_DIM);
        barRect.setAttributeNS(null, 'class', 'background');
        cellGroup.appendChild(barRect)
        emptyGroup = false
      }
      if (grid[i][j].hasBarUnder) {
        var barRect =
            document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        barRect.setAttributeNS(
            null, 'x', GRIDLINE + j * (SQUARE_DIM + GRIDLINE));
        barRect.setAttributeNS(
            null, 'y',
            GRIDLINE + (i + 1) * (SQUARE_DIM + GRIDLINE) - BAR_WIDTH_BY2);
        barRect.setAttributeNS(null, 'width', SQUARE_DIM);
        barRect.setAttributeNS(null, 'height', BAR_WIDTH);
        barRect.setAttributeNS(null, 'class', 'background');
        cellGroup.appendChild(barRect)
        emptyGroup = false
      }
      if (!emptyGroup) {
        svg.appendChild(cellGroup);
      }
    }
  }
  statusNumTotal.innerHTML = numCellsToFill
}

function displayNinas() {
  var NINA_COLORS = [
    'rgba(0,0,255,0.2)',
    'rgba(0,255,0,0.2)',
    'rgba(0,255,255,0.2)',
    'rgba(255,0,255,0.2)',
    'rgba(255,255,0,0.2)',
    'rgba(255,50,50,0.2)',
    'rgba(50,255,50,0.2)',
    'rgba(50,50,255,0.2)',
    'rgba(50,200,200,0.2)',
    'rgba(200,50,200,0.2)',
    'rgba(200,200,50,0.2)',
  ];
  var ninaColorIndex = 0;
  for (var nina of ninas) {
    for (var cellOrClass of nina) {
      if (!Array.isArray(cellOrClass)) {
        // span-class-specified nina
        var elts = document.getElementsByClassName(cellOrClass)
        if (!elts || elts.length == 0) {
          addError('Nina ' + cellOrClass +
                   ' is not a cell location nor a class with html tags');
          return
        }
        for (var elt of elts) {
          ninaClassElements.push({
            'element': elt,
            'colour':  NINA_COLORS[ninaColorIndex],
          });
        }
        continue
      }    
      var row = cellOrClass[0]
      var col = cellOrClass[1]
      var ninaRect = document.createElement('div');
      ninaRect.style.left =  '' +  grid[row][col].cellLeft + 'px';
      ninaRect.style.top = '' + grid[row][col].cellTop + 'px';
      ninaRect.style.width = '' + SQUARE_DIM + 'px';
      ninaRect.style.height = '' + SQUARE_DIM + 'px';
      ninaRect.style.backgroundColor = NINA_COLORS[ninaColorIndex]
      ninaRect.setAttributeNS(null, 'class', 'nina');
      ninaRect.addEventListener('click', getRowColActivator(row, col));
      ninaGroup.appendChild(ninaRect);
    }
    ninaColorIndex = (ninaColorIndex + 1) % NINA_COLORS.length
  }
}

function showNinas() {
  for (var ec of ninaClassElements) {
    ec.element.style.backgroundColor = ec.colour;
  }
  ninaGroup.style.display = '';
  ninasButton.innerHTML = 'Hide ninas'
  showingNinas = true
}

function hideNinas() {
  for (var ec of ninaClassElements) {
    ec.element.style.backgroundColor = 'transparent';
  }
  ninaGroup.style.display = 'none';
  ninasButton.innerHTML = 'Show ninas'
  showingNinas = false
}

function toggleNinas() {
  if (showingNinas) {
    hideNinas()
  } else {
    if (!confirm('Are you sure you want to reveal the nina(s)!?')) {
      return
    }
    showNinas()
  }
}

function clearCurrent() {
  for (var x of activeCells) {
    var row = x[0]
    var col = x[1]
    var oldLetter = grid[row][col].currentLetter
    if (oldLetter != '') {
      grid[row][col].currentLetter = ''
      grid[row][col].textNode.nodeValue = ''
      if (row == currentRow && col == currentCol) {
        gridInput.value = ''
      }
    }
    if (oldLetter == '1') {
      var symRow = gridHeight - 1 - row
      var symCol = gridWidth - 1 - col
      if (grid[symRow][symCol].isDiagramless) {
        grid[symRow][symCol].currentLetter = ''
        grid[symRow][symCol].textNode.nodeValue = ''
      }
    }
  }
  updateAndSaveState()
}

function clearAll() {
  if (!confirm('Are you sure you want to clear the whole grid!?')) {
    return
  }
  for (var row = 0; row < gridHeight; row++) {
    for (var col = 0; col < gridWidth; col++) {
      if (!grid[row][col].isLight && !grid[row][col].isDiagramless) {
        continue
      }
      grid[row][col].currentLetter = ''
      grid[row][col].textNode.nodeValue = ''
      if (row == currentRow && col == currentCol) {
        gridInput.value = ''
      }
    }
  }
  for (var a of answersList) {
    a.input.value = ''
  }
  for (var a of revelationList) {
    a.style.display = 'none'
  }
  hideNinas()
  updateAndSaveState()
}

function checkCurrent() {
  for (var x of activeCells) {
    var row = x[0]
    var col = x[1]
    var oldLetter = grid[row][col].currentLetter
    if (oldLetter == grid[row][col].solution) {
      continue
    }
    grid[row][col].currentLetter = ''
    grid[row][col].textNode.nodeValue = ''
    if (row == currentRow && col == currentCol) {
      gridInput.value = ''
    }
    if (oldLetter == '1') {
      var symRow = gridHeight - 1 - row
      var symCol = gridWidth - 1 - col
      if (grid[symRow][symCol].isDiagramless) {
        grid[symRow][symCol].currentLetter = ''
        grid[symRow][symCol].textNode.nodeValue = ''
      }
    }
  }
  updateAndSaveState()
}

function checkAll() {
  if (!confirm('Are you sure you want to clear mistakes everywhere!?')) {
    return
  }
  for (var row = 0; row < gridHeight; row++) {
    for (var col = 0; col < gridWidth; col++) {
      if (!grid[row][col].isLight && !grid[row][col].isDiagramless) {
        continue
      }
      if (grid[row][col].currentLetter == grid[row][col].solution) {
        continue
      }
      grid[row][col].currentLetter = ''
      grid[row][col].textNode.nodeValue = ''
      if (row == currentRow && col == currentCol) {
        gridInput.value = ''
      }
    }
  }
  updateAndSaveState()
}

function revealCurrent() {
  for (var x of activeCells) {
    var row = x[0]
    var col = x[1]
    var oldLetter = grid[row][col].currentLetter
    var letter = grid[row][col].solution
    if (oldLetter != letter) {
      grid[row][col].currentLetter = letter
      var char = letter
      if (char == '1') {
        char = BLOCK_CHAR
      }  
      grid[row][col].textNode.nodeValue = char
      if (row == currentRow && col == currentCol) {
        gridInput.value = char
      }
    }
    if (oldLetter == '1' || letter == '1') {
      var symRow = gridHeight - 1 - row
      var symCol = gridWidth - 1 - col
      if (grid[symRow][symCol].isDiagramless) {
        var symLetter = (letter == '1') ? '1' : ''
        var symChar = (letter == '1') ? BLOCK_CHAR : ''
        grid[symRow][symCol].currentLetter = symLetter
        grid[symRow][symCol].textNode.nodeValue = symChar
      }
    }
  }
  updateAndSaveState()
}

function revealAll() {
  if (!confirm('Are you sure you want to reveal the whole solution!?')) {
    return
  }
  for (var row = 0; row < gridHeight; row++) {
    for (var col = 0; col < gridHeight; col++) {
      if (!grid[row][col].isLight && !grid[row][col].isDiagramless) {
        continue
      }
      if (grid[row][col].currentLetter != grid[row][col].solution) {
        grid[row][col].currentLetter = grid[row][col].solution
        var char = grid[row][col].solution
        if (char == '1') {
          char = BLOCK_CHAR
        }  
        grid[row][col].textNode.nodeValue = char
        if (row == currentRow && col == currentCol) {
          gridInput.value = char
        }
      }
    }
  }
  for (var a of answersList) {
    if (a.ans) {
      a.input.value = a.ans
    }
  }
  for (var a of revelationList) {
    a.style.display = ''
  }
  showNinas()
  updateAndSaveState()
}

function submitSolution() {
  if (!confirm('Are you sure you are ready to submit!?')) {
    return
  }
  var state = updateDisplayAndGetState()
  var fullSubmitURL = submitURL + '&' + submitKeys[0] + '=' +
                      encodeURIComponent(state)
  for (var i = 0; i < answersList.length; i++) {
     fullSubmitURL = fullSubmitURL + '&' + submitKeys[i + 1] + '=' +
                   encodeURIComponent(answersList[i].input.value.toUpperCase())
  }
  document.body.style.cursor = 'wait'
  window.location.replace(fullSubmitURL)
}

function displayButtons() {
  clearButton.disabled = true
  if (!hasUnsolvedCells) {
    checkButton.style.display = ''
    checkAllButton.style.display = ''
    revealButton.style.display = ''
    revealAllButton.style.display = ''

    checkButton.disabled = true
    revealButton.disabled = true
    submitButton.disabled = true
  }
  if (ninas.length > 0) {
    ninasButton.style.display = ''
  }
  if (submitURL) {
    submitButton.style.display = ''
  }
}

function createPuzzle() {
  init();

  parseOverallDisplayMost();
  parseAndDisplayPrelude();
  parseAndDisplayExplanations();
  checkIdAndConsistency();
  parseGrid();
  markClueStartsUsingGrid();
  parseClueLists();

  setClueMemberships();
  processClueChildren();
  fixFullDisplayLabels()
  setGridWordEndsAndHyphens();
  displayClues();
  displayGridBackground();
  createListeners();
  displayGrid();
  displayNinas();
  displayButtons();

  restoreState();
}

// ------ End functions.

</script>

<style>
.background {
  fill: black;
}
.cell {
  fill: white;
  cursor: pointer;
}
.cell-num {
  font-size: 9px;
  font-family: sans-serif;
}
.cell-text {
  font-size: 16px;
  font-family: sans-serif;
  cursor: text;
}
.wordend {
  fill: rgb(0,0,255);
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
td {
  padding: 4px 6px 0 0;
  vertical-align: top;
}
td:first-child {
  max-width: 45px;
  font-weight: bold;
}
.anno-text {
  font-style: italic;
  color: darkgreen;
}
.flex-row {
  display: flex;
  flex-flow: row wrap;
  align-items: flex-start;
}
.flex-col {
  display: flex;
  flex-flow: column wrap;
}
.wide-box {
  width: 460px;
}
#title {
  text-align: center;
  font-weight: bold;
}
#setter {
  text-align: center;
  color: darkgreen;
  margin: 0 0 8px 0;
}
#prelude {
  margin: 8px 8px 0 8px;
  padding: 0;
}
#small-print {
  font-size: small;
  text-align: right;
}
#errors {
  font-weight: bold;
  color: red;
}
#current-clue-parent {
  height: 40px;
  position:relative;
  margin: 8px 8px 8px 0;
}
#current-clue {
  position: absolute;
  z-index: 2;
  word-wrap: break-word;
  font-weight: bold;
  margin: 0 0 0 8px;
  padding: 4px 4px 4px 0;
}
#grid-panel {
  margin: 0 0 0 8px;
}
#grid-parent-centerer {
  text-align: center;
}
#grid-parent {
  position:relative;
  margin: 0 20px 0 0;
  display: inline-block;
}
#grid-input-wrapper {
  position: absolute;
  border: none;
  border-width:0;
}
#grid-input {
  text-align: center;
  text-anchor: middle;
  border: 0;
  width: 100%;
  height: 100%;
  padding: 0;
  background: rgba(255,255,255,0.0);
}
.controls-row {
  margin: 6px 0 6px 0;
}
.clues-box {
  margin: 0 10px 0 0;
  overflow-y: auto;
}
#explanations {
  margin: 10px 0 0 0;
}
hr {
  margin: 0 0 4px 0;
  background-color: darkgreen;
}
.button {
  background-color: #4CAF50; /* Green */
  border: none;
  outline: none;
  color: white;
  padding: 8px 8px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  border-radius: 12px;
  font-family: monospace;
  font-size: 14px;
}
.button:hover {
  background-color: darkgreen;
  cursor: pointer;
}
.button:disabled {
  background-color: gray;
  cursor: not-allowed;
}
.small-button {
  background-color: mistyrose;
  border: 1px solid lightpink;
  outline: none;
  padding: 4px 8px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  border-radius: 4px;
  font-family: monospace;
  font-weight: bold;
  font-size: 14px;
}
.small-button:hover {
  background-color: lightpink;
  cursor: pointer;
}
#nina-group {
  position: absolute;
  border: none;
  border-width:0;
  outline: none;
}
.nina {
  position: absolute;
  border: none;
  border-width:0;
  outline: none;
  cursor: pointer;
}
#status {
  font-family: monospace;
  font-size: 12px;
  margin: 6px 0 6px 0;
  color: darkgreen;
}
#saving {
  font-size: x-small;
  font-family: monospace;
  color: gray;
  margin: 0px 0 20px 0;
}
.question {
  margin: 0 0 20px 0;
}
.answer {
  border: none;
  border-bottom: 1px solid darkgreen;
  padding: 0 0 6px 0;
  outline: none;
  font-family: monospace;
  font-size: 12px;
  color: darkgreen;
}
@media print {
  .button {
    display: none;
  }
  #report-bug {
    display: none;
  }
  #exolve-link {
    display: none;
  }
  @page {
    margin: 0.2in;
  }
  .clues-box {
    overflow-y: visible;
  }
}
</style>

</head>

<body onload="createPuzzle()">

<div class="flex-col" id="outermost-stack">
  <h2 id="title">Title</h2>
  <div id="setter"></div>
  <div id="prelude"></div>
  <div id="current-clue-parent">
    <div id="current-clue"></div>
  </div>
  <div class="flex-row">
    <div id="grid-panel">
      <div id="grid-parent-centerer">
        <div id="grid-parent">
          <svg id="grid" zoomAndPan="disable"></svg>
          <div id="grid-input-wrapper" style="display:none;left:0;top:0"><input id="grid-input" type="text" maxlength="2" autocomplete="off" spellcheck="false" class="cell-text"/></div>
          <div id="nina-group" style="display:none;left:0;top:0"></div>
          <div id="small-print">
            <a id="report-bug"
               href="https://github.com/viresh-ratnakar/exolve/issues/new">Report bug</a>
            <a id="exolve-link" href="https://github.com/viresh-ratnakar/exolve">Exolve on GitHub</a>
            <span id="copyright"></span>
	  </div> <!-- #small-print -->
        </div> <!-- #grid-parent -->
      </div> <!-- #grid-parent-centerer -->
      <div id="controls-etc">
        <div id="controls" class="wide-box">
          <div id="button-row-1" class="controls-row">
            <button id="clear" class="button"
                onclick="clearCurrent()">Clear this</button>
            <button id="clear-all" class="button"
                onclick="clearAll()">Clear all!</button>
            <button id="check" class="button" style="display:none"
                onclick="checkCurrent()">Check this</button>
            <button id="check-all" class="button" style="display:none"
                onclick="checkAll()">Check all!</button>
          </div> <!-- #button-row-1 -->
          <div id="button-row-2" class="controls-row">
            <button id="reveal" class="button" style="display:none"
                onclick="revealCurrent()">Reveal this</button>
            <button id="ninas" class="button" style="display:none"
                onclick="toggleNinas()">Show ninas</button>
            <button id="reveal-all" class="button" style="display:none"
                onclick="revealAll()">Reveal all!</button>
          </div> <!-- #button-row-2 -->
        </div> <!-- #controls -->
        <div id="errors"></div>
        <div id="status">
          Squares filled:
          <span id="status-num-filled">0</span>/<span
                id="status-num-total"></span>
        </div> <!-- #status -->
        <div id="saving" class="wide-box">
          The current state is saved automatically in a cookie for 90 days.
	  You can also copy <a id="saving-url" href="">this URL</a> as
	  a fallback option to bookmark/save the current state.
        </div> <!-- #saving -->
        <div id="questions" class="wide-box"></div> 
        <div id="submit-parent">
          <button id="submit" class="button" style="display:none"
              onclick="submitSolution()">Submit!</button>
        </div> <!-- submit-parent -->
        <div id="explanations" class="wide-box" style="display:none"></div>
      </div> <!-- #controls-etc -->
      <br/>
      <br/>
    </div> <!-- #grid-panel -->
    <div id="clues" class="flex-row">
      <div id="across-clues-panel" class="wide-box clues-box" style="display:none">
        <hr/>
        <b>Across</b>
        <table id="across"></table>
        <br/>
      </div> <!-- #across-clues-panel -->
      <div id="down-clues-panel" class="wide-box clues-box" style="display:none">
        <hr/>
        <b>Down</b>
        <table id="down"></table>
        <br/>
      </div> <!-- #down-clues-panel -->
      <div id="nodir-clues-panel" class="wide-box clues-box" style="display:none">
        <hr/>
        <table id="nodir"></table>
        <br/>
      </div> <!-- #nodir-clues-panel -->
    </div> <!-- #clues -->
  </div>
</div> <!-- #outermost-stack -->

</body>

</html>
